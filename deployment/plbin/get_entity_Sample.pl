use strict;
use Data::Dumper;
use Bio::KBase::Utilities::ScriptThing;
use Carp;

#
# This is a SAS Component
#

=head1 NAME

get_entity_Sample

=head1 SYNOPSIS

get_entity_Sample [-c N] [-a] [--fields field-list] < ids > table.with.fields.added

=head1 DESCRIPTION

A sample is an experiment.  
In intensity experiment situations the sample will map 1 to 1 to the GSM.  
In this case there will be corresponding log2level data stored in the Measurement table.


Example:

    get_entity_Sample -a < ids > table.with.fields.added

would read in a file of ids and add a column for each field in the entity.

The standard input should be a tab-separated table (i.e., each line
is a tab-separated set of fields).  Normally, the last field in each
line would contain the id. If some other column contains the id,
use

    -c N

where N is the column (from 1) that contains the id.

This is a pipe command. The input is taken from the standard input, and the
output is to the standard output.

=head2 Related entities

The Sample entity has the following relationship links:

=over 4
    
=item DefaultControlSample Sample

=item SampleAveragedFrom Sample

=item SampleBelongsToExperimentalUnit ExperimentalUnit

=item SampleComponentOf Sample

=item SampleContactPerson Person

=item SampleForStrain Strain

=item SampleHasAnnotations SampleAnnotation

=item SampleInSeries Series

=item SampleMeasurements Measurement

=item SampleRunOnPlatform Platform

=item SampleUsesProtocol Protocol

=item SamplesDefaultControl Sample

=item SamplesInReplicateGroup ReplicateGroup


=back

=head1 COMMAND-LINE OPTIONS

Usage: get_entity_Sample [arguments] < ids > table.with.fields.added

    -a		    Return all available fields.
    -c num          Select the identifier from column num.
    -i filename     Use filename rather than stdin for input.
    --fields list   Choose a set of fields to return. List is a comma-separated list of strings.
    -a		    Return all available fields.
    --show-fields   List the available fields.

The following fields are available:

=over 4    

=item title

free text title of the sample

=item dataSource

The Data Source will be a way to identify where the data came from.  Examples might be : GEO, SEED Expression Pipeline, Enigma, M3D

=item externalSourceId

The externalSourceId gives users potentially an easy way to find the data of interest (ex:GSM9514). This will keep them from having to do problematic likes on the source-id field.

=item description

Free-text descibing the experiment.

=item molecule

Enumerated field (total RNA, polyA RNA, cytoplasmic RNA, nuclear RNA, genomic DNA).

=item type

Enumerated Microarray, RNA-Seq, qPCR

=item kbaseSubmissionDate

date of submission to Kbase

=item externalSourceDate

date that may exist in the external source metadata (could be to GEO, M3D etc...)

=item custom

A flag to keep track if this series was generated by custom operations (averaging or comparison)

=item originalLog2Median

The Original Median of the sample in log2space.  If null means the original median was not able to be determined.

=item source_id

The ID of the environment used by the data source.

=item dataQualityLevel

The quality of the data.  Lower the number the better.  Details need to be worked out.


=back

=head1 AUTHORS

L<The SEED Project|http://www.theseed.org>

=cut


our $usage = <<'END';
Usage: get_entity_Sample [arguments] < ids > table.with.fields.added

    -c num          Select the identifier from column num
    -i filename     Use filename rather than stdin for input
    --fields list   Choose a set of fields to return. List is a comma-separated list of strings.
    -a		    Return all available fields.
    --show-fields   List the available fields.

The following fields are available:

    title
        free text title of the sample
    dataSource
        The Data Source will be a way to identify where the data came from.  Examples might be : GEO, SEED Expression Pipeline, Enigma, M3D
    externalSourceId
        The externalSourceId gives users potentially an easy way to find the data of interest (ex:GSM9514). This will keep them from having to do problematic likes on the source-id field.
    description
        Free-text descibing the experiment.
    molecule
        Enumerated field (total RNA, polyA RNA, cytoplasmic RNA, nuclear RNA, genomic DNA).
    type
        Enumerated Microarray, RNA-Seq, qPCR
    kbaseSubmissionDate
        date of submission to Kbase
    externalSourceDate
        date that may exist in the external source metadata (could be to GEO, M3D etc...)
    custom
        A flag to keep track if this series was generated by custom operations (averaging or comparison)
    originalLog2Median
        The Original Median of the sample in log2space.  If null means the original median was not able to be determined.
    source_id
        The ID of the environment used by the data source.
    dataQualityLevel
        The quality of the data.  Lower the number the better.  Details need to be worked out.
END



use Bio::KBase::CDMI::CDMIClient;
use Getopt::Long;

#Default fields

my @all_fields = ( 'title', 'dataSource', 'externalSourceId', 'description', 'molecule', 'type', 'kbaseSubmissionDate', 'externalSourceDate', 'custom', 'originalLog2Median', 'source_id', 'dataQualityLevel' );
my %all_fields = map { $_ => 1 } @all_fields;

my $column;
my $a;
my $f;
my $i = "-";
my @fields;
my $help;
my $show_fields;
my $geO = Bio::KBase::CDMI::CDMIClient->new_get_entity_for_script('c=i'		 => \$column,
								  "all-fields|a" => \$a,
								  "help|h"	 => \$help,
								  "show-fields"	 => \$show_fields,
								  "fields=s"	 => \$f,
								  'i=s'		 => \$i);
if ($help)
{
    print $usage;
    exit 0;
}

if ($show_fields)
{
    print STDERR "Available fields:\n";
    print STDERR "\t$_\n" foreach @all_fields;
    exit 0;
}

if ($a && $f) 
{
    print STDERR "Only one of the -a and --fields options may be specified\n";
    exit 1;
} 
if ($a)
{
    @fields = @all_fields;
}
elsif ($f) {
    my @err;
    for my $field (split(",", $f))
    {
	if (!$all_fields{$field})
	{
	    push(@err, $field);
	}
	else
	{
	    push(@fields, $field);
	}
    }
    if (@err)
    {
	print STDERR "get_entity_Sample: unknown fields @err. Valid fields are: @all_fields\n";
	exit 1;
    }
} else {
    print STDERR $usage;
    exit 1;
}

my $ih;
if ($i eq '-')
{
    $ih = \*STDIN;
}
else
{
    open($ih, "<", $i) or die "Cannot open input file $i: $!\n";
}

while (my @tuples = Bio::KBase::Utilities::ScriptThing::GetBatch($ih, undef, $column)) {
    my @h = map { $_->[0] } @tuples;
    my $h = $geO->get_entity_Sample(\@h, \@fields);
    for my $tuple (@tuples) {
        my @values;
        my ($id, $line) = @$tuple;
        my $v = $h->{$id};
	if (! defined($v))
	{
	    #nothing found for this id
	    print STDERR $line,"\n";
     	} else {
	    foreach $_ (@fields) {
		my $val = $v->{$_};
		push (@values, ref($val) eq 'ARRAY' ? join(",", @$val) : $val);
	    }
	    my $tail = join("\t", @values);
	    print "$line\t$tail\n";
        }
    }
}
__DATA__
