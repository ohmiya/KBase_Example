############################################################
#
# Autogenerated by the KBase type compiler -
# any changes made here will be overwritten
#
############################################################

try:
    import json as _json
except ImportError:
    import sys
    sys.path.append('simplejson-2.3.3')
    import simplejson as _json

import requests as _requests
import urlparse as _urlparse
import random as _random
import base64 as _base64
from ConfigParser import ConfigParser as _ConfigParser
import os as _os

_CT = 'content-type'
_AJ = 'application/json'
_URL_SCHEME = frozenset(['http', 'https'])


def _get_token(user_id, password,
               auth_svc='https://nexus.api.globusonline.org/goauth/token?' +
                        'grant_type=client_credentials'):
    # This is bandaid helper function until we get a full
    # KBase python auth client released
    auth = _base64.encodestring(user_id + ':' + password)
    headers = {'Authorization': 'Basic ' + auth}
    ret = _requests.get(auth_svc, headers=headers, allow_redirects=True)
    status = ret.status_code
    if status >= 200 and status <= 299:
        tok = _json.loads(ret.text)
    elif status == 403:
        raise Exception('Authentication failed: Bad user_id/password ' +
                        'combination for user %s' % (user_id))
    else:
        raise Exception(ret.text)
    return tok['access_token']


def _read_rcfile(file=_os.environ['HOME'] + '/.authrc'):  # @ReservedAssignment
    # Another bandaid to read in the ~/.authrc file if one is present
    authdata = None
    if _os.path.exists(file):
        try:
            with open(file) as authrc:
                rawdata = _json.load(authrc)
                # strip down whatever we read to only what is legit
                authdata = {x: rawdata.get(x) for x in (
                    'user_id', 'token', 'client_secret', 'keyfile',
                    'keyfile_passphrase', 'password')}
        except Exception, e:
            print "Error while reading authrc file %s: %s" % (file, e)
    return authdata


def _read_inifile(file=_os.environ.get(  # @ReservedAssignment
                  'KB_DEPLOYMENT_CONFIG', _os.environ['HOME'] +
                  '/.kbase_config')):
    # Another bandaid to read in the ~/.kbase_config file if one is present
    authdata = None
    if _os.path.exists(file):
        try:
            config = _ConfigParser()
            config.read(file)
            # strip down whatever we read to only what is legit
            authdata = {x: config.get('authentication', x)
                        if config.has_option('authentication', x)
                        else None for x in ('user_id', 'token',
                                            'client_secret', 'keyfile',
                                            'keyfile_passphrase', 'password')}
        except Exception, e:
            print "Error while reading INI file %s: %s" % (file, e)
    return authdata


class ServerError(Exception):

    def __init__(self, name, code, message, data=None, error=None):
        self.name = name
        self.code = code
        self.message = '' if message is None else message
        self.data = data or error or ''
        # data = JSON RPC 2.0, error = 1.1

    def __str__(self):
        return self.name + ': ' + str(self.code) + '. ' + self.message + \
            '\n' + self.data


class _JSONObjectEncoder(_json.JSONEncoder):

    def default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        if isinstance(obj, frozenset):
            return list(obj)
        return _json.JSONEncoder.default(self, obj)


class fbaModelServices(object):

    def __init__(self, url=None, timeout=30 * 60, user_id=None,
                 password=None, token=None, ignore_authrc=False,
                 trust_all_ssl_certificates=False):
        if url is None:
            raise ValueError('A url is required')
        scheme, _, _, _, _, _ = _urlparse.urlparse(url)
        if scheme not in _URL_SCHEME:
            raise ValueError(url + " isn't a valid http url")
        self.url = url
        self.timeout = int(timeout)
        self._headers = dict()
        self.trust_all_ssl_certificates = trust_all_ssl_certificates
        # token overrides user_id and password
        if token is not None:
            self._headers['AUTHORIZATION'] = token
        elif user_id is not None and password is not None:
            self._headers['AUTHORIZATION'] = _get_token(user_id, password)
        elif 'KB_AUTH_TOKEN' in _os.environ:
            self._headers['AUTHORIZATION'] = _os.environ.get('KB_AUTH_TOKEN')
        elif not ignore_authrc:
            authdata = _read_inifile()
            if authdata is None:
                authdata = _read_rcfile()
            if authdata is not None:
                if authdata.get('token') is not None:
                    self._headers['AUTHORIZATION'] = authdata['token']
                elif(authdata.get('user_id') is not None
                     and authdata.get('password') is not None):
                    self._headers['AUTHORIZATION'] = _get_token(
                        authdata['user_id'], authdata['password'])
        if self.timeout < 1:
            raise ValueError('Timeout value must be at least 1 second')

    def _call(self, method, params):
        arg_hash = {'method': method,
                    'params': params,
                    'version': '1.1',
                    'id': str(_random.random())[2:]
                    }

        body = _json.dumps(arg_hash, cls=_JSONObjectEncoder)
        ret = _requests.post(self.url, data=body, headers=self._headers,
                             timeout=self.timeout,
                             verify=not self.trust_all_ssl_certificates)
        if ret.status_code == _requests.codes.server_error:
            if _CT in ret.headers and ret.headers[_CT] == _AJ:
                err = _json.loads(ret.text)
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:
                    raise ServerError('Unknown', 0, ret.text)
            else:
                raise ServerError('Unknown', 0, ret.text)
        if ret.status_code != _requests.codes.OK:
            ret.raise_for_status()
        resp = _json.loads(ret.text)
        if 'result' not in resp:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')
        return resp['result']

    def get_models(self, input):
        resp = self._call('fbaModelServices.get_models',
                          [input])
        return resp[0]

    def get_fbas(self, input):
        resp = self._call('fbaModelServices.get_fbas',
                          [input])
        return resp[0]

    def get_gapfills(self, input):
        resp = self._call('fbaModelServices.get_gapfills',
                          [input])
        return resp[0]

    def get_gapgens(self, input):
        resp = self._call('fbaModelServices.get_gapgens',
                          [input])
        return resp[0]

    def get_reactions(self, input):
        resp = self._call('fbaModelServices.get_reactions',
                          [input])
        return resp[0]

    def get_compounds(self, input):
        resp = self._call('fbaModelServices.get_compounds',
                          [input])
        return resp[0]

    def get_alias(self, input):
        resp = self._call('fbaModelServices.get_alias',
                          [input])
        return resp[0]

    def get_aliassets(self, input):
        resp = self._call('fbaModelServices.get_aliassets',
                          [input])
        return resp[0]

    def get_media(self, input):
        resp = self._call('fbaModelServices.get_media',
                          [input])
        return resp[0]

    def get_biochemistry(self, input):
        resp = self._call('fbaModelServices.get_biochemistry',
                          [input])
        return resp[0]

    def import_probanno(self, input):
        resp = self._call('fbaModelServices.import_probanno',
                          [input])
        return resp[0]

    def genome_object_to_workspace(self, input):
        resp = self._call('fbaModelServices.genome_object_to_workspace',
                          [input])
        return resp[0]

    def genome_to_workspace(self, input):
        resp = self._call('fbaModelServices.genome_to_workspace',
                          [input])
        return resp[0]

    def domains_to_workspace(self, input):
        resp = self._call('fbaModelServices.domains_to_workspace',
                          [input])
        return resp[0]

    def compute_domains(self, params):
        resp = self._call('fbaModelServices.compute_domains',
                          [params])
        return resp[0]

    def add_feature_translation(self, input):
        resp = self._call('fbaModelServices.add_feature_translation',
                          [input])
        return resp[0]

    def genome_to_fbamodel(self, input):
        resp = self._call('fbaModelServices.genome_to_fbamodel',
                          [input])
        return resp[0]

    def translate_fbamodel(self, input):
        resp = self._call('fbaModelServices.translate_fbamodel',
                          [input])
        return resp[0]

    def build_pangenome(self, input):
        resp = self._call('fbaModelServices.build_pangenome',
                          [input])
        return resp[0]

    def genome_heatmap_from_pangenome(self, input):
        resp = self._call('fbaModelServices.genome_heatmap_from_pangenome',
                          [input])
        return resp[0]

    def ortholog_family_from_pangenome(self, input):
        resp = self._call('fbaModelServices.ortholog_family_from_pangenome',
                          [input])
        return resp[0]

    def pangenome_to_proteome_comparison(self, input):
        resp = self._call('fbaModelServices.pangenome_to_proteome_comparison',
                          [input])
        return resp[0]

    def import_fbamodel(self, input):
        resp = self._call('fbaModelServices.import_fbamodel',
                          [input])
        return resp[0]

    def export_fbamodel(self, input):
        resp = self._call('fbaModelServices.export_fbamodel',
                          [input])
        return resp[0]

    def export_object(self, input):
        resp = self._call('fbaModelServices.export_object',
                          [input])
        return resp[0]

    def export_genome(self, input):
        resp = self._call('fbaModelServices.export_genome',
                          [input])
        return resp[0]

    def adjust_model_reaction(self, input):
        resp = self._call('fbaModelServices.adjust_model_reaction',
                          [input])
        return resp[0]

    def adjust_biomass_reaction(self, input):
        resp = self._call('fbaModelServices.adjust_biomass_reaction',
                          [input])
        return resp[0]

    def addmedia(self, input):
        resp = self._call('fbaModelServices.addmedia',
                          [input])
        return resp[0]

    def export_media(self, input):
        resp = self._call('fbaModelServices.export_media',
                          [input])
        return resp[0]

    def runfba(self, input):
        resp = self._call('fbaModelServices.runfba',
                          [input])
        return resp[0]

    def quantitative_optimization(self, input):
        resp = self._call('fbaModelServices.quantitative_optimization',
                          [input])
        return resp[0]

    def generate_model_stats(self, input):
        resp = self._call('fbaModelServices.generate_model_stats',
                          [input])
        return resp[0]

    def minimize_reactions(self, input):
        resp = self._call('fbaModelServices.minimize_reactions',
                          [input])
        return resp[0]

    def export_fba(self, input):
        resp = self._call('fbaModelServices.export_fba',
                          [input])
        return resp[0]

    def import_phenotypes(self, input):
        resp = self._call('fbaModelServices.import_phenotypes',
                          [input])
        return resp[0]

    def simulate_phenotypes(self, input):
        resp = self._call('fbaModelServices.simulate_phenotypes',
                          [input])
        return resp[0]

    def add_media_transporters(self, input):
        resp = self._call('fbaModelServices.add_media_transporters',
                          [input])
        return resp[0]

    def export_phenotypeSimulationSet(self, input):
        resp = self._call('fbaModelServices.export_phenotypeSimulationSet',
                          [input])
        return resp[0]

    def integrate_reconciliation_solutions(self, input):
        resp = self._call('fbaModelServices.integrate_reconciliation_solutions',
                          [input])
        return resp[0]

    def queue_runfba(self, input):
        resp = self._call('fbaModelServices.queue_runfba',
                          [input])
        return resp[0]

    def queue_gapfill_model(self, input):
        resp = self._call('fbaModelServices.queue_gapfill_model',
                          [input])
        return resp[0]

    def gapfill_model(self, input):
        resp = self._call('fbaModelServices.gapfill_model',
                          [input])
        return resp[0]

    def queue_gapgen_model(self, input):
        resp = self._call('fbaModelServices.queue_gapgen_model',
                          [input])
        return resp[0]

    def gapgen_model(self, input):
        resp = self._call('fbaModelServices.gapgen_model',
                          [input])
        return resp[0]

    def queue_wildtype_phenotype_reconciliation(self, input):
        resp = self._call('fbaModelServices.queue_wildtype_phenotype_reconciliation',
                          [input])
        return resp[0]

    def queue_reconciliation_sensitivity_analysis(self, input):
        resp = self._call('fbaModelServices.queue_reconciliation_sensitivity_analysis',
                          [input])
        return resp[0]

    def queue_combine_wildtype_phenotype_reconciliation(self, input):
        resp = self._call('fbaModelServices.queue_combine_wildtype_phenotype_reconciliation',
                          [input])
        return resp[0]

    def run_job(self, input):
        resp = self._call('fbaModelServices.run_job',
                          [input])
        return resp[0]

    def queue_job(self, input):
        resp = self._call('fbaModelServices.queue_job',
                          [input])
        return resp[0]

    def set_cofactors(self, input):
        resp = self._call('fbaModelServices.set_cofactors',
                          [input])
        return resp[0]

    def find_reaction_synonyms(self, input):
        resp = self._call('fbaModelServices.find_reaction_synonyms',
                          [input])
        return resp[0]

    def role_to_reactions(self, params):
        resp = self._call('fbaModelServices.role_to_reactions',
                          [params])
        return resp[0]

    def reaction_sensitivity_analysis(self, input):
        resp = self._call('fbaModelServices.reaction_sensitivity_analysis',
                          [input])
        return resp[0]

    def filter_iterative_solutions(self, input):
        resp = self._call('fbaModelServices.filter_iterative_solutions',
                          [input])
        return resp[0]

    def delete_noncontributing_reactions(self, input):
        resp = self._call('fbaModelServices.delete_noncontributing_reactions',
                          [input])
        return resp[0]

    def annotate_workspace_Genome(self, params):
        resp = self._call('fbaModelServices.annotate_workspace_Genome',
                          [params])
        return resp[0]

    def gtf_to_genome(self, params):
        resp = self._call('fbaModelServices.gtf_to_genome',
                          [params])
        return resp[0]

    def fasta_to_ProteinSet(self, params):
        resp = self._call('fbaModelServices.fasta_to_ProteinSet',
                          [params])
        return resp[0]

    def ProteinSet_to_Genome(self, params):
        resp = self._call('fbaModelServices.ProteinSet_to_Genome',
                          [params])
        return resp[0]

    def fasta_to_ContigSet(self, params):
        resp = self._call('fbaModelServices.fasta_to_ContigSet',
                          [params])
        return resp[0]

    def ContigSet_to_Genome(self, params):
        resp = self._call('fbaModelServices.ContigSet_to_Genome',
                          [params])
        return resp[0]

    def probanno_to_genome(self, params):
        resp = self._call('fbaModelServices.probanno_to_genome',
                          [params])
        return resp[0]

    def get_mapping(self, params):
        resp = self._call('fbaModelServices.get_mapping',
                          [params])
        return resp[0]

    def subsystem_of_roles(self, params):
        resp = self._call('fbaModelServices.subsystem_of_roles',
                          [params])
        return resp[0]

    def adjust_mapping_role(self, params):
        resp = self._call('fbaModelServices.adjust_mapping_role',
                          [params])
        return resp[0]

    def adjust_mapping_complex(self, params):
        resp = self._call('fbaModelServices.adjust_mapping_complex',
                          [params])
        return resp[0]

    def adjust_mapping_subsystem(self, params):
        resp = self._call('fbaModelServices.adjust_mapping_subsystem',
                          [params])
        return resp[0]

    def get_template_model(self, params):
        resp = self._call('fbaModelServices.get_template_model',
                          [params])
        return resp[0]

    def import_template_fbamodel(self, input):
        resp = self._call('fbaModelServices.import_template_fbamodel',
                          [input])
        return resp[0]

    def adjust_template_reaction(self, params):
        resp = self._call('fbaModelServices.adjust_template_reaction',
                          [params])
        return resp[0]

    def adjust_template_biomass(self, params):
        resp = self._call('fbaModelServices.adjust_template_biomass',
                          [params])
        return resp[0]

    def add_stimuli(self, params):
        resp = self._call('fbaModelServices.add_stimuli',
                          [params])
        return resp[0]

    def import_regulatory_model(self, params):
        resp = self._call('fbaModelServices.import_regulatory_model',
                          [params])
        return resp[0]

    def compare_models(self, params):
        resp = self._call('fbaModelServices.compare_models',
                          [params])
        return resp[0]

    def compare_fbas(self, params):
        resp = self._call('fbaModelServices.compare_fbas',
                          [params])
        return resp[0]

    def compare_genomes(self, params):
        resp = self._call('fbaModelServices.compare_genomes',
                          [params])
        return resp[0]

    def import_metagenome_annotation(self, params):
        resp = self._call('fbaModelServices.import_metagenome_annotation',
                          [params])
        return resp[0]

    def models_to_community_model(self, params):
        resp = self._call('fbaModelServices.models_to_community_model',
                          [params])
        return resp[0]

    def metagenome_to_fbamodels(self, params):
        resp = self._call('fbaModelServices.metagenome_to_fbamodels',
                          [params])
        return resp[0]

    def import_expression(self, input):
        resp = self._call('fbaModelServices.import_expression',
                          [input])
        return resp[0]

    def import_regulome(self, input):
        resp = self._call('fbaModelServices.import_regulome',
                          [input])
        return resp[0]

    def create_promconstraint(self, params):
        resp = self._call('fbaModelServices.create_promconstraint',
                          [params])
        return resp[0]

    def add_biochemistry_compounds(self, params):
        resp = self._call('fbaModelServices.add_biochemistry_compounds',
                          [params])
        return resp[0]

    def update_object_references(self, params):
        resp = self._call('fbaModelServices.update_object_references',
                          [params])
        return resp[0]

    def add_reactions(self, params):
        resp = self._call('fbaModelServices.add_reactions',
                          [params])
        return resp[0]

    def remove_reactions(self, params):
        resp = self._call('fbaModelServices.remove_reactions',
                          [params])
        return resp[0]

    def modify_reactions(self, params):
        resp = self._call('fbaModelServices.modify_reactions',
                          [params])
        return resp[0]

    def add_features(self, params):
        resp = self._call('fbaModelServices.add_features',
                          [params])
        return resp[0]

    def remove_features(self, params):
        resp = self._call('fbaModelServices.remove_features',
                          [params])
        return resp[0]

    def modify_features(self, params):
        resp = self._call('fbaModelServices.modify_features',
                          [params])
        return resp[0]

    def import_trainingset(self, params):
        resp = self._call('fbaModelServices.import_trainingset',
                          [params])
        return resp[0]

    def preload_trainingset(self, params):
        resp = self._call('fbaModelServices.preload_trainingset',
                          [params])
        return resp[0]

    def build_classifier(self, params):
        resp = self._call('fbaModelServices.build_classifier',
                          [params])
        return resp[0]

    def classify_genomes(self, params):
        resp = self._call('fbaModelServices.classify_genomes',
                          [params])
        return resp[0]

    def build_tissue_model(self, params):
        resp = self._call('fbaModelServices.build_tissue_model',
                          [params])
        return resp[0]
