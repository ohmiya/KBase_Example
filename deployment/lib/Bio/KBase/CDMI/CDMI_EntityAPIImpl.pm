package Bio::KBase::CDMI::CDMI_EntityAPIImpl;
use strict;
use Bio::KBase::Exceptions;
# Use Semantic Versioning (2.0.0-rc.1)
# http://semver.org 
our $VERSION = "0.1.0";

=head1 NAME

CDMI_EntityAPI

=head1 DESCRIPTION



=cut

#BEGIN_HEADER

use Bio::KBase::CDMI::CDMI;

our $entity_field_defs = {
    'Alignment' => {
	id => 1,
		    'n_rows' => 1,
		    'n_cols' => 1,
		    'status' => 1,
		    'is_concatenation' => 1,
		    'sequence_type' => 1,
		    'timestamp' => 1,
		    'method' => 1,
		    'parameters' => 1,
		    'protocol' => 1,
		    'source_id' => 1,
	
    },
    'AlignmentAttribute' => {
	id => 1,
	
    },
    'AlignmentRow' => {
	id => 1,
		    'row_number' => 1,
		    'row_id' => 1,
		    'row_description' => 1,
		    'n_components' => 1,
		    'beg_pos_aln' => 1,
		    'end_pos_aln' => 1,
		    'md5_of_ungapped_sequence' => 1,
		    'sequence' => 1,
	
    },
    'AlleleFrequency' => {
	id => 1,
		    'source_id' => 1,
		    'position' => 1,
		    'minor_AF' => 1,
		    'minor_allele' => 1,
		    'major_AF' => 1,
		    'major_allele' => 1,
		    'obs_unit_count' => 1,
	
    },
    'Annotation' => {
	id => 1,
		    'annotator' => 1,
		    'comment' => 1,
		    'annotation_time' => 1,
	
    },
    'Assay' => {
	id => 1,
		    'source_id' => 1,
		    'assay_type' => 1,
		    'assay_type_id' => 1,
	
    },
    'Association' => {
	id => 1,
		    'name' => 1,
		    'description' => 1,
		    'directional' => 1,
		    'confidence' => 1,
		    'url' => 1,
	
    },
    'AssociationDataset' => {
	id => 1,
		    'description' => 1,
		    'data_source' => 1,
		    'url' => 1,
		    'association_type' => 1,
	
    },
    'AssociationDetectionType' => {
	id => 1,
		    'description' => 1,
	
    },
    'AtomicRegulon' => {
	id => 1,
	
    },
    'Attribute' => {
	id => 1,
		    'description' => 1,
	
    },
    'Biomass' => {
	id => 1,
		    'mod_date' => 1,
		    'name' => 1,
		    'dna' => 1,
		    'protein' => 1,
		    'cell_wall' => 1,
		    'lipid' => 1,
		    'cofactor' => 1,
		    'energy' => 1,
	
    },
    'CodonUsage' => {
	id => 1,
		    'frequencies' => 1,
		    'genetic_code' => 1,
		    'type' => 1,
		    'subtype' => 1,
	
    },
    'Complex' => {
	id => 1,
		    'name' => 1,
		    'source_id' => 1,
		    'mod_date' => 1,
	
    },
    'Compound' => {
	id => 1,
		    'label' => 1,
		    'abbr' => 1,
		    'source_id' => 1,
		    'ubiquitous' => 1,
		    'mod_date' => 1,
		    'mass' => 1,
		    'formula' => 1,
		    'charge' => 1,
		    'deltaG' => 1,
		    'deltaG_error' => 1,
	
    },
    'CompoundInstance' => {
	id => 1,
		    'charge' => 1,
		    'formula' => 1,
	
    },
    'ConservedDomainModel' => {
	id => 1,
		    'accession' => 1,
		    'short_name' => 1,
		    'description' => 1,
	
    },
    'Contig' => {
	id => 1,
		    'source_id' => 1,
	
    },
    'ContigChunk' => {
	id => 1,
		    'sequence' => 1,
	
    },
    'ContigSequence' => {
	id => 1,
		    'length' => 1,
	
    },
    'CoregulatedSet' => {
	id => 1,
		    'source_id' => 1,
		    'binding_location' => 1,
	
    },
    'Diagram' => {
	id => 1,
		    'name' => 1,
		    'content' => 1,
	
    },
    'EcNumber' => {
	id => 1,
		    'obsolete' => 1,
		    'replacedby' => 1,
	
    },
    'Effector' => {
	id => 1,
		    'name' => 1,
		    'effector_class' => 1,
	
    },
    'Environment' => {
	id => 1,
		    'temperature' => 1,
		    'description' => 1,
		    'oxygenConcentration' => 1,
		    'pH' => 1,
		    'source_id' => 1,
	
    },
    'Experiment' => {
	id => 1,
		    'source' => 1,
	
    },
    'ExperimentMeta' => {
	id => 1,
		    'title' => 1,
		    'description' => 1,
		    'source_id' => 1,
		    'startDate' => 1,
		    'comments' => 1,
	
    },
    'ExperimentalUnit' => {
	id => 1,
		    'source_id' => 1,
	
    },
    'ExperimentalUnitGroup' => {
	id => 1,
		    'source_id' => 1,
		    'name' => 1,
		    'comments' => 1,
		    'groupType' => 1,
	
    },
    'Family' => {
	id => 1,
		    'type' => 1,
		    'release' => 1,
		    'family_function' => 1,
		    'alignment' => 1,
	
    },
    'Feature' => {
	id => 1,
		    'feature_type' => 1,
		    'source_id' => 1,
		    'sequence_length' => 1,
		    'function' => 1,
		    'alias' => 1,
	
    },
    'Genome' => {
	id => 1,
		    'pegs' => 1,
		    'rnas' => 1,
		    'scientific_name' => 1,
		    'complete' => 1,
		    'prokaryotic' => 1,
		    'dna_size' => 1,
		    'contigs' => 1,
		    'domain' => 1,
		    'genetic_code' => 1,
		    'gc_content' => 1,
		    'phenotype' => 1,
		    'md5' => 1,
		    'source_id' => 1,
	
    },
    'Locality' => {
	id => 1,
		    'source_name' => 1,
		    'city' => 1,
		    'state' => 1,
		    'country' => 1,
		    'origcty' => 1,
		    'elevation' => 1,
		    'latitude' => 1,
		    'longitude' => 1,
		    'lo_accession' => 1,
	
    },
    'LocalizedCompound' => {
	id => 1,
	
    },
    'Location' => {
	id => 1,
		    'mod_date' => 1,
		    'name' => 1,
		    'source_id' => 1,
		    'abbr' => 1,
	
    },
    'LocationInstance' => {
	id => 1,
		    'index' => 1,
		    'label' => 1,
		    'pH' => 1,
		    'potential' => 1,
	
    },
    'Measurement' => {
	id => 1,
		    'source_id' => 1,
		    'value' => 1,
		    'mean' => 1,
		    'median' => 1,
		    'stddev' => 1,
		    'N' => 1,
		    'p_value' => 1,
		    'Z_score' => 1,
	
    },
    'MeasurementDescription' => {
	id => 1,
		    'name' => 1,
		    'description' => 1,
		    'unitOfMeasure' => 1,
		    'category' => 1,
		    'source_id' => 1,
	
    },
    'Media' => {
	id => 1,
		    'mod_date' => 1,
		    'name' => 1,
		    'is_minimal' => 1,
		    'source_id' => 1,
		    'type' => 1,
	
    },
    'Model' => {
	id => 1,
		    'mod_date' => 1,
		    'name' => 1,
		    'version' => 1,
		    'type' => 1,
		    'status' => 1,
		    'reaction_count' => 1,
		    'compound_count' => 1,
		    'annotation_count' => 1,
	
    },
    'OTU' => {
	id => 1,
	
    },
    'ObservationalUnit' => {
	id => 1,
		    'source_name' => 1,
		    'source_name2' => 1,
		    'plant_id' => 1,
	
    },
    'Ontology' => {
	id => 1,
		    'id' => 1,
		    'name' => 1,
		    'definition' => 1,
		    'ontologySource' => 1,
	
    },
    'Operon' => {
	id => 1,
	
    },
    'PairSet' => {
	id => 1,
		    'score' => 1,
	
    },
    'Pairing' => {
	id => 1,
	
    },
    'Parameter' => {
	id => 1,
	
    },
    'Person' => {
	id => 1,
		    'firstName' => 1,
		    'lastName' => 1,
		    'contactEmail' => 1,
		    'institution' => 1,
		    'source_id' => 1,
	
    },
    'Platform' => {
	id => 1,
		    'title' => 1,
		    'externalSourceId' => 1,
		    'technology' => 1,
		    'type' => 1,
		    'source_id' => 1,
	
    },
    'ProbeSet' => {
	id => 1,
	
    },
    'ProteinSequence' => {
	id => 1,
		    'sequence' => 1,
	
    },
    'Protocol' => {
	id => 1,
		    'name' => 1,
		    'description' => 1,
		    'source_id' => 1,
	
    },
    'Publication' => {
	id => 1,
		    'title' => 1,
		    'link' => 1,
		    'pubdate' => 1,
	
    },
    'Reaction' => {
	id => 1,
		    'mod_date' => 1,
		    'name' => 1,
		    'source_id' => 1,
		    'abbr' => 1,
		    'direction' => 1,
		    'deltaG' => 1,
		    'deltaG_error' => 1,
		    'thermodynamic_reversibility' => 1,
		    'default_protons' => 1,
		    'status' => 1,
	
    },
    'ReactionInstance' => {
	id => 1,
		    'direction' => 1,
		    'protons' => 1,
	
    },
    'Regulator' => {
	id => 1,
		    'name' => 1,
		    'rfam_id' => 1,
		    'tf_family' => 1,
		    'type' => 1,
		    'taxonomy' => 1,
	
    },
    'Regulog' => {
	id => 1,
		    'description' => 1,
	
    },
    'RegulogCollection' => {
	id => 1,
		    'name' => 1,
		    'description' => 1,
	
    },
    'Regulome' => {
	id => 1,
		    'description' => 1,
		    'creation_date' => 1,
	
    },
    'Regulon' => {
	id => 1,
		    'description' => 1,
	
    },
    'ReplicateGroup' => {
	id => 1,
	
    },
    'Role' => {
	id => 1,
		    'hypothetical' => 1,
	
    },
    'SSCell' => {
	id => 1,
	
    },
    'SSRow' => {
	id => 1,
		    'curated' => 1,
		    'region' => 1,
	
    },
    'Sample' => {
	id => 1,
		    'title' => 1,
		    'dataSource' => 1,
		    'externalSourceId' => 1,
		    'description' => 1,
		    'molecule' => 1,
		    'type' => 1,
		    'kbaseSubmissionDate' => 1,
		    'externalSourceDate' => 1,
		    'custom' => 1,
		    'originalLog2Median' => 1,
		    'source_id' => 1,
		    'dataQualityLevel' => 1,
	
    },
    'SampleAnnotation' => {
	id => 1,
		    'annotationDate' => 1,
		    'source_id' => 1,
	
    },
    'Scenario' => {
	id => 1,
		    'common_name' => 1,
	
    },
    'Series' => {
	id => 1,
		    'title' => 1,
		    'summary' => 1,
		    'design' => 1,
		    'externalSourceId' => 1,
		    'kbaseSubmissionDate' => 1,
		    'externalSourceDate' => 1,
		    'source_id' => 1,
	
    },
    'Source' => {
	id => 1,
		    'name' => 1,
		    'url' => 1,
		    'description' => 1,
	
    },
    'Strain' => {
	id => 1,
		    'name' => 1,
		    'description' => 1,
		    'source_id' => 1,
		    'aggregateData' => 1,
		    'wildtype' => 1,
		    'referenceStrain' => 1,
	
    },
    'StudyExperiment' => {
	id => 1,
		    'source_name' => 1,
		    'design' => 1,
		    'originator' => 1,
	
    },
    'Subsystem' => {
	id => 1,
		    'version' => 1,
		    'curator' => 1,
		    'notes' => 1,
		    'description' => 1,
		    'usable' => 1,
		    'private' => 1,
		    'cluster_based' => 1,
		    'experimental' => 1,
	
    },
    'SubsystemClass' => {
	id => 1,
	
    },
    'TaxonomicGrouping' => {
	id => 1,
		    'domain' => 1,
		    'hidden' => 1,
		    'scientific_name' => 1,
		    'alias' => 1,
	
    },
    'TimeSeries' => {
	id => 1,
		    'source_id' => 1,
		    'name' => 1,
		    'comments' => 1,
		    'timeUnits' => 1,
	
    },
    'Trait' => {
	id => 1,
		    'trait_name' => 1,
		    'unit_of_measure' => 1,
		    'TO_ID' => 1,
		    'protocol' => 1,
	
    },
    'Tree' => {
	id => 1,
		    'status' => 1,
		    'data_type' => 1,
		    'timestamp' => 1,
		    'method' => 1,
		    'parameters' => 1,
		    'protocol' => 1,
		    'source_id' => 1,
		    'newick' => 1,
	
    },
    'TreeAttribute' => {
	id => 1,
	
    },
    'TreeNodeAttribute' => {
	id => 1,
	
    },
    'Variant' => {
	id => 1,
		    'role_rule' => 1,
		    'code' => 1,
		    'type' => 1,
		    'comment' => 1,
	
    },

};

our $entity_field_rels = {
    'Alignment' => {
    },
    'AlignmentAttribute' => {
    },
    'AlignmentRow' => {
    },
    'AlleleFrequency' => {
    },
    'Annotation' => {
    },
    'Assay' => {
    },
    'Association' => {
    },
    'AssociationDataset' => {
    },
    'AssociationDetectionType' => {
    },
    'AtomicRegulon' => {
    },
    'Attribute' => {
    },
    'Biomass' => {
	    'name' => 'BiomassName',
    },
    'CodonUsage' => {
    },
    'Complex' => {
	    'name' => 'ComplexName',
    },
    'Compound' => {
    },
    'CompoundInstance' => {
    },
    'ConservedDomainModel' => {
    },
    'Contig' => {
    },
    'ContigChunk' => {
    },
    'ContigSequence' => {
    },
    'CoregulatedSet' => {
	    'binding_location' => 'CoregulatedSetBinding',
    },
    'Diagram' => {
	    'content' => 'DiagramContent',
    },
    'EcNumber' => {
    },
    'Effector' => {
    },
    'Environment' => {
    },
    'Experiment' => {
    },
    'ExperimentMeta' => {
    },
    'ExperimentalUnit' => {
    },
    'ExperimentalUnitGroup' => {
    },
    'Family' => {
	    'family_function' => 'FamilyFunction',
	    'alignment' => 'FamilyAlignment',
    },
    'Feature' => {
	    'alias' => 'FeatureAlias',
    },
    'Genome' => {
	    'phenotype' => 'GenomeSequencePhenotype',
    },
    'Locality' => {
    },
    'LocalizedCompound' => {
    },
    'Location' => {
    },
    'LocationInstance' => {
	    'label' => 'ModelCompartmentLabel',
    },
    'Measurement' => {
    },
    'MeasurementDescription' => {
    },
    'Media' => {
    },
    'Model' => {
    },
    'OTU' => {
    },
    'ObservationalUnit' => {
	    'source_name2' => 'ObservationalUnitName2',
    },
    'Ontology' => {
    },
    'Operon' => {
    },
    'PairSet' => {
    },
    'Pairing' => {
    },
    'Parameter' => {
    },
    'Person' => {
    },
    'Platform' => {
    },
    'ProbeSet' => {
    },
    'ProteinSequence' => {
    },
    'Protocol' => {
    },
    'Publication' => {
    },
    'Reaction' => {
    },
    'ReactionInstance' => {
    },
    'Regulator' => {
    },
    'Regulog' => {
    },
    'RegulogCollection' => {
    },
    'Regulome' => {
    },
    'Regulon' => {
    },
    'ReplicateGroup' => {
    },
    'Role' => {
    },
    'SSCell' => {
    },
    'SSRow' => {
    },
    'Sample' => {
    },
    'SampleAnnotation' => {
    },
    'Scenario' => {
    },
    'Series' => {
    },
    'Source' => {
    },
    'Strain' => {
    },
    'StudyExperiment' => {
    },
    'Subsystem' => {
    },
    'SubsystemClass' => {
    },
    'TaxonomicGrouping' => {
	    'alias' => 'TaxonomicGroupingAlias',
    },
    'TimeSeries' => {
    },
    'Trait' => {
    },
    'Tree' => {
    },
    'TreeAttribute' => {
    },
    'TreeNodeAttribute' => {
    },
    'Variant' => {
	    'role_rule' => 'VariantRole',
    },

};

our $relationship_field_defs = {
    'AffectsLevelOf' => {
	to_link => 1, from_link => 1,
		    'level' => 1,
	
    },
    'IsAffectedIn' => {
	to_link => 1, from_link => 1,
		    'level' => 1,
	
    },
    'Aligned' => {
	to_link => 1, from_link => 1,
	
    },
    'WasAlignedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'AssertsFunctionFor' => {
	to_link => 1, from_link => 1,
		    'function' => 1,
		    'external_id' => 1,
		    'organism' => 1,
		    'gi_number' => 1,
		    'release_date' => 1,
	
    },
    'HasAssertedFunctionFrom' => {
	to_link => 1, from_link => 1,
		    'function' => 1,
		    'external_id' => 1,
		    'organism' => 1,
		    'gi_number' => 1,
		    'release_date' => 1,
	
    },
    'AssociationFeature' => {
	to_link => 1, from_link => 1,
		    'stoichiometry' => 1,
		    'strength' => 1,
		    'rank' => 1,
	
    },
    'FeatureInteractsIn' => {
	to_link => 1, from_link => 1,
		    'stoichiometry' => 1,
		    'strength' => 1,
		    'rank' => 1,
	
    },
    'CompoundMeasuredBy' => {
	to_link => 1, from_link => 1,
	
    },
    'MeasuresCompound' => {
	to_link => 1, from_link => 1,
	
    },
    'Concerns' => {
	to_link => 1, from_link => 1,
	
    },
    'IsATopicOf' => {
	to_link => 1, from_link => 1,
	
    },
    'ConsistsOfCompounds' => {
	to_link => 1, from_link => 1,
		    'molar_ratio' => 1,
	
    },
    'ComponentOf' => {
	to_link => 1, from_link => 1,
		    'molar_ratio' => 1,
	
    },
    'Contains' => {
	to_link => 1, from_link => 1,
	
    },
    'IsContainedIn' => {
	to_link => 1, from_link => 1,
	
    },
    'ContainsAlignedDNA' => {
	to_link => 1, from_link => 1,
		    'index_in_concatenation' => 1,
		    'beg_pos_in_parent' => 1,
		    'end_pos_in_parent' => 1,
		    'parent_seq_len' => 1,
		    'beg_pos_aln' => 1,
		    'end_pos_aln' => 1,
		    'kb_feature_id' => 1,
	
    },
    'IsAlignedDNAComponentOf' => {
	to_link => 1, from_link => 1,
		    'index_in_concatenation' => 1,
		    'beg_pos_in_parent' => 1,
		    'end_pos_in_parent' => 1,
		    'parent_seq_len' => 1,
		    'beg_pos_aln' => 1,
		    'end_pos_aln' => 1,
		    'kb_feature_id' => 1,
	
    },
    'ContainsAlignedProtein' => {
	to_link => 1, from_link => 1,
		    'index_in_concatenation' => 1,
		    'beg_pos_in_parent' => 1,
		    'end_pos_in_parent' => 1,
		    'parent_seq_len' => 1,
		    'beg_pos_aln' => 1,
		    'end_pos_aln' => 1,
		    'kb_feature_id' => 1,
	
    },
    'IsAlignedProteinComponentOf' => {
	to_link => 1, from_link => 1,
		    'index_in_concatenation' => 1,
		    'beg_pos_in_parent' => 1,
		    'end_pos_in_parent' => 1,
		    'parent_seq_len' => 1,
		    'beg_pos_aln' => 1,
		    'end_pos_aln' => 1,
		    'kb_feature_id' => 1,
	
    },
    'ContainsExperimentalUnit' => {
	to_link => 1, from_link => 1,
		    'location' => 1,
		    'groupMeta' => 1,
	
    },
    'GroupedBy' => {
	to_link => 1, from_link => 1,
		    'location' => 1,
		    'groupMeta' => 1,
	
    },
    'Controls' => {
	to_link => 1, from_link => 1,
	
    },
    'IsControlledUsing' => {
	to_link => 1, from_link => 1,
	
    },
    'DefaultControlSample' => {
	to_link => 1, from_link => 1,
	
    },
    'SamplesDefaultControl' => {
	to_link => 1, from_link => 1,
	
    },
    'Describes' => {
	to_link => 1, from_link => 1,
	
    },
    'IsDescribedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'DescribesAlignment' => {
	to_link => 1, from_link => 1,
		    'value' => 1,
	
    },
    'HasAlignmentAttribute' => {
	to_link => 1, from_link => 1,
		    'value' => 1,
	
    },
    'DescribesMeasurement' => {
	to_link => 1, from_link => 1,
	
    },
    'IsDefinedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'DescribesTree' => {
	to_link => 1, from_link => 1,
		    'value' => 1,
	
    },
    'HasTreeAttribute' => {
	to_link => 1, from_link => 1,
		    'value' => 1,
	
    },
    'DescribesTreeNode' => {
	to_link => 1, from_link => 1,
		    'value' => 1,
		    'node_id' => 1,
	
    },
    'HasNodeAttribute' => {
	to_link => 1, from_link => 1,
		    'value' => 1,
		    'node_id' => 1,
	
    },
    'DetectedWithMethod' => {
	to_link => 1, from_link => 1,
	
    },
    'DetectedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'Displays' => {
	to_link => 1, from_link => 1,
		    'location' => 1,
	
    },
    'IsDisplayedOn' => {
	to_link => 1, from_link => 1,
		    'location' => 1,
	
    },
    'Encompasses' => {
	to_link => 1, from_link => 1,
	
    },
    'IsEncompassedIn' => {
	to_link => 1, from_link => 1,
	
    },
    'EvaluatedIn' => {
	to_link => 1, from_link => 1,
	
    },
    'IncludesStrain' => {
	to_link => 1, from_link => 1,
	
    },
    'FeatureIsTranscriptionFactorFor' => {
	to_link => 1, from_link => 1,
	
    },
    'HasTranscriptionFactorFeature' => {
	to_link => 1, from_link => 1,
	
    },
    'FeatureMeasuredBy' => {
	to_link => 1, from_link => 1,
	
    },
    'MeasuresFeature' => {
	to_link => 1, from_link => 1,
	
    },
    'Formulated' => {
	to_link => 1, from_link => 1,
	
    },
    'WasFormulatedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'GeneratedLevelsFor' => {
	to_link => 1, from_link => 1,
		    'level_vector' => 1,
	
    },
    'WasGeneratedFrom' => {
	to_link => 1, from_link => 1,
		    'level_vector' => 1,
	
    },
    'GenomeParentOf' => {
	to_link => 1, from_link => 1,
	
    },
    'DerivedFromGenome' => {
	to_link => 1, from_link => 1,
	
    },
    'HasAliasAssertedFrom' => {
	to_link => 1, from_link => 1,
		    'alias' => 1,
	
    },
    'AssertsAliasFor' => {
	to_link => 1, from_link => 1,
		    'alias' => 1,
	
    },
    'HasCompoundAliasFrom' => {
	to_link => 1, from_link => 1,
		    'alias' => 1,
	
    },
    'UsesAliasForCompound' => {
	to_link => 1, from_link => 1,
		    'alias' => 1,
	
    },
    'HasEffector' => {
	to_link => 1, from_link => 1,
	
    },
    'IsEffectorFor' => {
	to_link => 1, from_link => 1,
	
    },
    'HasExperimentalUnit' => {
	to_link => 1, from_link => 1,
	
    },
    'IsExperimentalUnitOf' => {
	to_link => 1, from_link => 1,
	
    },
    'HasExpressionSample' => {
	to_link => 1, from_link => 1,
	
    },
    'SampleBelongsToExperimentalUnit' => {
	to_link => 1, from_link => 1,
	
    },
    'HasGenomes' => {
	to_link => 1, from_link => 1,
	
    },
    'IsInRegulogCollection' => {
	to_link => 1, from_link => 1,
	
    },
    'HasIndicatedSignalFrom' => {
	to_link => 1, from_link => 1,
		    'rma_value' => 1,
		    'level' => 1,
	
    },
    'IndicatesSignalFor' => {
	to_link => 1, from_link => 1,
		    'rma_value' => 1,
		    'level' => 1,
	
    },
    'HasKnockoutIn' => {
	to_link => 1, from_link => 1,
	
    },
    'KnockedOutIn' => {
	to_link => 1, from_link => 1,
	
    },
    'HasMeasurement' => {
	to_link => 1, from_link => 1,
	
    },
    'IsMeasureOf' => {
	to_link => 1, from_link => 1,
	
    },
    'HasMember' => {
	to_link => 1, from_link => 1,
	
    },
    'IsMemberOf' => {
	to_link => 1, from_link => 1,
	
    },
    'HasParameter' => {
	to_link => 1, from_link => 1,
		    'value' => 1,
	
    },
    'OfEnvironment' => {
	to_link => 1, from_link => 1,
		    'value' => 1,
	
    },
    'HasParticipant' => {
	to_link => 1, from_link => 1,
		    'type' => 1,
	
    },
    'ParticipatesIn' => {
	to_link => 1, from_link => 1,
		    'type' => 1,
	
    },
    'HasPresenceOf' => {
	to_link => 1, from_link => 1,
		    'concentration' => 1,
		    'minimum_flux' => 1,
		    'maximum_flux' => 1,
	
    },
    'IsPresentIn' => {
	to_link => 1, from_link => 1,
		    'concentration' => 1,
		    'minimum_flux' => 1,
		    'maximum_flux' => 1,
	
    },
    'HasProteinMember' => {
	to_link => 1, from_link => 1,
		    'source_id' => 1,
	
    },
    'IsProteinMemberOf' => {
	to_link => 1, from_link => 1,
		    'source_id' => 1,
	
    },
    'HasReactionAliasFrom' => {
	to_link => 1, from_link => 1,
		    'alias' => 1,
	
    },
    'UsesAliasForReaction' => {
	to_link => 1, from_link => 1,
		    'alias' => 1,
	
    },
    'HasRegulogs' => {
	to_link => 1, from_link => 1,
	
    },
    'IsInCollection' => {
	to_link => 1, from_link => 1,
	
    },
    'HasRepresentativeOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsRepresentedIn' => {
	to_link => 1, from_link => 1,
	
    },
    'HasRequirementOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsARequirementOf' => {
	to_link => 1, from_link => 1,
	
    },
    'HasResultsIn' => {
	to_link => 1, from_link => 1,
		    'sequence' => 1,
	
    },
    'HasResultsFor' => {
	to_link => 1, from_link => 1,
		    'sequence' => 1,
	
    },
    'HasSection' => {
	to_link => 1, from_link => 1,
	
    },
    'IsSectionOf' => {
	to_link => 1, from_link => 1,
	
    },
    'HasStep' => {
	to_link => 1, from_link => 1,
	
    },
    'IsStepOf' => {
	to_link => 1, from_link => 1,
	
    },
    'HasTrait' => {
	to_link => 1, from_link => 1,
		    'value' => 1,
		    'statistic_type' => 1,
		    'measure_id' => 1,
	
    },
    'Measures' => {
	to_link => 1, from_link => 1,
		    'value' => 1,
		    'statistic_type' => 1,
		    'measure_id' => 1,
	
    },
    'HasUnits' => {
	to_link => 1, from_link => 1,
	
    },
    'IsLocated' => {
	to_link => 1, from_link => 1,
	
    },
    'HasUsage' => {
	to_link => 1, from_link => 1,
	
    },
    'IsUsageOf' => {
	to_link => 1, from_link => 1,
	
    },
    'HasValueFor' => {
	to_link => 1, from_link => 1,
		    'value' => 1,
	
    },
    'HasValueIn' => {
	to_link => 1, from_link => 1,
		    'value' => 1,
	
    },
    'HasVariationIn' => {
	to_link => 1, from_link => 1,
		    'position' => 1,
		    'len' => 1,
		    'data' => 1,
		    'data2' => 1,
		    'quality' => 1,
	
    },
    'IsVariedIn' => {
	to_link => 1, from_link => 1,
		    'position' => 1,
		    'len' => 1,
		    'data' => 1,
		    'data2' => 1,
		    'quality' => 1,
	
    },
    'Impacts' => {
	to_link => 1, from_link => 1,
		    'source_name' => 1,
		    'rank' => 1,
		    'pvalue' => 1,
		    'position' => 1,
	
    },
    'IsImpactedBy' => {
	to_link => 1, from_link => 1,
		    'source_name' => 1,
		    'rank' => 1,
		    'pvalue' => 1,
		    'position' => 1,
	
    },
    'ImplementsReaction' => {
	to_link => 1, from_link => 1,
	
    },
    'ImplementedBasedOn' => {
	to_link => 1, from_link => 1,
	
    },
    'Includes' => {
	to_link => 1, from_link => 1,
		    'sequence' => 1,
		    'abbreviation' => 1,
		    'auxiliary' => 1,
	
    },
    'IsIncludedIn' => {
	to_link => 1, from_link => 1,
		    'sequence' => 1,
		    'abbreviation' => 1,
		    'auxiliary' => 1,
	
    },
    'IncludesAdditionalCompounds' => {
	to_link => 1, from_link => 1,
		    'concentration' => 1,
		    'units' => 1,
	
    },
    'IncludedIn' => {
	to_link => 1, from_link => 1,
		    'concentration' => 1,
		    'units' => 1,
	
    },
    'IncludesAlignmentRow' => {
	to_link => 1, from_link => 1,
	
    },
    'IsAlignmentRowIn' => {
	to_link => 1, from_link => 1,
	
    },
    'IncludesPart' => {
	to_link => 1, from_link => 1,
	
    },
    'IsPartOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IndicatedLevelsFor' => {
	to_link => 1, from_link => 1,
		    'level_vector' => 1,
	
    },
    'HasLevelsFrom' => {
	to_link => 1, from_link => 1,
		    'level_vector' => 1,
	
    },
    'Involves' => {
	to_link => 1, from_link => 1,
		    'coefficient' => 1,
		    'cofactor' => 1,
	
    },
    'IsInvolvedIn' => {
	to_link => 1, from_link => 1,
		    'coefficient' => 1,
		    'cofactor' => 1,
	
    },
    'IsAnnotatedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'Annotates' => {
	to_link => 1, from_link => 1,
	
    },
    'IsAssayOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsAssayedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'IsClassFor' => {
	to_link => 1, from_link => 1,
	
    },
    'IsInClass' => {
	to_link => 1, from_link => 1,
	
    },
    'IsCollectionOf' => {
	to_link => 1, from_link => 1,
		    'representative' => 1,
	
    },
    'IsCollectedInto' => {
	to_link => 1, from_link => 1,
		    'representative' => 1,
	
    },
    'IsComposedOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsComponentOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsComprisedOf' => {
	to_link => 1, from_link => 1,
		    'coefficient' => 1,
	
    },
    'Comprises' => {
	to_link => 1, from_link => 1,
		    'coefficient' => 1,
	
    },
    'IsConfiguredBy' => {
	to_link => 1, from_link => 1,
	
    },
    'ReflectsStateOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsConservedDomainModelFor' => {
	to_link => 1, from_link => 1,
		    'percent_identity' => 1,
		    'alignment_length' => 1,
		    'mismatches' => 1,
		    'gap_openings' => 1,
		    'protein_start' => 1,
		    'protein_end' => 1,
		    'domain_start' => 1,
		    'domain_end' => 1,
		    'e_value' => 1,
		    'bit_score' => 1,
	
    },
    'HasConservedDomainModel' => {
	to_link => 1, from_link => 1,
		    'percent_identity' => 1,
		    'alignment_length' => 1,
		    'mismatches' => 1,
		    'gap_openings' => 1,
		    'protein_start' => 1,
		    'protein_end' => 1,
		    'domain_start' => 1,
		    'domain_end' => 1,
		    'e_value' => 1,
		    'bit_score' => 1,
	
    },
    'IsConsistentWith' => {
	to_link => 1, from_link => 1,
	
    },
    'IsConsistentTo' => {
	to_link => 1, from_link => 1,
	
    },
    'IsContextOf' => {
	to_link => 1, from_link => 1,
	
    },
    'HasEnvironment' => {
	to_link => 1, from_link => 1,
	
    },
    'IsCoregulatedWith' => {
	to_link => 1, from_link => 1,
		    'coefficient' => 1,
	
    },
    'HasCoregulationWith' => {
	to_link => 1, from_link => 1,
		    'coefficient' => 1,
	
    },
    'IsCoupledTo' => {
	to_link => 1, from_link => 1,
		    'co_occurrence_evidence' => 1,
		    'co_expression_evidence' => 1,
	
    },
    'IsCoupledWith' => {
	to_link => 1, from_link => 1,
		    'co_occurrence_evidence' => 1,
		    'co_expression_evidence' => 1,
	
    },
    'IsDatasetFor' => {
	to_link => 1, from_link => 1,
	
    },
    'HasAssociationDataset' => {
	to_link => 1, from_link => 1,
	
    },
    'IsDeterminedBy' => {
	to_link => 1, from_link => 1,
		    'inverted' => 1,
	
    },
    'Determines' => {
	to_link => 1, from_link => 1,
		    'inverted' => 1,
	
    },
    'IsDividedInto' => {
	to_link => 1, from_link => 1,
	
    },
    'IsDivisionOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsExecutedAs' => {
	to_link => 1, from_link => 1,
	
    },
    'IsExecutionOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsExemplarOf' => {
	to_link => 1, from_link => 1,
	
    },
    'HasAsExemplar' => {
	to_link => 1, from_link => 1,
	
    },
    'IsFamilyFor' => {
	to_link => 1, from_link => 1,
	
    },
    'DeterminesFunctionOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsFormedOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsFormedInto' => {
	to_link => 1, from_link => 1,
	
    },
    'IsFunctionalIn' => {
	to_link => 1, from_link => 1,
	
    },
    'HasFunctional' => {
	to_link => 1, from_link => 1,
	
    },
    'IsGroupFor' => {
	to_link => 1, from_link => 1,
	
    },
    'IsInGroup' => {
	to_link => 1, from_link => 1,
	
    },
    'IsGroupingOf' => {
	to_link => 1, from_link => 1,
	
    },
    'InAssociationDataset' => {
	to_link => 1, from_link => 1,
	
    },
    'IsImplementedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'Implements' => {
	to_link => 1, from_link => 1,
	
    },
    'IsInOperon' => {
	to_link => 1, from_link => 1,
		    'rank' => 1,
	
    },
    'OperonContains' => {
	to_link => 1, from_link => 1,
		    'rank' => 1,
	
    },
    'IsInPair' => {
	to_link => 1, from_link => 1,
	
    },
    'IsPairOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsInstantiatedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'IsInstanceOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsLocatedIn' => {
	to_link => 1, from_link => 1,
		    'ordinal' => 1,
		    'begin' => 1,
		    'len' => 1,
		    'dir' => 1,
	
    },
    'IsLocusFor' => {
	to_link => 1, from_link => 1,
		    'ordinal' => 1,
		    'begin' => 1,
		    'len' => 1,
		    'dir' => 1,
	
    },
    'IsMeasurementMethodOf' => {
	to_link => 1, from_link => 1,
	
    },
    'WasMeasuredBy' => {
	to_link => 1, from_link => 1,
	
    },
    'IsModeledBy' => {
	to_link => 1, from_link => 1,
	
    },
    'Models' => {
	to_link => 1, from_link => 1,
	
    },
    'IsModifiedToBuildAlignment' => {
	to_link => 1, from_link => 1,
		    'modification_type' => 1,
		    'modification_value' => 1,
	
    },
    'IsModificationOfAlignment' => {
	to_link => 1, from_link => 1,
		    'modification_type' => 1,
		    'modification_value' => 1,
	
    },
    'IsModifiedToBuildTree' => {
	to_link => 1, from_link => 1,
		    'modification_type' => 1,
		    'modification_value' => 1,
	
    },
    'IsModificationOfTree' => {
	to_link => 1, from_link => 1,
		    'modification_type' => 1,
		    'modification_value' => 1,
	
    },
    'IsOwnerOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsOwnedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'IsParticipatingAt' => {
	to_link => 1, from_link => 1,
	
    },
    'ParticipatesAt' => {
	to_link => 1, from_link => 1,
	
    },
    'IsProteinFor' => {
	to_link => 1, from_link => 1,
	
    },
    'Produces' => {
	to_link => 1, from_link => 1,
	
    },
    'IsReagentIn' => {
	to_link => 1, from_link => 1,
		    'coefficient' => 1,
	
    },
    'Targets' => {
	to_link => 1, from_link => 1,
		    'coefficient' => 1,
	
    },
    'IsRealLocationOf' => {
	to_link => 1, from_link => 1,
	
    },
    'HasRealLocationIn' => {
	to_link => 1, from_link => 1,
	
    },
    'IsReferencedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'UsesReference' => {
	to_link => 1, from_link => 1,
	
    },
    'IsRegulatedIn' => {
	to_link => 1, from_link => 1,
	
    },
    'IsRegulatedSetOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsRegulatorFor' => {
	to_link => 1, from_link => 1,
	
    },
    'HasRegulator' => {
	to_link => 1, from_link => 1,
	
    },
    'IsRegulatorForRegulon' => {
	to_link => 1, from_link => 1,
	
    },
    'ReglonHasRegulator' => {
	to_link => 1, from_link => 1,
	
    },
    'IsRegulatorySiteFor' => {
	to_link => 1, from_link => 1,
	
    },
    'HasRegulatorySite' => {
	to_link => 1, from_link => 1,
	
    },
    'IsRelevantFor' => {
	to_link => 1, from_link => 1,
	
    },
    'IsRelevantTo' => {
	to_link => 1, from_link => 1,
	
    },
    'IsRepresentedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'DefinedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'IsRoleOf' => {
	to_link => 1, from_link => 1,
	
    },
    'HasRole' => {
	to_link => 1, from_link => 1,
	
    },
    'IsRowOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsRoleFor' => {
	to_link => 1, from_link => 1,
	
    },
    'IsSequenceOf' => {
	to_link => 1, from_link => 1,
	
    },
    'HasAsSequence' => {
	to_link => 1, from_link => 1,
	
    },
    'IsSourceForAssociationDataset' => {
	to_link => 1, from_link => 1,
	
    },
    'AssociationDatasetSourcedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'IsSubInstanceOf' => {
	to_link => 1, from_link => 1,
	
    },
    'Validates' => {
	to_link => 1, from_link => 1,
	
    },
    'IsSummarizedBy' => {
	to_link => 1, from_link => 1,
		    'position' => 1,
	
    },
    'Summarizes' => {
	to_link => 1, from_link => 1,
		    'position' => 1,
	
    },
    'IsSuperclassOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsSubclassOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsTaxonomyOf' => {
	to_link => 1, from_link => 1,
	
    },
    'IsInTaxa' => {
	to_link => 1, from_link => 1,
	
    },
    'IsTerminusFor' => {
	to_link => 1, from_link => 1,
		    'group_number' => 1,
	
    },
    'HasAsTerminus' => {
	to_link => 1, from_link => 1,
		    'group_number' => 1,
	
    },
    'IsTriggeredBy' => {
	to_link => 1, from_link => 1,
		    'optional' => 1,
		    'type' => 1,
		    'triggering' => 1,
	
    },
    'Triggers' => {
	to_link => 1, from_link => 1,
		    'optional' => 1,
		    'type' => 1,
		    'triggering' => 1,
	
    },
    'IsUsedToBuildTree' => {
	to_link => 1, from_link => 1,
	
    },
    'IsBuiltFromAlignment' => {
	to_link => 1, from_link => 1,
	
    },
    'Manages' => {
	to_link => 1, from_link => 1,
	
    },
    'IsManagedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'OntologyForSample' => {
	to_link => 1, from_link => 1,
	
    },
    'SampleHasOntology' => {
	to_link => 1, from_link => 1,
	
    },
    'OperatesIn' => {
	to_link => 1, from_link => 1,
	
    },
    'IsUtilizedIn' => {
	to_link => 1, from_link => 1,
	
    },
    'OrdersExperimentalUnit' => {
	to_link => 1, from_link => 1,
		    'time' => 1,
		    'timeMeta' => 1,
	
    },
    'IsTimepointOf' => {
	to_link => 1, from_link => 1,
		    'time' => 1,
		    'timeMeta' => 1,
	
    },
    'Overlaps' => {
	to_link => 1, from_link => 1,
	
    },
    'IncludesPartOf' => {
	to_link => 1, from_link => 1,
	
    },
    'ParticipatesAs' => {
	to_link => 1, from_link => 1,
	
    },
    'IsParticipationOf' => {
	to_link => 1, from_link => 1,
	
    },
    'PerformedExperiment' => {
	to_link => 1, from_link => 1,
		    'role' => 1,
	
    },
    'PerformedBy' => {
	to_link => 1, from_link => 1,
		    'role' => 1,
	
    },
    'PersonAnnotatedSample' => {
	to_link => 1, from_link => 1,
	
    },
    'SampleAnnotatedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'PlatformWithSamples' => {
	to_link => 1, from_link => 1,
	
    },
    'SampleRunOnPlatform' => {
	to_link => 1, from_link => 1,
	
    },
    'ProducedResultsFor' => {
	to_link => 1, from_link => 1,
	
    },
    'HadResultsProducedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'ProtocolForSample' => {
	to_link => 1, from_link => 1,
	
    },
    'SampleUsesProtocol' => {
	to_link => 1, from_link => 1,
	
    },
    'Provided' => {
	to_link => 1, from_link => 1,
	
    },
    'WasProvidedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'PublishedAssociation' => {
	to_link => 1, from_link => 1,
	
    },
    'AssociationPublishedIn' => {
	to_link => 1, from_link => 1,
	
    },
    'PublishedExperiment' => {
	to_link => 1, from_link => 1,
	
    },
    'ExperimentPublishedIn' => {
	to_link => 1, from_link => 1,
	
    },
    'PublishedProtocol' => {
	to_link => 1, from_link => 1,
	
    },
    'ProtocolPublishedIn' => {
	to_link => 1, from_link => 1,
	
    },
    'RegulogHasRegulon' => {
	to_link => 1, from_link => 1,
	
    },
    'RegulonIsInRegolog' => {
	to_link => 1, from_link => 1,
	
    },
    'RegulomeHasGenome' => {
	to_link => 1, from_link => 1,
	
    },
    'GenomeIsInRegulome' => {
	to_link => 1, from_link => 1,
	
    },
    'RegulomeHasRegulon' => {
	to_link => 1, from_link => 1,
	
    },
    'RegulonIsInRegolome' => {
	to_link => 1, from_link => 1,
	
    },
    'RegulomeSource' => {
	to_link => 1, from_link => 1,
	
    },
    'CreatedRegulome' => {
	to_link => 1, from_link => 1,
	
    },
    'RegulonHasOperon' => {
	to_link => 1, from_link => 1,
	
    },
    'OperonIsInRegulon' => {
	to_link => 1, from_link => 1,
	
    },
    'SampleAveragedFrom' => {
	to_link => 1, from_link => 1,
	
    },
    'SampleComponentOf' => {
	to_link => 1, from_link => 1,
	
    },
    'SampleContactPerson' => {
	to_link => 1, from_link => 1,
	
    },
    'PersonPerformedSample' => {
	to_link => 1, from_link => 1,
	
    },
    'SampleHasAnnotations' => {
	to_link => 1, from_link => 1,
	
    },
    'AnnotationsForSample' => {
	to_link => 1, from_link => 1,
	
    },
    'SampleInSeries' => {
	to_link => 1, from_link => 1,
	
    },
    'SeriesWithSamples' => {
	to_link => 1, from_link => 1,
	
    },
    'SampleMeasurements' => {
	to_link => 1, from_link => 1,
	
    },
    'MeasurementInSample' => {
	to_link => 1, from_link => 1,
	
    },
    'SamplesInReplicateGroup' => {
	to_link => 1, from_link => 1,
	
    },
    'ReplicateGroupsForSample' => {
	to_link => 1, from_link => 1,
	
    },
    'SeriesPublishedIn' => {
	to_link => 1, from_link => 1,
	
    },
    'PublicationsForSeries' => {
	to_link => 1, from_link => 1,
	
    },
    'Shows' => {
	to_link => 1, from_link => 1,
		    'location' => 1,
	
    },
    'IsShownOn' => {
	to_link => 1, from_link => 1,
		    'location' => 1,
	
    },
    'StrainParentOf' => {
	to_link => 1, from_link => 1,
	
    },
    'DerivedFromStrain' => {
	to_link => 1, from_link => 1,
	
    },
    'StrainWithPlatforms' => {
	to_link => 1, from_link => 1,
	
    },
    'PlatformForStrain' => {
	to_link => 1, from_link => 1,
	
    },
    'StrainWithSample' => {
	to_link => 1, from_link => 1,
	
    },
    'SampleForStrain' => {
	to_link => 1, from_link => 1,
	
    },
    'Submitted' => {
	to_link => 1, from_link => 1,
	
    },
    'WasSubmittedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'SupersedesAlignment' => {
	to_link => 1, from_link => 1,
		    'successor_type' => 1,
	
    },
    'IsSupersededByAlignment' => {
	to_link => 1, from_link => 1,
		    'successor_type' => 1,
	
    },
    'SupersedesTree' => {
	to_link => 1, from_link => 1,
		    'successor_type' => 1,
	
    },
    'IsSupersededByTree' => {
	to_link => 1, from_link => 1,
		    'successor_type' => 1,
	
    },
    'Treed' => {
	to_link => 1, from_link => 1,
	
    },
    'IsTreeFrom' => {
	to_link => 1, from_link => 1,
	
    },
    'UsedIn' => {
	to_link => 1, from_link => 1,
	
    },
    'HasMedia' => {
	to_link => 1, from_link => 1,
	
    },
    'Uses' => {
	to_link => 1, from_link => 1,
	
    },
    'IsUsedBy' => {
	to_link => 1, from_link => 1,
	
    },
    'UsesCodons' => {
	to_link => 1, from_link => 1,
	
    },
    'AreCodonsFor' => {
	to_link => 1, from_link => 1,
	
    },

};

our $relationship_field_rels = {
    'AffectsLevelOf' => {
    },
    'IsAffectedIn' => {
    },
    'Aligned' => {
    },
    'WasAlignedBy' => {
    },
    'AssertsFunctionFor' => {
    },
    'HasAssertedFunctionFrom' => {
    },
    'AssociationFeature' => {
    },
    'FeatureInteractsIn' => {
    },
    'CompoundMeasuredBy' => {
    },
    'MeasuresCompound' => {
    },
    'Concerns' => {
    },
    'IsATopicOf' => {
    },
    'ConsistsOfCompounds' => {
    },
    'ComponentOf' => {
    },
    'Contains' => {
    },
    'IsContainedIn' => {
    },
    'ContainsAlignedDNA' => {
    },
    'IsAlignedDNAComponentOf' => {
    },
    'ContainsAlignedProtein' => {
    },
    'IsAlignedProteinComponentOf' => {
    },
    'ContainsExperimentalUnit' => {
    },
    'GroupedBy' => {
    },
    'Controls' => {
    },
    'IsControlledUsing' => {
    },
    'DefaultControlSample' => {
    },
    'SamplesDefaultControl' => {
    },
    'Describes' => {
    },
    'IsDescribedBy' => {
    },
    'DescribesAlignment' => {
    },
    'HasAlignmentAttribute' => {
    },
    'DescribesMeasurement' => {
    },
    'IsDefinedBy' => {
    },
    'DescribesTree' => {
    },
    'HasTreeAttribute' => {
    },
    'DescribesTreeNode' => {
    },
    'HasNodeAttribute' => {
    },
    'DetectedWithMethod' => {
    },
    'DetectedBy' => {
    },
    'Displays' => {
    },
    'IsDisplayedOn' => {
    },
    'Encompasses' => {
    },
    'IsEncompassedIn' => {
    },
    'EvaluatedIn' => {
    },
    'IncludesStrain' => {
    },
    'FeatureIsTranscriptionFactorFor' => {
    },
    'HasTranscriptionFactorFeature' => {
    },
    'FeatureMeasuredBy' => {
    },
    'MeasuresFeature' => {
    },
    'Formulated' => {
    },
    'WasFormulatedBy' => {
    },
    'GeneratedLevelsFor' => {
    },
    'WasGeneratedFrom' => {
    },
    'GenomeParentOf' => {
    },
    'DerivedFromGenome' => {
    },
    'HasAliasAssertedFrom' => {
    },
    'AssertsAliasFor' => {
    },
    'HasCompoundAliasFrom' => {
    },
    'UsesAliasForCompound' => {
    },
    'HasEffector' => {
    },
    'IsEffectorFor' => {
    },
    'HasExperimentalUnit' => {
    },
    'IsExperimentalUnitOf' => {
    },
    'HasExpressionSample' => {
    },
    'SampleBelongsToExperimentalUnit' => {
    },
    'HasGenomes' => {
    },
    'IsInRegulogCollection' => {
    },
    'HasIndicatedSignalFrom' => {
    },
    'IndicatesSignalFor' => {
    },
    'HasKnockoutIn' => {
    },
    'KnockedOutIn' => {
    },
    'HasMeasurement' => {
    },
    'IsMeasureOf' => {
    },
    'HasMember' => {
    },
    'IsMemberOf' => {
    },
    'HasParameter' => {
    },
    'OfEnvironment' => {
    },
    'HasParticipant' => {
    },
    'ParticipatesIn' => {
    },
    'HasPresenceOf' => {
    },
    'IsPresentIn' => {
    },
    'HasProteinMember' => {
    },
    'IsProteinMemberOf' => {
    },
    'HasReactionAliasFrom' => {
    },
    'UsesAliasForReaction' => {
    },
    'HasRegulogs' => {
    },
    'IsInCollection' => {
    },
    'HasRepresentativeOf' => {
    },
    'IsRepresentedIn' => {
    },
    'HasRequirementOf' => {
    },
    'IsARequirementOf' => {
    },
    'HasResultsIn' => {
    },
    'HasResultsFor' => {
    },
    'HasSection' => {
    },
    'IsSectionOf' => {
    },
    'HasStep' => {
    },
    'IsStepOf' => {
    },
    'HasTrait' => {
    },
    'Measures' => {
    },
    'HasUnits' => {
    },
    'IsLocated' => {
    },
    'HasUsage' => {
    },
    'IsUsageOf' => {
    },
    'HasValueFor' => {
    },
    'HasValueIn' => {
    },
    'HasVariationIn' => {
    },
    'IsVariedIn' => {
    },
    'Impacts' => {
    },
    'IsImpactedBy' => {
    },
    'ImplementsReaction' => {
    },
    'ImplementedBasedOn' => {
    },
    'Includes' => {
    },
    'IsIncludedIn' => {
    },
    'IncludesAdditionalCompounds' => {
    },
    'IncludedIn' => {
    },
    'IncludesAlignmentRow' => {
    },
    'IsAlignmentRowIn' => {
    },
    'IncludesPart' => {
    },
    'IsPartOf' => {
    },
    'IndicatedLevelsFor' => {
    },
    'HasLevelsFrom' => {
    },
    'Involves' => {
    },
    'IsInvolvedIn' => {
    },
    'IsAnnotatedBy' => {
    },
    'Annotates' => {
    },
    'IsAssayOf' => {
    },
    'IsAssayedBy' => {
    },
    'IsClassFor' => {
    },
    'IsInClass' => {
    },
    'IsCollectionOf' => {
    },
    'IsCollectedInto' => {
    },
    'IsComposedOf' => {
    },
    'IsComponentOf' => {
    },
    'IsComprisedOf' => {
    },
    'Comprises' => {
    },
    'IsConfiguredBy' => {
    },
    'ReflectsStateOf' => {
    },
    'IsConservedDomainModelFor' => {
    },
    'HasConservedDomainModel' => {
    },
    'IsConsistentWith' => {
    },
    'IsConsistentTo' => {
    },
    'IsContextOf' => {
    },
    'HasEnvironment' => {
    },
    'IsCoregulatedWith' => {
    },
    'HasCoregulationWith' => {
    },
    'IsCoupledTo' => {
    },
    'IsCoupledWith' => {
    },
    'IsDatasetFor' => {
    },
    'HasAssociationDataset' => {
    },
    'IsDeterminedBy' => {
    },
    'Determines' => {
    },
    'IsDividedInto' => {
    },
    'IsDivisionOf' => {
    },
    'IsExecutedAs' => {
    },
    'IsExecutionOf' => {
    },
    'IsExemplarOf' => {
    },
    'HasAsExemplar' => {
    },
    'IsFamilyFor' => {
    },
    'DeterminesFunctionOf' => {
    },
    'IsFormedOf' => {
    },
    'IsFormedInto' => {
    },
    'IsFunctionalIn' => {
    },
    'HasFunctional' => {
    },
    'IsGroupFor' => {
    },
    'IsInGroup' => {
    },
    'IsGroupingOf' => {
    },
    'InAssociationDataset' => {
    },
    'IsImplementedBy' => {
    },
    'Implements' => {
    },
    'IsInOperon' => {
    },
    'OperonContains' => {
    },
    'IsInPair' => {
    },
    'IsPairOf' => {
    },
    'IsInstantiatedBy' => {
    },
    'IsInstanceOf' => {
    },
    'IsLocatedIn' => {
    },
    'IsLocusFor' => {
    },
    'IsMeasurementMethodOf' => {
    },
    'WasMeasuredBy' => {
    },
    'IsModeledBy' => {
    },
    'Models' => {
    },
    'IsModifiedToBuildAlignment' => {
    },
    'IsModificationOfAlignment' => {
    },
    'IsModifiedToBuildTree' => {
    },
    'IsModificationOfTree' => {
    },
    'IsOwnerOf' => {
    },
    'IsOwnedBy' => {
    },
    'IsParticipatingAt' => {
    },
    'ParticipatesAt' => {
    },
    'IsProteinFor' => {
    },
    'Produces' => {
    },
    'IsReagentIn' => {
    },
    'Targets' => {
    },
    'IsRealLocationOf' => {
    },
    'HasRealLocationIn' => {
    },
    'IsReferencedBy' => {
    },
    'UsesReference' => {
    },
    'IsRegulatedIn' => {
    },
    'IsRegulatedSetOf' => {
    },
    'IsRegulatorFor' => {
    },
    'HasRegulator' => {
    },
    'IsRegulatorForRegulon' => {
    },
    'ReglonHasRegulator' => {
    },
    'IsRegulatorySiteFor' => {
    },
    'HasRegulatorySite' => {
    },
    'IsRelevantFor' => {
    },
    'IsRelevantTo' => {
    },
    'IsRepresentedBy' => {
    },
    'DefinedBy' => {
    },
    'IsRoleOf' => {
    },
    'HasRole' => {
    },
    'IsRowOf' => {
    },
    'IsRoleFor' => {
    },
    'IsSequenceOf' => {
    },
    'HasAsSequence' => {
    },
    'IsSourceForAssociationDataset' => {
    },
    'AssociationDatasetSourcedBy' => {
    },
    'IsSubInstanceOf' => {
    },
    'Validates' => {
    },
    'IsSummarizedBy' => {
    },
    'Summarizes' => {
    },
    'IsSuperclassOf' => {
    },
    'IsSubclassOf' => {
    },
    'IsTaxonomyOf' => {
    },
    'IsInTaxa' => {
    },
    'IsTerminusFor' => {
    },
    'HasAsTerminus' => {
    },
    'IsTriggeredBy' => {
    },
    'Triggers' => {
    },
    'IsUsedToBuildTree' => {
    },
    'IsBuiltFromAlignment' => {
    },
    'Manages' => {
    },
    'IsManagedBy' => {
    },
    'OntologyForSample' => {
    },
    'SampleHasOntology' => {
    },
    'OperatesIn' => {
    },
    'IsUtilizedIn' => {
    },
    'OrdersExperimentalUnit' => {
    },
    'IsTimepointOf' => {
    },
    'Overlaps' => {
    },
    'IncludesPartOf' => {
    },
    'ParticipatesAs' => {
    },
    'IsParticipationOf' => {
    },
    'PerformedExperiment' => {
    },
    'PerformedBy' => {
    },
    'PersonAnnotatedSample' => {
    },
    'SampleAnnotatedBy' => {
    },
    'PlatformWithSamples' => {
    },
    'SampleRunOnPlatform' => {
    },
    'ProducedResultsFor' => {
    },
    'HadResultsProducedBy' => {
    },
    'ProtocolForSample' => {
    },
    'SampleUsesProtocol' => {
    },
    'Provided' => {
    },
    'WasProvidedBy' => {
    },
    'PublishedAssociation' => {
    },
    'AssociationPublishedIn' => {
    },
    'PublishedExperiment' => {
    },
    'ExperimentPublishedIn' => {
    },
    'PublishedProtocol' => {
    },
    'ProtocolPublishedIn' => {
    },
    'RegulogHasRegulon' => {
    },
    'RegulonIsInRegolog' => {
    },
    'RegulomeHasGenome' => {
    },
    'GenomeIsInRegulome' => {
    },
    'RegulomeHasRegulon' => {
    },
    'RegulonIsInRegolome' => {
    },
    'RegulomeSource' => {
    },
    'CreatedRegulome' => {
    },
    'RegulonHasOperon' => {
    },
    'OperonIsInRegulon' => {
    },
    'SampleAveragedFrom' => {
    },
    'SampleComponentOf' => {
    },
    'SampleContactPerson' => {
    },
    'PersonPerformedSample' => {
    },
    'SampleHasAnnotations' => {
    },
    'AnnotationsForSample' => {
    },
    'SampleInSeries' => {
    },
    'SeriesWithSamples' => {
    },
    'SampleMeasurements' => {
    },
    'MeasurementInSample' => {
    },
    'SamplesInReplicateGroup' => {
    },
    'ReplicateGroupsForSample' => {
    },
    'SeriesPublishedIn' => {
    },
    'PublicationsForSeries' => {
    },
    'Shows' => {
    },
    'IsShownOn' => {
    },
    'StrainParentOf' => {
    },
    'DerivedFromStrain' => {
    },
    'StrainWithPlatforms' => {
    },
    'PlatformForStrain' => {
    },
    'StrainWithSample' => {
    },
    'SampleForStrain' => {
    },
    'Submitted' => {
    },
    'WasSubmittedBy' => {
    },
    'SupersedesAlignment' => {
    },
    'IsSupersededByAlignment' => {
    },
    'SupersedesTree' => {
    },
    'IsSupersededByTree' => {
    },
    'Treed' => {
    },
    'IsTreeFrom' => {
    },
    'UsedIn' => {
    },
    'HasMedia' => {
    },
    'Uses' => {
    },
    'IsUsedBy' => {
    },
    'UsesCodons' => {
    },
    'AreCodonsFor' => {
    },

};

our $relationship_entities = {
    'AffectsLevelOf' => [ 'Experiment', 'AtomicRegulon' ],
    'IsAffectedIn' => [ 'AtomicRegulon', 'Experiment' ],
    'Aligned' => [ 'Source', 'Alignment' ],
    'WasAlignedBy' => [ 'Alignment', 'Source' ],
    'AssertsFunctionFor' => [ 'Source', 'ProteinSequence' ],
    'HasAssertedFunctionFrom' => [ 'ProteinSequence', 'Source' ],
    'AssociationFeature' => [ 'Association', 'Feature' ],
    'FeatureInteractsIn' => [ 'Feature', 'Association' ],
    'CompoundMeasuredBy' => [ 'Compound', 'Measurement' ],
    'MeasuresCompound' => [ 'Measurement', 'Compound' ],
    'Concerns' => [ 'Publication', 'ProteinSequence' ],
    'IsATopicOf' => [ 'ProteinSequence', 'Publication' ],
    'ConsistsOfCompounds' => [ 'Compound', 'Compound' ],
    'ComponentOf' => [ 'Compound', 'Compound' ],
    'Contains' => [ 'SSCell', 'Feature' ],
    'IsContainedIn' => [ 'Feature', 'SSCell' ],
    'ContainsAlignedDNA' => [ 'AlignmentRow', 'ContigSequence' ],
    'IsAlignedDNAComponentOf' => [ 'ContigSequence', 'AlignmentRow' ],
    'ContainsAlignedProtein' => [ 'AlignmentRow', 'ProteinSequence' ],
    'IsAlignedProteinComponentOf' => [ 'ProteinSequence', 'AlignmentRow' ],
    'ContainsExperimentalUnit' => [ 'ExperimentalUnitGroup', 'ExperimentalUnit' ],
    'GroupedBy' => [ 'ExperimentalUnit', 'ExperimentalUnitGroup' ],
    'Controls' => [ 'Feature', 'CoregulatedSet' ],
    'IsControlledUsing' => [ 'CoregulatedSet', 'Feature' ],
    'DefaultControlSample' => [ 'Sample', 'Sample' ],
    'SamplesDefaultControl' => [ 'Sample', 'Sample' ],
    'Describes' => [ 'Subsystem', 'Variant' ],
    'IsDescribedBy' => [ 'Variant', 'Subsystem' ],
    'DescribesAlignment' => [ 'AlignmentAttribute', 'Alignment' ],
    'HasAlignmentAttribute' => [ 'Alignment', 'AlignmentAttribute' ],
    'DescribesMeasurement' => [ 'MeasurementDescription', 'Measurement' ],
    'IsDefinedBy' => [ 'Measurement', 'MeasurementDescription' ],
    'DescribesTree' => [ 'TreeAttribute', 'Tree' ],
    'HasTreeAttribute' => [ 'Tree', 'TreeAttribute' ],
    'DescribesTreeNode' => [ 'TreeNodeAttribute', 'Tree' ],
    'HasNodeAttribute' => [ 'Tree', 'TreeNodeAttribute' ],
    'DetectedWithMethod' => [ 'AssociationDetectionType', 'Association' ],
    'DetectedBy' => [ 'Association', 'AssociationDetectionType' ],
    'Displays' => [ 'Diagram', 'Reaction' ],
    'IsDisplayedOn' => [ 'Reaction', 'Diagram' ],
    'Encompasses' => [ 'Feature', 'Feature' ],
    'IsEncompassedIn' => [ 'Feature', 'Feature' ],
    'EvaluatedIn' => [ 'Strain', 'ExperimentalUnit' ],
    'IncludesStrain' => [ 'ExperimentalUnit', 'Strain' ],
    'FeatureIsTranscriptionFactorFor' => [ 'Feature', 'Regulon' ],
    'HasTranscriptionFactorFeature' => [ 'Regulon', 'Feature' ],
    'FeatureMeasuredBy' => [ 'Feature', 'Measurement' ],
    'MeasuresFeature' => [ 'Measurement', 'Feature' ],
    'Formulated' => [ 'Source', 'CoregulatedSet' ],
    'WasFormulatedBy' => [ 'CoregulatedSet', 'Source' ],
    'GeneratedLevelsFor' => [ 'ProbeSet', 'AtomicRegulon' ],
    'WasGeneratedFrom' => [ 'AtomicRegulon', 'ProbeSet' ],
    'GenomeParentOf' => [ 'Genome', 'Strain' ],
    'DerivedFromGenome' => [ 'Strain', 'Genome' ],
    'HasAliasAssertedFrom' => [ 'Feature', 'Source' ],
    'AssertsAliasFor' => [ 'Source', 'Feature' ],
    'HasCompoundAliasFrom' => [ 'Source', 'Compound' ],
    'UsesAliasForCompound' => [ 'Compound', 'Source' ],
    'HasEffector' => [ 'Regulon', 'Effector' ],
    'IsEffectorFor' => [ 'Effector', 'Regulon' ],
    'HasExperimentalUnit' => [ 'ExperimentMeta', 'ExperimentalUnit' ],
    'IsExperimentalUnitOf' => [ 'ExperimentalUnit', 'ExperimentMeta' ],
    'HasExpressionSample' => [ 'ExperimentalUnit', 'Sample' ],
    'SampleBelongsToExperimentalUnit' => [ 'Sample', 'ExperimentalUnit' ],
    'HasGenomes' => [ 'RegulogCollection', 'Genome' ],
    'IsInRegulogCollection' => [ 'Genome', 'RegulogCollection' ],
    'HasIndicatedSignalFrom' => [ 'Feature', 'Experiment' ],
    'IndicatesSignalFor' => [ 'Experiment', 'Feature' ],
    'HasKnockoutIn' => [ 'Strain', 'Feature' ],
    'KnockedOutIn' => [ 'Feature', 'Strain' ],
    'HasMeasurement' => [ 'ExperimentalUnit', 'Measurement' ],
    'IsMeasureOf' => [ 'Measurement', 'ExperimentalUnit' ],
    'HasMember' => [ 'Family', 'Feature' ],
    'IsMemberOf' => [ 'Feature', 'Family' ],
    'HasParameter' => [ 'Environment', 'Parameter' ],
    'OfEnvironment' => [ 'Parameter', 'Environment' ],
    'HasParticipant' => [ 'Scenario', 'Reaction' ],
    'ParticipatesIn' => [ 'Reaction', 'Scenario' ],
    'HasPresenceOf' => [ 'Media', 'Compound' ],
    'IsPresentIn' => [ 'Compound', 'Media' ],
    'HasProteinMember' => [ 'Family', 'ProteinSequence' ],
    'IsProteinMemberOf' => [ 'ProteinSequence', 'Family' ],
    'HasReactionAliasFrom' => [ 'Source', 'Reaction' ],
    'UsesAliasForReaction' => [ 'Reaction', 'Source' ],
    'HasRegulogs' => [ 'RegulogCollection', 'Regulog' ],
    'IsInCollection' => [ 'Regulog', 'RegulogCollection' ],
    'HasRepresentativeOf' => [ 'Genome', 'Family' ],
    'IsRepresentedIn' => [ 'Family', 'Genome' ],
    'HasRequirementOf' => [ 'Model', 'ReactionInstance' ],
    'IsARequirementOf' => [ 'ReactionInstance', 'Model' ],
    'HasResultsIn' => [ 'ProbeSet', 'Experiment' ],
    'HasResultsFor' => [ 'Experiment', 'ProbeSet' ],
    'HasSection' => [ 'ContigSequence', 'ContigChunk' ],
    'IsSectionOf' => [ 'ContigChunk', 'ContigSequence' ],
    'HasStep' => [ 'Complex', 'Reaction' ],
    'IsStepOf' => [ 'Reaction', 'Complex' ],
    'HasTrait' => [ 'ObservationalUnit', 'Trait' ],
    'Measures' => [ 'Trait', 'ObservationalUnit' ],
    'HasUnits' => [ 'Locality', 'ObservationalUnit' ],
    'IsLocated' => [ 'ObservationalUnit', 'Locality' ],
    'HasUsage' => [ 'LocalizedCompound', 'CompoundInstance' ],
    'IsUsageOf' => [ 'CompoundInstance', 'LocalizedCompound' ],
    'HasValueFor' => [ 'Experiment', 'Attribute' ],
    'HasValueIn' => [ 'Attribute', 'Experiment' ],
    'HasVariationIn' => [ 'Contig', 'ObservationalUnit' ],
    'IsVariedIn' => [ 'ObservationalUnit', 'Contig' ],
    'Impacts' => [ 'Trait', 'Contig' ],
    'IsImpactedBy' => [ 'Contig', 'Trait' ],
    'ImplementsReaction' => [ 'Feature', 'ReactionInstance' ],
    'ImplementedBasedOn' => [ 'ReactionInstance', 'Feature' ],
    'Includes' => [ 'Subsystem', 'Role' ],
    'IsIncludedIn' => [ 'Role', 'Subsystem' ],
    'IncludesAdditionalCompounds' => [ 'Environment', 'Compound' ],
    'IncludedIn' => [ 'Compound', 'Environment' ],
    'IncludesAlignmentRow' => [ 'Alignment', 'AlignmentRow' ],
    'IsAlignmentRowIn' => [ 'AlignmentRow', 'Alignment' ],
    'IncludesPart' => [ 'StudyExperiment', 'ObservationalUnit' ],
    'IsPartOf' => [ 'ObservationalUnit', 'StudyExperiment' ],
    'IndicatedLevelsFor' => [ 'ProbeSet', 'Feature' ],
    'HasLevelsFrom' => [ 'Feature', 'ProbeSet' ],
    'Involves' => [ 'Reaction', 'LocalizedCompound' ],
    'IsInvolvedIn' => [ 'LocalizedCompound', 'Reaction' ],
    'IsAnnotatedBy' => [ 'Feature', 'Annotation' ],
    'Annotates' => [ 'Annotation', 'Feature' ],
    'IsAssayOf' => [ 'Assay', 'StudyExperiment' ],
    'IsAssayedBy' => [ 'StudyExperiment', 'Assay' ],
    'IsClassFor' => [ 'SubsystemClass', 'Subsystem' ],
    'IsInClass' => [ 'Subsystem', 'SubsystemClass' ],
    'IsCollectionOf' => [ 'OTU', 'Genome' ],
    'IsCollectedInto' => [ 'Genome', 'OTU' ],
    'IsComposedOf' => [ 'Genome', 'Contig' ],
    'IsComponentOf' => [ 'Contig', 'Genome' ],
    'IsComprisedOf' => [ 'Biomass', 'CompoundInstance' ],
    'Comprises' => [ 'CompoundInstance', 'Biomass' ],
    'IsConfiguredBy' => [ 'Genome', 'AtomicRegulon' ],
    'ReflectsStateOf' => [ 'AtomicRegulon', 'Genome' ],
    'IsConservedDomainModelFor' => [ 'ConservedDomainModel', 'ProteinSequence' ],
    'HasConservedDomainModel' => [ 'ProteinSequence', 'ConservedDomainModel' ],
    'IsConsistentWith' => [ 'EcNumber', 'Role' ],
    'IsConsistentTo' => [ 'Role', 'EcNumber' ],
    'IsContextOf' => [ 'Environment', 'ExperimentalUnit' ],
    'HasEnvironment' => [ 'ExperimentalUnit', 'Environment' ],
    'IsCoregulatedWith' => [ 'Feature', 'Feature' ],
    'HasCoregulationWith' => [ 'Feature', 'Feature' ],
    'IsCoupledTo' => [ 'Family', 'Family' ],
    'IsCoupledWith' => [ 'Family', 'Family' ],
    'IsDatasetFor' => [ 'AssociationDataset', 'Genome' ],
    'HasAssociationDataset' => [ 'Genome', 'AssociationDataset' ],
    'IsDeterminedBy' => [ 'PairSet', 'Pairing' ],
    'Determines' => [ 'Pairing', 'PairSet' ],
    'IsDividedInto' => [ 'Model', 'LocationInstance' ],
    'IsDivisionOf' => [ 'LocationInstance', 'Model' ],
    'IsExecutedAs' => [ 'Reaction', 'ReactionInstance' ],
    'IsExecutionOf' => [ 'ReactionInstance', 'Reaction' ],
    'IsExemplarOf' => [ 'Feature', 'Role' ],
    'HasAsExemplar' => [ 'Role', 'Feature' ],
    'IsFamilyFor' => [ 'Family', 'Role' ],
    'DeterminesFunctionOf' => [ 'Role', 'Family' ],
    'IsFormedOf' => [ 'AtomicRegulon', 'Feature' ],
    'IsFormedInto' => [ 'Feature', 'AtomicRegulon' ],
    'IsFunctionalIn' => [ 'Role', 'Feature' ],
    'HasFunctional' => [ 'Feature', 'Role' ],
    'IsGroupFor' => [ 'TaxonomicGrouping', 'TaxonomicGrouping' ],
    'IsInGroup' => [ 'TaxonomicGrouping', 'TaxonomicGrouping' ],
    'IsGroupingOf' => [ 'AssociationDataset', 'Association' ],
    'InAssociationDataset' => [ 'Association', 'AssociationDataset' ],
    'IsImplementedBy' => [ 'Variant', 'SSRow' ],
    'Implements' => [ 'SSRow', 'Variant' ],
    'IsInOperon' => [ 'Feature', 'Operon' ],
    'OperonContains' => [ 'Operon', 'Feature' ],
    'IsInPair' => [ 'Feature', 'Pairing' ],
    'IsPairOf' => [ 'Pairing', 'Feature' ],
    'IsInstantiatedBy' => [ 'Location', 'LocationInstance' ],
    'IsInstanceOf' => [ 'LocationInstance', 'Location' ],
    'IsLocatedIn' => [ 'Feature', 'Contig' ],
    'IsLocusFor' => [ 'Contig', 'Feature' ],
    'IsMeasurementMethodOf' => [ 'Protocol', 'Measurement' ],
    'WasMeasuredBy' => [ 'Measurement', 'Protocol' ],
    'IsModeledBy' => [ 'Genome', 'Model' ],
    'Models' => [ 'Model', 'Genome' ],
    'IsModifiedToBuildAlignment' => [ 'Alignment', 'Alignment' ],
    'IsModificationOfAlignment' => [ 'Alignment', 'Alignment' ],
    'IsModifiedToBuildTree' => [ 'Tree', 'Tree' ],
    'IsModificationOfTree' => [ 'Tree', 'Tree' ],
    'IsOwnerOf' => [ 'Genome', 'Feature' ],
    'IsOwnedBy' => [ 'Feature', 'Genome' ],
    'IsParticipatingAt' => [ 'Location', 'LocalizedCompound' ],
    'ParticipatesAt' => [ 'LocalizedCompound', 'Location' ],
    'IsProteinFor' => [ 'ProteinSequence', 'Feature' ],
    'Produces' => [ 'Feature', 'ProteinSequence' ],
    'IsReagentIn' => [ 'CompoundInstance', 'ReactionInstance' ],
    'Targets' => [ 'ReactionInstance', 'CompoundInstance' ],
    'IsRealLocationOf' => [ 'LocationInstance', 'CompoundInstance' ],
    'HasRealLocationIn' => [ 'CompoundInstance', 'LocationInstance' ],
    'IsReferencedBy' => [ 'Genome', 'ObservationalUnit' ],
    'UsesReference' => [ 'ObservationalUnit', 'Genome' ],
    'IsRegulatedIn' => [ 'Feature', 'CoregulatedSet' ],
    'IsRegulatedSetOf' => [ 'CoregulatedSet', 'Feature' ],
    'IsRegulatorFor' => [ 'Regulator', 'Regulog' ],
    'HasRegulator' => [ 'Regulog', 'Regulator' ],
    'IsRegulatorForRegulon' => [ 'Regulator', 'Regulon' ],
    'ReglonHasRegulator' => [ 'Regulon', 'Regulator' ],
    'IsRegulatorySiteFor' => [ 'Feature', 'Operon' ],
    'HasRegulatorySite' => [ 'Operon', 'Feature' ],
    'IsRelevantFor' => [ 'Diagram', 'Subsystem' ],
    'IsRelevantTo' => [ 'Subsystem', 'Diagram' ],
    'IsRepresentedBy' => [ 'TaxonomicGrouping', 'ObservationalUnit' ],
    'DefinedBy' => [ 'ObservationalUnit', 'TaxonomicGrouping' ],
    'IsRoleOf' => [ 'Role', 'SSCell' ],
    'HasRole' => [ 'SSCell', 'Role' ],
    'IsRowOf' => [ 'SSRow', 'SSCell' ],
    'IsRoleFor' => [ 'SSCell', 'SSRow' ],
    'IsSequenceOf' => [ 'ContigSequence', 'Contig' ],
    'HasAsSequence' => [ 'Contig', 'ContigSequence' ],
    'IsSourceForAssociationDataset' => [ 'Source', 'AssociationDataset' ],
    'AssociationDatasetSourcedBy' => [ 'AssociationDataset', 'Source' ],
    'IsSubInstanceOf' => [ 'Subsystem', 'Scenario' ],
    'Validates' => [ 'Scenario', 'Subsystem' ],
    'IsSummarizedBy' => [ 'Contig', 'AlleleFrequency' ],
    'Summarizes' => [ 'AlleleFrequency', 'Contig' ],
    'IsSuperclassOf' => [ 'SubsystemClass', 'SubsystemClass' ],
    'IsSubclassOf' => [ 'SubsystemClass', 'SubsystemClass' ],
    'IsTaxonomyOf' => [ 'TaxonomicGrouping', 'Genome' ],
    'IsInTaxa' => [ 'Genome', 'TaxonomicGrouping' ],
    'IsTerminusFor' => [ 'Compound', 'Scenario' ],
    'HasAsTerminus' => [ 'Scenario', 'Compound' ],
    'IsTriggeredBy' => [ 'Complex', 'Role' ],
    'Triggers' => [ 'Role', 'Complex' ],
    'IsUsedToBuildTree' => [ 'Alignment', 'Tree' ],
    'IsBuiltFromAlignment' => [ 'Tree', 'Alignment' ],
    'Manages' => [ 'Model', 'Biomass' ],
    'IsManagedBy' => [ 'Biomass', 'Model' ],
    'OntologyForSample' => [ 'Ontology', 'SampleAnnotation' ],
    'SampleHasOntology' => [ 'SampleAnnotation', 'Ontology' ],
    'OperatesIn' => [ 'Experiment', 'Media' ],
    'IsUtilizedIn' => [ 'Media', 'Experiment' ],
    'OrdersExperimentalUnit' => [ 'TimeSeries', 'ExperimentalUnit' ],
    'IsTimepointOf' => [ 'ExperimentalUnit', 'TimeSeries' ],
    'Overlaps' => [ 'Scenario', 'Diagram' ],
    'IncludesPartOf' => [ 'Diagram', 'Scenario' ],
    'ParticipatesAs' => [ 'Compound', 'LocalizedCompound' ],
    'IsParticipationOf' => [ 'LocalizedCompound', 'Compound' ],
    'PerformedExperiment' => [ 'Person', 'ExperimentMeta' ],
    'PerformedBy' => [ 'ExperimentMeta', 'Person' ],
    'PersonAnnotatedSample' => [ 'Person', 'SampleAnnotation' ],
    'SampleAnnotatedBy' => [ 'SampleAnnotation', 'Person' ],
    'PlatformWithSamples' => [ 'Platform', 'Sample' ],
    'SampleRunOnPlatform' => [ 'Sample', 'Platform' ],
    'ProducedResultsFor' => [ 'ProbeSet', 'Genome' ],
    'HadResultsProducedBy' => [ 'Genome', 'ProbeSet' ],
    'ProtocolForSample' => [ 'Protocol', 'Sample' ],
    'SampleUsesProtocol' => [ 'Sample', 'Protocol' ],
    'Provided' => [ 'Source', 'Subsystem' ],
    'WasProvidedBy' => [ 'Subsystem', 'Source' ],
    'PublishedAssociation' => [ 'Publication', 'Association' ],
    'AssociationPublishedIn' => [ 'Association', 'Publication' ],
    'PublishedExperiment' => [ 'Publication', 'ExperimentMeta' ],
    'ExperimentPublishedIn' => [ 'ExperimentMeta', 'Publication' ],
    'PublishedProtocol' => [ 'Publication', 'Protocol' ],
    'ProtocolPublishedIn' => [ 'Protocol', 'Publication' ],
    'RegulogHasRegulon' => [ 'Regulog', 'Regulon' ],
    'RegulonIsInRegolog' => [ 'Regulon', 'Regulog' ],
    'RegulomeHasGenome' => [ 'Regulome', 'Genome' ],
    'GenomeIsInRegulome' => [ 'Genome', 'Regulome' ],
    'RegulomeHasRegulon' => [ 'Regulome', 'Regulon' ],
    'RegulonIsInRegolome' => [ 'Regulon', 'Regulome' ],
    'RegulomeSource' => [ 'Regulome', 'Source' ],
    'CreatedRegulome' => [ 'Source', 'Regulome' ],
    'RegulonHasOperon' => [ 'Regulon', 'Operon' ],
    'OperonIsInRegulon' => [ 'Operon', 'Regulon' ],
    'SampleAveragedFrom' => [ 'Sample', 'Sample' ],
    'SampleComponentOf' => [ 'Sample', 'Sample' ],
    'SampleContactPerson' => [ 'Sample', 'Person' ],
    'PersonPerformedSample' => [ 'Person', 'Sample' ],
    'SampleHasAnnotations' => [ 'Sample', 'SampleAnnotation' ],
    'AnnotationsForSample' => [ 'SampleAnnotation', 'Sample' ],
    'SampleInSeries' => [ 'Sample', 'Series' ],
    'SeriesWithSamples' => [ 'Series', 'Sample' ],
    'SampleMeasurements' => [ 'Sample', 'Measurement' ],
    'MeasurementInSample' => [ 'Measurement', 'Sample' ],
    'SamplesInReplicateGroup' => [ 'Sample', 'ReplicateGroup' ],
    'ReplicateGroupsForSample' => [ 'ReplicateGroup', 'Sample' ],
    'SeriesPublishedIn' => [ 'Series', 'Publication' ],
    'PublicationsForSeries' => [ 'Publication', 'Series' ],
    'Shows' => [ 'Diagram', 'Compound' ],
    'IsShownOn' => [ 'Compound', 'Diagram' ],
    'StrainParentOf' => [ 'Strain', 'Strain' ],
    'DerivedFromStrain' => [ 'Strain', 'Strain' ],
    'StrainWithPlatforms' => [ 'Strain', 'Platform' ],
    'PlatformForStrain' => [ 'Platform', 'Strain' ],
    'StrainWithSample' => [ 'Strain', 'Sample' ],
    'SampleForStrain' => [ 'Sample', 'Strain' ],
    'Submitted' => [ 'Source', 'Genome' ],
    'WasSubmittedBy' => [ 'Genome', 'Source' ],
    'SupersedesAlignment' => [ 'Alignment', 'Alignment' ],
    'IsSupersededByAlignment' => [ 'Alignment', 'Alignment' ],
    'SupersedesTree' => [ 'Tree', 'Tree' ],
    'IsSupersededByTree' => [ 'Tree', 'Tree' ],
    'Treed' => [ 'Source', 'Tree' ],
    'IsTreeFrom' => [ 'Tree', 'Source' ],
    'UsedIn' => [ 'Media', 'Environment' ],
    'HasMedia' => [ 'Environment', 'Media' ],
    'Uses' => [ 'Genome', 'SSRow' ],
    'IsUsedBy' => [ 'SSRow', 'Genome' ],
    'UsesCodons' => [ 'Genome', 'CodonUsage' ],
    'AreCodonsFor' => [ 'CodonUsage', 'Genome' ],

};

#sub _init_instance
#{
#    my($self) = @_;
#    $self->{db} = CDMI->new(dbhost => 'seed-db-read', sock => '', DBD => '/home/parrello/FIGdisk/dist/releases/current/WinBuild/KSaplingDBD.xml');
#}

sub _validate_fields_for_entity
{
    my($self, $tbl, $fields, $ensure_id) = @_;

    my $valid_fields = $entity_field_defs->{$tbl};

    my $have_id;

    my $cdmi = $self->{db};
    my $q = $cdmi->{_dbh}->quote;

    my @rel_fields;
    my @qfields;
    my @sfields;
    my @bad_fields;
    for my $field (@$fields)
    {
	$field =~ s/-/_/g;
	if (!$valid_fields->{$field})
	{
	    push(@bad_fields, $field);
	    next;
	}
	if (my $rel = $entity_field_rels->{$tbl}->{$field})
	{
	    push(@rel_fields, [$field, $rel]);
	}
	else
	{
	    push(@sfields, $field);
	    my $qfield = $q . $field . $q;
	    $have_id = 1 if $field eq 'id';
	    push(@qfields, $qfield);
	}
    }

    if (@bad_fields)
    {
	die "The following fields are invalid in entity $tbl: @bad_fields";
    }

    if (!$have_id && ($ensure_id || @rel_fields))
    {
	unshift(@sfields, 'id');
	unshift(@qfields, $q . 'id' . $q);
    }

    return(\@sfields, \@qfields, \@rel_fields);
}

sub _validate_fields_for_relationship
{
    my($self, $tbl, $fields, $link_field) = @_;

    my $valid_fields = $relationship_field_defs->{$tbl};

    my $cdmi = $self->{db};
    my $q = $cdmi->{_dbh}->quote;

    my $have_id = 0;
    my @qfields;
    my @sfields;
    my @bad_fields;
    for my $field (@$fields)
    {
	$field =~ s/-/_/g;
	if (!$valid_fields->{$field})
	{
	    push(@bad_fields, $field);
	    next;
	}

	$have_id = 1 if $field eq $link_field;
	push(@sfields, $field);
	my $qfield = $q . $field . $q;
	push(@qfields, $qfield);
    }

    if (!$have_id)
    {
	unshift(@sfields, $link_field);
	unshift(@qfields, $q . $link_field . $q);
    }

    if (@bad_fields)
    {
	die "The following fields are invalid in relationship $tbl: @bad_fields";
    }

    return(\@sfields, \@qfields);
}

sub _query_entity
{
    my($self, $ctx, $tbl, $user_qry, $fields) = @_;

    my($sfields, $qfields, $rel_fields) = $self->_validate_fields_for_entity($tbl, $fields, 1);

    my @filter;
    my @filter_params;

    my $valid_fields = $entity_field_defs->{$tbl};
    my $field_rels = $entity_field_rels->{$tbl};
    
    #IN violates the typespec since it requires an array as the $value rather than a string
    my %valid_ops = map { $_ => 1 } ('IS NULL', 'IS NOT NULL', 'LIKE', '<', '>', '=', '>=', '<='); # 'IN');
    my @bad_q;
    for my $q (@$user_qry)
    {
        my($field, $op, $value) = @$q;
	$field =~ s/-/_/g;
        if (!$valid_fields->{$field})
        {
            push(@bad_q, "Field $field does not exist in $tbl");
            next;
        }
        if ($field_rels->{$field})
        {
            push(@bad_q, "Field $field is stored in a secondary relation; this is not yet supported for queries.");
            next;
        }
        if (!$valid_ops{uc($op)})
        {
            push(@bad_q, "Operator $op is not allowed");
               next;
        }
        if ($op eq 'IN')
        {
            if (! ref $value eq 'ARRAY')
            {
                push(@bad_q, "Associated value for operator $op must be an array");
                next;
            } else {
                my $quest = '(' . join(', ', ('?') x @$value) . ')';
                push(@filter, "$field $op $quest");
                push(@filter_params, @$value);
            }
        }
        elsif ($op eq 'IS NOT NULL' or $op eq 'IS NULL')
        {
            push(@filter, "$field $op");
        } else {
            push(@filter, "$field $op ?");
            push(@filter_params, $value);
        }
    } 

    if (@bad_q)
    {
        die "Errors found in query:\n" . join("\n", @bad_q);
    }

    my $cdmi = $self->{db};
    my $q = $cdmi->{_dbh}->quote;

    my $qstr = join(", ", @$qfields);

    my $filter = join(" AND ", map { "(" . $_ . ")" } @filter);
    my $qry = "SELECT $qstr FROM $q$tbl$q WHERE $filter";

    my $attrs = {};
    my $dbk = $cdmi->{_dbh};
    if ($dbk->dbms eq 'mysql')
    {
	$attrs->{mysql_use_result} = 1;
    }

    my $sth = $dbk->{_dbh}->prepare($qry, $attrs);
    
    # print STDERR "$qry\n";
    $sth->execute(@filter_params);
    my $out = $sth->fetchall_hashref('id');

    my @ids = keys %$out;

    if (@ids)
    {
	my $rel_filter = "id IN (" . join(", ", map { "?" } @ids) . ")";
	#
	# Now query for the fields that are in separate relations.
	#
	for my $ent (@$rel_fields)
	{
	    my($field, $rel) = @$ent;
	    
	    my $sth = $dbk->{_dbh}->prepare(qq(SELECT id, $field FROM $rel WHERE $rel_filter));
	    $sth->execute(@ids);
	    while (my $row = $sth->fetchrow_arrayref())
	    {
		my($id, $val) = @$row;
		push(@{$out->{$id}->{$field}}, $val);
	    }
	}
    }
    return $out;
}    

sub _get_entity
{
    my($self, $ctx, $tbl, $ids, $fields) = @_;

    my($sfields, $qfields, $rel_fields) = $self->_validate_fields_for_entity($tbl, $fields, 1);
    
    my $filter = "id IN (" . join(", ", map { '?' } @$ids) . ")";

    my $cdmi = $self->{db};
    my $q = $cdmi->{_dbh}->quote;

    my $qstr = join(", ", @$qfields);
    my $qry = "SELECT $qstr FROM $q$tbl$q WHERE $filter";

    my $attrs = {};
    my $dbk = $cdmi->{_dbh};
    if ($dbk->dbms eq 'mysql')
    {
	$attrs->{mysql_use_result} = 1;
    }

    my $sth = $dbk->{_dbh}->prepare($qry, $attrs);
    
    # print STDERR "$qry\n";
    $sth->execute(@$ids);
    my $out = $sth->fetchall_hashref('id');

    #
    # Now query for the fields that are in separate relations.
    #
    for my $ent (@$rel_fields)
    {
	my($field, $rel) = @$ent;
	my $sth = $dbk->{_dbh}->prepare(qq(SELECT id, $field FROM $rel WHERE $filter));
	$sth->execute(@$ids);
	while (my $row = $sth->fetchrow_arrayref())
	{
	    my($id, $val) = @$row;
	    push(@{$out->{$id}->{$field}}, $val);
	}
    }
    return $out;
}    

# sub _add_entities
# {
#     my($self, $ctx, $tbl, $fields, $data) = @_;

#     my($sfields, $qfields, $rel_fields) = $self->_validate_fields_for_entity($tbl, $fields, 1);
    
#     my $cdmi = $self->{db};
#     my $q = $cdmi->{_dbh}->quote;

#     my $qstr = join(", ", @$qfields);
#     my $qry = "SELECT $qstr FROM $q$tbl$q WHERE $filter";

#     my $attrs = {};
#     my $dbk = $cdmi->{_dbh};
#     if ($dbk->dbms eq 'mysql')
#     {
# 	$attrs->{mysql_use_result} = 1;
#     }
#     XXXXXXX

#     my $sth = $dbk->{_dbh}->prepare($qry, $attrs);
    
#     # print STDERR "$qry\n";
#     $sth->execute(@$ids);
#     my $out = $sth->fetchall_hashref('id');

#     #
#     # Now query for the fields that are in separate relations.
#     #
#     for my $ent (@$rel_fields)
#     {
# 	my($field, $rel) = @$ent;
# 	my $sth = $dbk->{_dbh}->prepare(qq(SELECT id, $field FROM $rel WHERE $filter));
# 	$sth->execute(@$ids);
# 	while (my $row = $sth->fetchrow_arrayref())
# 	{
# 	    my($id, $val) = @$row;
# 	    push(@{$out->{$id}->{$field}}, $val);
# 	}
#     }
#     return $out;
# }    

sub _get_relationship
{
    my($self, $ctx, $relationship, $table, $is_converse, $ids, $from_fields, $rel_fields, $to_fields) = @_;

    my($from_tbl, $to_tbl) = @{$relationship_entities->{$relationship}};
    if (!$from_tbl)
    {
	die "Unknown relationship $relationship";
    }

    my %link_name_map;
    my($from_link, $to_link);
    if ($is_converse)
    {
	($from_link, $to_link) = qw(to_link from_link);
	%link_name_map = ( from_link => 'to_link', to_link => 'from_link');
    }
    else
    {
	($from_link, $to_link) = qw(from_link to_link);
	%link_name_map = ( from_link => 'from_link', to_link => 'to_link');
    }
    for my $f (@$rel_fields)
    {
	if (!exists $link_name_map{$f})
	{
	    $link_name_map{$f} = $f;
	}
    }

    my $cdmi = $self->{db};
    my $q = $cdmi->{_dbh}->quote;

    my($from_sfields, $from_qfields, $from_relfields) = $self->_validate_fields_for_entity($from_tbl, $from_fields, 0);
    my($to_sfields, $to_qfields, $to_relfields) = $self->_validate_fields_for_entity($to_tbl, $to_fields, 0);

    my @trans_rel_fields = map { $link_name_map{$_} } @$rel_fields;
    my($rel_sfields, $rel_qfields) = $self->_validate_fields_for_relationship($relationship, \@trans_rel_fields, $from_link);
    
    my $filter = "$from_link IN (" . join(", ", map { '?' } @$ids) . ")";

    my $from = "$q$table$q r ";
    if (@$from_qfields)
    {
	$from .= "JOIN $q$from_tbl$q f ON f.id = r.$from_link ";
    }
    if (@$to_qfields)
    {
	$from .= "JOIN $q$to_tbl$q t ON t.id = r.$to_link ";
    }

    my $qstr = join(", ",
		    (map { "f.$_" } @$from_qfields),
		    (map { "t.$_" }  @$to_qfields),
		    (map { "r.$_" } @$rel_qfields));

    my $qry = "SELECT $qstr FROM $from WHERE $filter";

    my $attrs = {};
    my $dbk = $cdmi->{_dbh};
    if ($dbk->dbms eq 'mysql')
    {
	$attrs->{mysql_use_result} = 1;
    }

    my $sth = $dbk->{_dbh}->prepare($qry, $attrs);
    
    # print STDERR "$qry\n";
    $sth->execute(@$ids);
    my $res = $sth->fetchall_arrayref();

    my $out = [];

    my(%from_keys_for_rel, %to_keys_for_rel);
    for my $ent (@$res)
    {
	my($fout, $rout, $tout) = ({}, {}, {});
	for my $fld (@$from_sfields)
	{
	    my $v = shift @$ent;
	    $fout->{$fld} = $v;
	}
	for my $fld (@$to_sfields)
	{
	    my $v = shift @$ent;
	    $tout->{$fld} = $v;
	}
	for my $fld (@$rel_sfields)
	{
	    my $v = shift @$ent;
	    $rout->{$link_name_map{$fld}} = $v;
	}
	my $row = [$fout, $rout, $tout];

	if (@$from_relfields)
	{
	    push(@{$from_keys_for_rel{$fout->{id}}}, $row);
	}

	if (@$to_relfields)
	{
	    push(@{$to_keys_for_rel{$tout->{id}}}, $row);
	}

	push(@$out, $row);
    }

    if (@$from_relfields)
    {
	my %ids = keys %from_keys_for_rel;
	my @ids = keys %ids;

	my $filter = "id IN (" . join(", ", map { '?' } @ids) . ")";

	for my $ent (@$from_relfields)
	{
	    my($field, $rel) = @$ent;
	    
	    my $sth = $dbk->{_dbh}->prepare(qq(SELECT id, $field FROM $rel WHERE $filter));
	    $sth->execute(@ids);
	    while (my $row = $sth->fetchrow_arrayref())
	    {
		my($id, $val) = @$row;

		for my $row (@{$from_keys_for_rel{$id}})
		{
		    push(@{$row->[0]->{$field}}, $val);
		}
	    }
	}
    }

    if (@$to_relfields)
    {
	my %ids = keys %to_keys_for_rel;
	my @ids = keys %ids;

	my $filter = "id IN (" . join(", ", map { '?' } @ids) . ")";

	for my $ent (@$to_relfields)
	{
	    my($field, $rel) = @$ent;
	    
	    my $sth = $dbk->{_dbh}->prepare(qq(SELECT id, $field FROM $rel WHERE $filter));
	    $sth->execute(@ids);
	    while (my $row = $sth->fetchrow_arrayref())
	    {
		my($id, $val) = @$row;

		for my $row (@{$to_keys_for_rel{$id}})
		{
		    push(@{$row->[2]->{$field}}, $val);
		}
	    }
	}
    }


    return $out;
}    

sub _query_relationship
{
    my($self, $ctx, $relationship, $table, $is_converse, $ids, $user_qry, $from_fields, $rel_fields, $to_fields) = @_;

    my($from_tbl, $to_tbl) = @{$relationship_entities->{$relationship}};
    if (!$from_tbl)
    {
	die "Unknown relationship $relationship";
    }

    my %link_name_map;
    my($from_link, $to_link);

    my $valid_from_fields = $entity_field_defs->{$from_tbl};
    my $valid_rel_fields = $relationship_field_defs->{$table};
    my $valid_to_fields = $entity_field_defs->{$to_tbl};

    if ($is_converse)
    {
	($from_link, $to_link) = qw(to_link from_link);
	%link_name_map = ( from_link => 'to_link', to_link => 'from_link');
    }
    else
    {
	($from_link, $to_link) = qw(from_link to_link);
	%link_name_map = ( from_link => 'from_link', to_link => 'to_link');
    }
    for my $f (@$rel_fields)
    {
	if (!exists $link_name_map{$f})
	{
	    $link_name_map{$f} = $f;
	}
    }

    my $cdmi = $self->{db};
    my $q = $cdmi->{_dbh}->quote;

    my($from_sfields, $from_qfields, $from_relfields) = $self->_validate_fields_for_entity($from_tbl, $from_fields, 0);
    my($to_sfields, $to_qfields, $to_relfields) = $self->_validate_fields_for_entity($to_tbl, $to_fields, 0);

    my @trans_rel_fields = map { $link_name_map{$_} } @$rel_fields;
    my($rel_sfields, $rel_qfields) = $self->_validate_fields_for_relationship($relationship, \@trans_rel_fields, $from_link);
    
#    my $filter = "$from_link IN (" . join(", ", map { '?' } @$ids) . ")";
    #IN violates the typespec since it requires an array as the $value rather than a string
    my %valid_ops = map { $_ => 1 } ('IS NULL', 'IS NOT NULL', 'LIKE', '<', '>', '=', '>=', '<='); # 'IN');
    my @bad_q;
    my $need_from;
    my $need_to;
    my(@filter, @filter_params);
    for my $q (@$user_qry)
    {
        my($field, $op, $value) = @$q;
	
	my $field_tbl = 'r';
	my $field_name = $field;
	my $valid_hash = $valid_rel_fields;
	if ($field =~ /^to\.(.*)/)
	{
	    $need_to++;
	    $field_tbl = 't';
	    $field_name = $1;
	    $valid_hash = $valid_to_fields;
	}
	elsif ($field =~ /^from\.(.*)/)
	{
	    $need_from++;
	    $field_tbl = 'f';
	    $field_name = $1;
	    $valid_hash = $valid_from_fields;
	}
	elsif ($field =~ /^rel\.(.*)/)
	{
	    $field_tbl = 'r';
	    $field_name = $1;
	    $valid_hash = $valid_rel_fields;
	}
	
	if (defined(my $l = $link_name_map{$field_name}))
	{
	    $field_name = $l;
	}

	$field =~ s/-/_/g;
        if (!$valid_hash->{$field_name})
        {
            push(@bad_q, "Field $field_name does not exist in $field_tbl");
            next;
        }
        if (!$valid_ops{uc($op)})
        {
            push(@bad_q, "Operator $op is not allowed");
               next;
        }
        if ($op eq 'IS NOT NULL' or $op eq 'IS NULL')
        {
            push(@filter, "$field_tbl.field_name $op");
        } else {
            push(@filter, "$field_tbl.$field_name $op ?");
            push(@filter_params, $value);
        }
    } 
    if (@$ids)
    {
	push(@filter, "$from_link IN (" . join(", ", map { '?' } @$ids) . ")");
	push(@filter_params, @$ids);
    }

    if (@bad_q)
    {
        die "Errors found in query:\n" . join("\n", @bad_q);
    }

    my $from = "$q$table$q r ";
    if (@$from_qfields || $need_from)
    {
	$from .= "JOIN $q$from_tbl$q f ON f.id = r.$from_link ";
    }
    if (@$to_qfields || $need_to)
    {
	$from .= "JOIN $q$to_tbl$q t ON t.id = r.$to_link ";
    }

    my $qstr = join(", ",
		    (map { "f.$_" } @$from_qfields),
		    (map { "t.$_" }  @$to_qfields),
		    (map { "r.$_" } @$rel_qfields));

    my $filter = join(" AND ", map { "(" . $_ . ")" } @filter);
    my $qry = "SELECT $qstr FROM $from WHERE $filter";

    my $attrs = {};
    my $dbk = $cdmi->{_dbh};
    if ($dbk->dbms eq 'mysql')
    {
	$attrs->{mysql_use_result} = 1;
    }

    my $sth = $dbk->{_dbh}->prepare($qry, $attrs);
    
    # print STDERR "$qry\n";
    $sth->execute(@filter_params);
    my $res = $sth->fetchall_arrayref();

    my $out = [];

    my(%from_keys_for_rel, %to_keys_for_rel);
    for my $ent (@$res)
    {
	my($fout, $rout, $tout) = ({}, {}, {});
	for my $fld (@$from_sfields)
	{
	    my $v = shift @$ent;
	    $fout->{$fld} = $v;
	}
	for my $fld (@$to_sfields)
	{
	    my $v = shift @$ent;
	    $tout->{$fld} = $v;
	}
	for my $fld (@$rel_sfields)
	{
	    my $v = shift @$ent;
	    $rout->{$link_name_map{$fld}} = $v;
	}
	my $row = [$fout, $rout, $tout];

	if (@$from_relfields)
	{
	    push(@{$from_keys_for_rel{$fout->{id}}}, $row);
	}

	if (@$to_relfields)
	{
	    push(@{$to_keys_for_rel{$tout->{id}}}, $row);
	}

	push(@$out, $row);
    }

    if (@$from_relfields)
    {
	my %ids = keys %from_keys_for_rel;
	my @ids = keys %ids;

	my $filter = "id IN (" . join(", ", map { '?' } @ids) . ")";

	for my $ent (@$from_relfields)
	{
	    my($field, $rel) = @$ent;
	    
	    my $sth = $dbk->{_dbh}->prepare(qq(SELECT id, $field FROM $rel WHERE $filter));
	    $sth->execute(@ids);
	    while (my $row = $sth->fetchrow_arrayref())
	    {
		my($id, $val) = @$row;

		for my $row (@{$from_keys_for_rel{$id}})
		{
		    push(@{$row->[0]->{$field}}, $val);
		}
	    }
	}
    }

    if (@$to_relfields)
    {
	my %ids = keys %to_keys_for_rel;
	my @ids = keys %ids;

	my $filter = "id IN (" . join(", ", map { '?' } @ids) . ")";

	for my $ent (@$to_relfields)
	{
	    my($field, $rel) = @$ent;
	    
	    my $sth = $dbk->{_dbh}->prepare(qq(SELECT id, $field FROM $rel WHERE $filter));
	    $sth->execute(@ids);
	    while (my $row = $sth->fetchrow_arrayref())
	    {
		my($id, $val) = @$row;

		for my $row (@{$to_keys_for_rel{$id}})
		{
		    push(@{$row->[2]->{$field}}, $val);
		}
	    }
	}
    }


    return $out;
}    

sub _all_entities
{
    my($self, $ctx, $tbl, $start, $count, $fields) = @_;

    my($sfields, $qfields, $rel_fields) = $self->_validate_fields_for_entity($tbl, $fields, 1);

    my $cdmi = $self->{db};
    my $q = $cdmi->{_dbh}->quote;

    my $qstr = join(", ", @$qfields);

    my $attrs = {};
    my $dbk = $cdmi->{_dbh};
    my $limit;
    
    if ($dbk->dbms eq 'mysql')
    {
	$attrs->{mysql_use_result} = 1;
	$limit = "LIMIT $start, $count";
    }
    elsif ($dbk->dbms eq 'Pg')
    {
	$limit = "ORDER BY id LIMIT $count OFFSET $start";
    }

    my $qry = "SELECT $qstr FROM $q$tbl$q $limit";

    my $sth = $dbk->{_dbh}->prepare($qry, $attrs);
    
    # print STDERR "$qry\n";
    $sth->execute();
    my $out = $sth->fetchall_hashref('id');

    #
    # Now query for the fields that are in separate relations.
    #
    my @ids = keys %$out;
    if (@ids)
    {
	my $filter = "id IN (" . join(", ", map { '?' } @ids) . ")";
	
	for my $ent (@$rel_fields)
	{
	    my($field, $rel) = @$ent;
	    
	    my $sth = $dbk->{_dbh}->prepare(qq(SELECT id, $field FROM $rel WHERE $filter));
	    $sth->execute(@ids);
	    while (my $row = $sth->fetchrow_arrayref())
	    {
		my($id, $val) = @$row;
		push(@{$out->{$id}->{$field}}, $val);
	    }
	}
    }

    return $out;
}    

#END_HEADER

sub new
{
    my($class, @args) = @_;
    my $self = {
    };
    bless $self, $class;
    #BEGIN_CONSTRUCTOR

    my($cdmi) = @args;
    if (! $cdmi) {
		my %params;
		if (my $e = $ENV{KB_DEPLOYMENT_CONFIG})
		{
	    	my $service = $ENV{KB_SERVICE_NAME};
	    	my $c = Config::Simple->new();
	    	$c->read($e);
	    	my @params = qw(DBD dbName sock userData dbhost port dbms develop);
	    	for my $p (@params)
	    	{
				my $v = $c->param("$service.$p");
				if ($v)
				{
		    		$params{$p} = $v;
				}
	    	}
		}
        $cdmi = Bio::KBase::CDMI::CDMI->new(%params);
    }
    $self->{db} = $cdmi;

    #END_CONSTRUCTOR

    if ($self->can('_init_instance'))
    {
	$self->_init_instance();
    }
    return $self;
}

=head1 METHODS



=head2 get_all

  $result_set = $obj->get_all($object_names, $filter_clause, $parameters, $fields, $count)

=over 4

=item Parameter and return types

=begin html

<pre>
$object_names is a string
$filter_clause is a string
$parameters is a reference to a list where each element is a string
$fields is a string
$count is an int
$result_set is a reference to a list where each element is a reference to a list where each element is a string

</pre>

=end html

=begin text

$object_names is a string
$filter_clause is a string
$parameters is a reference to a list where each element is a string
$fields is a string
$count is an int
$result_set is a reference to a list where each element is a reference to a list where each element is a string


=end text



=item Description

Wrapper for the GetAll function documented L<here|http://pubseed.theseed.org/sapling/server.cgi?pod=ERDB#GetAll>.
Note that the object_names and fields arguments must be strings; array references are not allowed.

=back

=cut

sub get_all
{
    my $self = shift;
    my($object_names, $filter_clause, $parameters, $fields, $count) = @_;

    my @_bad_arguments;
    (!ref($object_names)) or push(@_bad_arguments, "Invalid type for argument \"object_names\" (value was \"$object_names\")");
    (!ref($filter_clause)) or push(@_bad_arguments, "Invalid type for argument \"filter_clause\" (value was \"$filter_clause\")");
    (ref($parameters) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"parameters\" (value was \"$parameters\")");
    (!ref($fields)) or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_all:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_all');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($result_set);
    #BEGIN get_all

    $result_set = [$self->{db}->GetAll($object_names, $filter_clause, $parameters, $fields, $count)];

    #END get_all
    my @_bad_returns;
    (ref($result_set) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"result_set\" (value was \"$result_set\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_all:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_all');
    }
    return($result_set);
}




=head2 get_entity_Alignment

  $return = $obj->get_entity_Alignment($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Alignment
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Alignment
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string


=end text



=item Description

An alignment arranges a group of sequences so that they
match. Each alignment is associated with a phylogenetic tree that
describes how the sequences developed and their evolutionary
distance.

It has the following fields:

=over 4

=item n_rows

number of rows in the alignment

=item n_cols

number of columns in the alignment

=item status

status of the alignment, currently either [i]active[/i], [i]superseded[/i], or [i]bad[/i]

=item is_concatenation

TRUE if the rows of the alignment map to multiple sequences, FALSE if they map to single sequences

=item sequence_type

type of sequence being aligned, currently either [i]Protein[/i], [i]DNA[/i], [i]RNA[/i], or [i]Mixed[/i]

=item timestamp

date and time the alignment was loaded

=item method

name of the primary software package or script used to construct the alignment

=item parameters

non-default parameters used as input to the software package or script indicated in the method attribute

=item protocol

description of the steps taken to construct the alignment, or a reference to an external pipeline

=item source_id

ID of this alignment in the source database


=back

=back

=cut

sub get_entity_Alignment
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Alignment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Alignment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Alignment

    $return = $self->_get_entity($ctx, 'Alignment', $ids, $fields);

    #END get_entity_Alignment
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Alignment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Alignment');
    }
    return($return);
}




=head2 query_entity_Alignment

  $return = $obj->query_entity_Alignment($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Alignment
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Alignment
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Alignment
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Alignment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Alignment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Alignment

    $return = $self->_query_entity($ctx, 'Alignment', $qry, $fields);

    #END query_entity_Alignment
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Alignment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Alignment');
    }
    return($return);
}




=head2 all_entities_Alignment

  $return = $obj->all_entities_Alignment($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Alignment
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Alignment
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Alignment
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Alignment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Alignment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Alignment

    $return = $self->_all_entities($ctx, 'Alignment', $start, $count, $fields);

    #END all_entities_Alignment
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Alignment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Alignment');
    }
    return($return);
}




=head2 get_entity_AlignmentAttribute

  $return = $obj->get_entity_AlignmentAttribute($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlignmentAttribute
fields_AlignmentAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlignmentAttribute
fields_AlignmentAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

This entity represents an attribute type that can
be assigned to an alignment. The attribute
values are stored in the relationships to the target. The
key is the attribute name.

It has the following fields:

=over 4


=back

=back

=cut

sub get_entity_AlignmentAttribute
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_AlignmentAttribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_AlignmentAttribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_AlignmentAttribute

    $return = $self->_get_entity($ctx, 'AlignmentAttribute', $ids, $fields);

    #END get_entity_AlignmentAttribute
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_AlignmentAttribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_AlignmentAttribute');
    }
    return($return);
}




=head2 query_entity_AlignmentAttribute

  $return = $obj->query_entity_AlignmentAttribute($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlignmentAttribute
fields_AlignmentAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlignmentAttribute
fields_AlignmentAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_AlignmentAttribute
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_AlignmentAttribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_AlignmentAttribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_AlignmentAttribute

    $return = $self->_query_entity($ctx, 'AlignmentAttribute', $qry, $fields);

    #END query_entity_AlignmentAttribute
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_AlignmentAttribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_AlignmentAttribute');
    }
    return($return);
}




=head2 all_entities_AlignmentAttribute

  $return = $obj->all_entities_AlignmentAttribute($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlignmentAttribute
fields_AlignmentAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlignmentAttribute
fields_AlignmentAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_AlignmentAttribute
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_AlignmentAttribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_AlignmentAttribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_AlignmentAttribute

    $return = $self->_all_entities($ctx, 'AlignmentAttribute', $start, $count, $fields);

    #END all_entities_AlignmentAttribute
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_AlignmentAttribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_AlignmentAttribute');
    }
    return($return);
}




=head2 get_entity_AlignmentRow

  $return = $obj->get_entity_AlignmentRow($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlignmentRow
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlignmentRow
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string


=end text



=item Description

This entity represents a single row of an alignment.
In general, this corresponds to a sequence, but in a
concatenated alignment multiple sequences may be represented
here.

It has the following fields:

=over 4

=item row_number

1-based ordinal number of this row in the alignment

=item row_id

identifier for this row in the FASTA file for the alignment

=item row_description

description of this row in the FASTA file for the alignment

=item n_components

number of components that make up this alignment row; for a single-sequence alignment this is always "1"

=item beg_pos_aln

the 1-based column index in the alignment where this sequence row begins

=item end_pos_aln

the 1-based column index in the alignment where this sequence row ends

=item md5_of_ungapped_sequence

the MD5 of this row's sequence after gaps have been removed; for DNA and RNA sequences, the [b]U[/b] codes are also normalized to [b]T[/b] before the MD5 is computed

=item sequence

sequence for this alignment row (with indels)


=back

=back

=cut

sub get_entity_AlignmentRow
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_AlignmentRow:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_AlignmentRow');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_AlignmentRow

    $return = $self->_get_entity($ctx, 'AlignmentRow', $ids, $fields);

    #END get_entity_AlignmentRow
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_AlignmentRow:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_AlignmentRow');
    }
    return($return);
}




=head2 query_entity_AlignmentRow

  $return = $obj->query_entity_AlignmentRow($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlignmentRow
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlignmentRow
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_AlignmentRow
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_AlignmentRow:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_AlignmentRow');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_AlignmentRow

    $return = $self->_query_entity($ctx, 'AlignmentRow', $qry, $fields);

    #END query_entity_AlignmentRow
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_AlignmentRow:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_AlignmentRow');
    }
    return($return);
}




=head2 all_entities_AlignmentRow

  $return = $obj->all_entities_AlignmentRow($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlignmentRow
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlignmentRow
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_AlignmentRow
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_AlignmentRow:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_AlignmentRow');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_AlignmentRow

    $return = $self->_all_entities($ctx, 'AlignmentRow', $start, $count, $fields);

    #END all_entities_AlignmentRow
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_AlignmentRow:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_AlignmentRow');
    }
    return($return);
}




=head2 get_entity_AlleleFrequency

  $return = $obj->get_entity_AlleleFrequency($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlleleFrequency
fields_AlleleFrequency is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	position has a value which is an int
	minor_AF has a value which is a float
	minor_allele has a value which is a string
	major_AF has a value which is a float
	major_allele has a value which is a string
	obs_unit_count has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlleleFrequency
fields_AlleleFrequency is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	position has a value which is an int
	minor_AF has a value which is a float
	minor_allele has a value which is a string
	major_AF has a value which is a float
	major_allele has a value which is a string
	obs_unit_count has a value which is an int


=end text



=item Description

An allele frequency represents a summary of the major and minor allele frequencies for a position on a chromosome.

It has the following fields:

=over 4

=item source_id

identifier for this allele in the original (source) database

=item position

Specific position on the contig where the allele occurs

=item minor_AF

Minor allele frequency.  Floating point number from 0.0 to 0.5.

=item minor_allele

Text letter representation of the minor allele. Valid values are A, C, G, and T.

=item major_AF

Major allele frequency.  Floating point number less than or equal to 1.0.

=item major_allele

Text letter representation of the major allele. Valid values are A, C, G, and T.

=item obs_unit_count

Number of observational units used to compute the allele frequencies. Indicates the quality of the analysis.


=back

=back

=cut

sub get_entity_AlleleFrequency
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_AlleleFrequency:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_AlleleFrequency');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_AlleleFrequency

    $return = $self->_get_entity($ctx, 'AlleleFrequency', $ids, $fields);

    #END get_entity_AlleleFrequency
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_AlleleFrequency:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_AlleleFrequency');
    }
    return($return);
}




=head2 query_entity_AlleleFrequency

  $return = $obj->query_entity_AlleleFrequency($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlleleFrequency
fields_AlleleFrequency is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	position has a value which is an int
	minor_AF has a value which is a float
	minor_allele has a value which is a string
	major_AF has a value which is a float
	major_allele has a value which is a string
	obs_unit_count has a value which is an int

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlleleFrequency
fields_AlleleFrequency is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	position has a value which is an int
	minor_AF has a value which is a float
	minor_allele has a value which is a string
	major_AF has a value which is a float
	major_allele has a value which is a string
	obs_unit_count has a value which is an int


=end text



=item Description



=back

=cut

sub query_entity_AlleleFrequency
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_AlleleFrequency:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_AlleleFrequency');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_AlleleFrequency

    $return = $self->_query_entity($ctx, 'AlleleFrequency', $qry, $fields);

    #END query_entity_AlleleFrequency
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_AlleleFrequency:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_AlleleFrequency');
    }
    return($return);
}




=head2 all_entities_AlleleFrequency

  $return = $obj->all_entities_AlleleFrequency($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlleleFrequency
fields_AlleleFrequency is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	position has a value which is an int
	minor_AF has a value which is a float
	minor_allele has a value which is a string
	major_AF has a value which is a float
	major_allele has a value which is a string
	obs_unit_count has a value which is an int

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AlleleFrequency
fields_AlleleFrequency is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	position has a value which is an int
	minor_AF has a value which is a float
	minor_allele has a value which is a string
	major_AF has a value which is a float
	major_allele has a value which is a string
	obs_unit_count has a value which is an int


=end text



=item Description



=back

=cut

sub all_entities_AlleleFrequency
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_AlleleFrequency:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_AlleleFrequency');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_AlleleFrequency

    $return = $self->_all_entities($ctx, 'AlleleFrequency', $start, $count, $fields);

    #END all_entities_AlleleFrequency
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_AlleleFrequency:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_AlleleFrequency');
    }
    return($return);
}




=head2 get_entity_Annotation

  $return = $obj->get_entity_Annotation($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Annotation
fields_Annotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotator has a value which is a string
	comment has a value which is a string
	annotation_time has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Annotation
fields_Annotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotator has a value which is a string
	comment has a value which is a string
	annotation_time has a value which is a string


=end text



=item Description

An annotation is a comment attached to a feature.
Annotations are used to track the history of a feature's
functional assignments and any related issues. The key is
the feature ID followed by a colon and a complemented ten-digit
sequence number.

It has the following fields:

=over 4

=item annotator

name of the annotator who made the comment

=item comment

text of the annotation

=item annotation_time

date and time at which the annotation was made


=back

=back

=cut

sub get_entity_Annotation
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Annotation:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Annotation');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Annotation

    $return = $self->_get_entity($ctx, 'Annotation', $ids, $fields);

    #END get_entity_Annotation
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Annotation:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Annotation');
    }
    return($return);
}




=head2 query_entity_Annotation

  $return = $obj->query_entity_Annotation($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Annotation
fields_Annotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotator has a value which is a string
	comment has a value which is a string
	annotation_time has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Annotation
fields_Annotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotator has a value which is a string
	comment has a value which is a string
	annotation_time has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Annotation
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Annotation:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Annotation');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Annotation

    $return = $self->_query_entity($ctx, 'Annotation', $qry, $fields);

    #END query_entity_Annotation
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Annotation:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Annotation');
    }
    return($return);
}




=head2 all_entities_Annotation

  $return = $obj->all_entities_Annotation($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Annotation
fields_Annotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotator has a value which is a string
	comment has a value which is a string
	annotation_time has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Annotation
fields_Annotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotator has a value which is a string
	comment has a value which is a string
	annotation_time has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Annotation
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Annotation:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Annotation');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Annotation

    $return = $self->_all_entities($ctx, 'Annotation', $start, $count, $fields);

    #END all_entities_Annotation
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Annotation:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Annotation');
    }
    return($return);
}




=head2 get_entity_Assay

  $return = $obj->get_entity_Assay($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Assay
fields_Assay is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	assay_type has a value which is a string
	assay_type_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Assay
fields_Assay is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	assay_type has a value which is a string
	assay_type_id has a value which is a string


=end text



=item Description

An assay is an experimental design for determining alleles at specific chromosome positions.

It has the following fields:

=over 4

=item source_id

identifier for this assay in the original (source) database

=item assay_type

Text description of the type of assay (e.g., SNP, length, sequence, categorical, array, short read, SSR marker, AFLP marker)

=item assay_type_id

source ID associated with the assay type (informational)


=back

=back

=cut

sub get_entity_Assay
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Assay:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Assay');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Assay

    $return = $self->_get_entity($ctx, 'Assay', $ids, $fields);

    #END get_entity_Assay
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Assay:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Assay');
    }
    return($return);
}




=head2 query_entity_Assay

  $return = $obj->query_entity_Assay($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Assay
fields_Assay is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	assay_type has a value which is a string
	assay_type_id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Assay
fields_Assay is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	assay_type has a value which is a string
	assay_type_id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Assay
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Assay:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Assay');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Assay

    $return = $self->_query_entity($ctx, 'Assay', $qry, $fields);

    #END query_entity_Assay
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Assay:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Assay');
    }
    return($return);
}




=head2 all_entities_Assay

  $return = $obj->all_entities_Assay($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Assay
fields_Assay is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	assay_type has a value which is a string
	assay_type_id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Assay
fields_Assay is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	assay_type has a value which is a string
	assay_type_id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Assay
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Assay:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Assay');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Assay

    $return = $self->_all_entities($ctx, 'Assay', $start, $count, $fields);

    #END all_entities_Assay
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Assay:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Assay');
    }
    return($return);
}




=head2 get_entity_Association

  $return = $obj->get_entity_Association($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Association
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Association
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string


=end text



=item Description

An Association represents a protein complex or a pairwise
(binary) physical association between proteins.


It has the following fields:

=over 4

=item name

This is the name of the association. 

=item description

This is a description of this association.  If the protein complex has a name, this should be it. 

=item directional

True for directional binary associations (e.g., those detected by a pulldown experiment), false for non-directional binary associations and complexes. Bidirectional associations (e.g., associations detected by reciprocal pulldown experiments) should be encoded as 2 separate binary associations. 

=item confidence

Optional numeric estimate of confidence in the association. Recommended to use a 0-100 scale. 

=item url

Optional URL for more info about this complex.


=back

=back

=cut

sub get_entity_Association
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Association:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Association');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Association

    $return = $self->_get_entity($ctx, 'Association', $ids, $fields);

    #END get_entity_Association
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Association:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Association');
    }
    return($return);
}




=head2 query_entity_Association

  $return = $obj->query_entity_Association($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Association
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Association
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Association
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Association:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Association');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Association

    $return = $self->_query_entity($ctx, 'Association', $qry, $fields);

    #END query_entity_Association
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Association:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Association');
    }
    return($return);
}




=head2 all_entities_Association

  $return = $obj->all_entities_Association($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Association
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Association
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Association
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Association:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Association');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Association

    $return = $self->_all_entities($ctx, 'Association', $start, $count, $fields);

    #END all_entities_Association
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Association:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Association');
    }
    return($return);
}




=head2 get_entity_AssociationDataset

  $return = $obj->get_entity_AssociationDataset($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AssociationDataset
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AssociationDataset
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string


=end text



=item Description

An Association Dataset is a collection of PPI
data imported from a single database or publication.


It has the following fields:

=over 4

=item description

This is a description of the dataset.

=item data_source

Optional external source for this dataset; e.g., another database.

=item url

Optional URL for more info about this dataset.

=item association_type

The type of this association.


=back

=back

=cut

sub get_entity_AssociationDataset
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_AssociationDataset:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_AssociationDataset');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_AssociationDataset

    $return = $self->_get_entity($ctx, 'AssociationDataset', $ids, $fields);

    #END get_entity_AssociationDataset
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_AssociationDataset:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_AssociationDataset');
    }
    return($return);
}




=head2 query_entity_AssociationDataset

  $return = $obj->query_entity_AssociationDataset($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AssociationDataset
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AssociationDataset
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_AssociationDataset
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_AssociationDataset:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_AssociationDataset');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_AssociationDataset

    $return = $self->_query_entity($ctx, 'AssociationDataset', $qry, $fields);

    #END query_entity_AssociationDataset
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_AssociationDataset:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_AssociationDataset');
    }
    return($return);
}




=head2 all_entities_AssociationDataset

  $return = $obj->all_entities_AssociationDataset($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AssociationDataset
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AssociationDataset
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_AssociationDataset
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_AssociationDataset:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_AssociationDataset');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_AssociationDataset

    $return = $self->_all_entities($ctx, 'AssociationDataset', $start, $count, $fields);

    #END all_entities_AssociationDataset
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_AssociationDataset:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_AssociationDataset');
    }
    return($return);
}




=head2 get_entity_AssociationDetectionType

  $return = $obj->get_entity_AssociationDetectionType($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AssociationDetectionType
fields_AssociationDetectionType is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AssociationDetectionType
fields_AssociationDetectionType is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description

This documents methods by which associations are detected
or annotated.


It has the following fields:

=over 4

=item description

This is a brief description of this detection method. 


=back

=back

=cut

sub get_entity_AssociationDetectionType
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_AssociationDetectionType:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_AssociationDetectionType');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_AssociationDetectionType

    $return = $self->_get_entity($ctx, 'AssociationDetectionType', $ids, $fields);

    #END get_entity_AssociationDetectionType
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_AssociationDetectionType:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_AssociationDetectionType');
    }
    return($return);
}




=head2 query_entity_AssociationDetectionType

  $return = $obj->query_entity_AssociationDetectionType($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AssociationDetectionType
fields_AssociationDetectionType is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AssociationDetectionType
fields_AssociationDetectionType is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_AssociationDetectionType
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_AssociationDetectionType:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_AssociationDetectionType');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_AssociationDetectionType

    $return = $self->_query_entity($ctx, 'AssociationDetectionType', $qry, $fields);

    #END query_entity_AssociationDetectionType
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_AssociationDetectionType:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_AssociationDetectionType');
    }
    return($return);
}




=head2 all_entities_AssociationDetectionType

  $return = $obj->all_entities_AssociationDetectionType($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AssociationDetectionType
fields_AssociationDetectionType is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AssociationDetectionType
fields_AssociationDetectionType is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_AssociationDetectionType
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_AssociationDetectionType:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_AssociationDetectionType');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_AssociationDetectionType

    $return = $self->_all_entities($ctx, 'AssociationDetectionType', $start, $count, $fields);

    #END all_entities_AssociationDetectionType
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_AssociationDetectionType:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_AssociationDetectionType');
    }
    return($return);
}




=head2 get_entity_AtomicRegulon

  $return = $obj->get_entity_AtomicRegulon($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AtomicRegulon
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AtomicRegulon
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

An atomic regulon is an indivisible group of coregulated
features on a single genome. Atomic regulons are constructed so
that a given feature can only belong to one. Because of this, the
expression levels for atomic regulons represent in some sense the
state of a cell.

It has the following fields:

=over 4


=back

=back

=cut

sub get_entity_AtomicRegulon
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_AtomicRegulon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_AtomicRegulon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_AtomicRegulon

    $return = $self->_get_entity($ctx, 'AtomicRegulon', $ids, $fields);

    #END get_entity_AtomicRegulon
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_AtomicRegulon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_AtomicRegulon');
    }
    return($return);
}




=head2 query_entity_AtomicRegulon

  $return = $obj->query_entity_AtomicRegulon($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AtomicRegulon
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AtomicRegulon
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_AtomicRegulon
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_AtomicRegulon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_AtomicRegulon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_AtomicRegulon

    $return = $self->_query_entity($ctx, 'AtomicRegulon', $qry, $fields);

    #END query_entity_AtomicRegulon
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_AtomicRegulon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_AtomicRegulon');
    }
    return($return);
}




=head2 all_entities_AtomicRegulon

  $return = $obj->all_entities_AtomicRegulon($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AtomicRegulon
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_AtomicRegulon
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_AtomicRegulon
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_AtomicRegulon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_AtomicRegulon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_AtomicRegulon

    $return = $self->_all_entities($ctx, 'AtomicRegulon', $start, $count, $fields);

    #END all_entities_AtomicRegulon
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_AtomicRegulon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_AtomicRegulon');
    }
    return($return);
}




=head2 get_entity_Attribute

  $return = $obj->get_entity_Attribute($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Attribute
fields_Attribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Attribute
fields_Attribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description

An attribute describes a category of condition or characteristic for
an experiment. The goals of the experiment can be inferred from its values
for all the attributes of interest.

It has the following fields:

=over 4

=item description

Descriptive text indicating the nature and use of this attribute.


=back

=back

=cut

sub get_entity_Attribute
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Attribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Attribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Attribute

    $return = $self->_get_entity($ctx, 'Attribute', $ids, $fields);

    #END get_entity_Attribute
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Attribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Attribute');
    }
    return($return);
}




=head2 query_entity_Attribute

  $return = $obj->query_entity_Attribute($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Attribute
fields_Attribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Attribute
fields_Attribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Attribute
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Attribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Attribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Attribute

    $return = $self->_query_entity($ctx, 'Attribute', $qry, $fields);

    #END query_entity_Attribute
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Attribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Attribute');
    }
    return($return);
}




=head2 all_entities_Attribute

  $return = $obj->all_entities_Attribute($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Attribute
fields_Attribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Attribute
fields_Attribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Attribute
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Attribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Attribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Attribute

    $return = $self->_all_entities($ctx, 'Attribute', $start, $count, $fields);

    #END all_entities_Attribute
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Attribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Attribute');
    }
    return($return);
}




=head2 get_entity_Biomass

  $return = $obj->get_entity_Biomass($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Biomass
fields_Biomass is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a reference to a list where each element is a string
	dna has a value which is a float
	protein has a value which is a float
	cell_wall has a value which is a float
	lipid has a value which is a float
	cofactor has a value which is a float
	energy has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Biomass
fields_Biomass is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a reference to a list where each element is a string
	dna has a value which is a float
	protein has a value which is a float
	cell_wall has a value which is a float
	lipid has a value which is a float
	cofactor has a value which is a float
	energy has a value which is a float


=end text



=item Description

A biomass is a collection of compounds in a specific
ratio and in specific compartments that are necessary for a
cell to function properly. The prediction of biomasses is key
to the functioning of the model. Each biomass belongs to
a specific model.

It has the following fields:

=over 4

=item mod_date

last modification date of the biomass data

=item name

descriptive name for this biomass

=item dna

portion of a gram of this biomass (expressed as a fraction of 1.0) that is DNA

=item protein

portion of a gram of this biomass (expressed as a fraction of 1.0) that is protein

=item cell_wall

portion of a gram of this biomass (expressed as a fraction of 1.0) that is cell wall

=item lipid

portion of a gram of this biomass (expressed as a fraction of 1.0) that is lipid but is not part of the cell wall

=item cofactor

portion of a gram of this biomass (expressed as a fraction of 1.0) that function as cofactors

=item energy

number of ATP molecules hydrolized per gram of this biomass


=back

=back

=cut

sub get_entity_Biomass
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Biomass:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Biomass');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Biomass

    $return = $self->_get_entity($ctx, 'Biomass', $ids, $fields);

    #END get_entity_Biomass
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Biomass:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Biomass');
    }
    return($return);
}




=head2 query_entity_Biomass

  $return = $obj->query_entity_Biomass($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Biomass
fields_Biomass is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a reference to a list where each element is a string
	dna has a value which is a float
	protein has a value which is a float
	cell_wall has a value which is a float
	lipid has a value which is a float
	cofactor has a value which is a float
	energy has a value which is a float

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Biomass
fields_Biomass is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a reference to a list where each element is a string
	dna has a value which is a float
	protein has a value which is a float
	cell_wall has a value which is a float
	lipid has a value which is a float
	cofactor has a value which is a float
	energy has a value which is a float


=end text



=item Description



=back

=cut

sub query_entity_Biomass
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Biomass:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Biomass');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Biomass

    $return = $self->_query_entity($ctx, 'Biomass', $qry, $fields);

    #END query_entity_Biomass
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Biomass:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Biomass');
    }
    return($return);
}




=head2 all_entities_Biomass

  $return = $obj->all_entities_Biomass($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Biomass
fields_Biomass is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a reference to a list where each element is a string
	dna has a value which is a float
	protein has a value which is a float
	cell_wall has a value which is a float
	lipid has a value which is a float
	cofactor has a value which is a float
	energy has a value which is a float

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Biomass
fields_Biomass is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a reference to a list where each element is a string
	dna has a value which is a float
	protein has a value which is a float
	cell_wall has a value which is a float
	lipid has a value which is a float
	cofactor has a value which is a float
	energy has a value which is a float


=end text



=item Description



=back

=cut

sub all_entities_Biomass
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Biomass:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Biomass');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Biomass

    $return = $self->_all_entities($ctx, 'Biomass', $start, $count, $fields);

    #END all_entities_Biomass
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Biomass:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Biomass');
    }
    return($return);
}




=head2 get_entity_CodonUsage

  $return = $obj->get_entity_CodonUsage($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CodonUsage
fields_CodonUsage is a reference to a hash where the following keys are defined:
	id has a value which is a string
	frequencies has a value which is a string
	genetic_code has a value which is an int
	type has a value which is a string
	subtype has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CodonUsage
fields_CodonUsage is a reference to a hash where the following keys are defined:
	id has a value which is a string
	frequencies has a value which is a string
	genetic_code has a value which is an int
	type has a value which is a string
	subtype has a value which is a string


=end text



=item Description

This entity contains information about the codon usage
frequency in a particular genome with respect to a particular
type of analysis (e.g. high-expression genes, modal, mean,
etc.).

It has the following fields:

=over 4

=item frequencies

A packed-string representation of the codon usage frequencies. These are not global frequencies, but rather frequenicy of use relative to other codons that produce the same amino acid.

=item genetic_code

Genetic code used for these codons.

=item type

Type of frequency analysis: average, modal, high-expression, or non-native.

=item subtype

Specific nature of the codon usage with respect to the given type, generally indicative of how the frequencies were computed.


=back

=back

=cut

sub get_entity_CodonUsage
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_CodonUsage:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_CodonUsage');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_CodonUsage

    $return = $self->_get_entity($ctx, 'CodonUsage', $ids, $fields);

    #END get_entity_CodonUsage
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_CodonUsage:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_CodonUsage');
    }
    return($return);
}




=head2 query_entity_CodonUsage

  $return = $obj->query_entity_CodonUsage($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CodonUsage
fields_CodonUsage is a reference to a hash where the following keys are defined:
	id has a value which is a string
	frequencies has a value which is a string
	genetic_code has a value which is an int
	type has a value which is a string
	subtype has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CodonUsage
fields_CodonUsage is a reference to a hash where the following keys are defined:
	id has a value which is a string
	frequencies has a value which is a string
	genetic_code has a value which is an int
	type has a value which is a string
	subtype has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_CodonUsage
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_CodonUsage:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_CodonUsage');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_CodonUsage

    $return = $self->_query_entity($ctx, 'CodonUsage', $qry, $fields);

    #END query_entity_CodonUsage
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_CodonUsage:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_CodonUsage');
    }
    return($return);
}




=head2 all_entities_CodonUsage

  $return = $obj->all_entities_CodonUsage($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CodonUsage
fields_CodonUsage is a reference to a hash where the following keys are defined:
	id has a value which is a string
	frequencies has a value which is a string
	genetic_code has a value which is an int
	type has a value which is a string
	subtype has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CodonUsage
fields_CodonUsage is a reference to a hash where the following keys are defined:
	id has a value which is a string
	frequencies has a value which is a string
	genetic_code has a value which is an int
	type has a value which is a string
	subtype has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_CodonUsage
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_CodonUsage:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_CodonUsage');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_CodonUsage

    $return = $self->_all_entities($ctx, 'CodonUsage', $start, $count, $fields);

    #END all_entities_CodonUsage
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_CodonUsage:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_CodonUsage');
    }
    return($return);
}




=head2 get_entity_Complex

  $return = $obj->get_entity_Complex($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Complex
fields_Complex is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a reference to a list where each element is a string
	source_id has a value which is a string
	mod_date has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Complex
fields_Complex is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a reference to a list where each element is a string
	source_id has a value which is a string
	mod_date has a value which is a string


=end text



=item Description

A complex is a set of chemical reactions that act in concert to
effect a role.

It has the following fields:

=over 4

=item name

name of this complex. Not all complexes have names.

=item source_id

ID of this complex in the source from which it was added.

=item mod_date

date and time of the last change to this complex's definition


=back

=back

=cut

sub get_entity_Complex
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Complex:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Complex');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Complex

    $return = $self->_get_entity($ctx, 'Complex', $ids, $fields);

    #END get_entity_Complex
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Complex:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Complex');
    }
    return($return);
}




=head2 query_entity_Complex

  $return = $obj->query_entity_Complex($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Complex
fields_Complex is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a reference to a list where each element is a string
	source_id has a value which is a string
	mod_date has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Complex
fields_Complex is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a reference to a list where each element is a string
	source_id has a value which is a string
	mod_date has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Complex
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Complex:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Complex');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Complex

    $return = $self->_query_entity($ctx, 'Complex', $qry, $fields);

    #END query_entity_Complex
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Complex:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Complex');
    }
    return($return);
}




=head2 all_entities_Complex

  $return = $obj->all_entities_Complex($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Complex
fields_Complex is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a reference to a list where each element is a string
	source_id has a value which is a string
	mod_date has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Complex
fields_Complex is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a reference to a list where each element is a string
	source_id has a value which is a string
	mod_date has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Complex
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Complex:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Complex');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Complex

    $return = $self->_all_entities($ctx, 'Complex', $start, $count, $fields);

    #END all_entities_Complex
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Complex:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Complex');
    }
    return($return);
}




=head2 get_entity_Compound

  $return = $obj->get_entity_Compound($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Compound
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Compound
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float


=end text



=item Description

A compound is a chemical that participates in a reaction. Both
ligands and reaction components are treated as compounds.

It has the following fields:

=over 4

=item label

primary name of the compound, for use in displaying reactions

=item abbr

shortened abbreviation for the compound name

=item source_id

common modeling ID of this compound

=item ubiquitous

TRUE if this compound is found in most reactions, else FALSE

=item mod_date

date and time of the last modification to the compound definition

=item mass

pH-neutral atomic mass of the compound

=item formula

a pH-neutral formula for the compound

=item charge

computed charge of the compound in a pH-neutral solution

=item deltaG

the pH 7 reference Gibbs free-energy of formation for this compound as calculated by the group contribution method (units are kcal/mol)

=item deltaG_error

the uncertainty in the [b]deltaG[/b] value (units are kcal/mol)


=back

=back

=cut

sub get_entity_Compound
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Compound:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Compound');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Compound

    $return = $self->_get_entity($ctx, 'Compound', $ids, $fields);

    #END get_entity_Compound
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Compound:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Compound');
    }
    return($return);
}




=head2 query_entity_Compound

  $return = $obj->query_entity_Compound($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Compound
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Compound
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float


=end text



=item Description



=back

=cut

sub query_entity_Compound
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Compound:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Compound');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Compound

    $return = $self->_query_entity($ctx, 'Compound', $qry, $fields);

    #END query_entity_Compound
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Compound:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Compound');
    }
    return($return);
}




=head2 all_entities_Compound

  $return = $obj->all_entities_Compound($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Compound
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Compound
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float


=end text



=item Description



=back

=cut

sub all_entities_Compound
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Compound:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Compound');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Compound

    $return = $self->_all_entities($ctx, 'Compound', $start, $count, $fields);

    #END all_entities_Compound
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Compound:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Compound');
    }
    return($return);
}




=head2 get_entity_CompoundInstance

  $return = $obj->get_entity_CompoundInstance($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CompoundInstance
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CompoundInstance
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string


=end text



=item Description

A Compound Instance represents the occurrence of a particular
compound in a location in a model.

It has the following fields:

=over 4

=item charge

computed charge based on the location instance pH and similar constraints

=item formula

computed chemical formula for this compound based on the location instance pH and similar constraints


=back

=back

=cut

sub get_entity_CompoundInstance
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_CompoundInstance:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_CompoundInstance');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_CompoundInstance

    $return = $self->_get_entity($ctx, 'CompoundInstance', $ids, $fields);

    #END get_entity_CompoundInstance
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_CompoundInstance:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_CompoundInstance');
    }
    return($return);
}




=head2 query_entity_CompoundInstance

  $return = $obj->query_entity_CompoundInstance($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CompoundInstance
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CompoundInstance
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_CompoundInstance
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_CompoundInstance:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_CompoundInstance');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_CompoundInstance

    $return = $self->_query_entity($ctx, 'CompoundInstance', $qry, $fields);

    #END query_entity_CompoundInstance
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_CompoundInstance:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_CompoundInstance');
    }
    return($return);
}




=head2 all_entities_CompoundInstance

  $return = $obj->all_entities_CompoundInstance($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CompoundInstance
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CompoundInstance
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_CompoundInstance
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_CompoundInstance:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_CompoundInstance');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_CompoundInstance

    $return = $self->_all_entities($ctx, 'CompoundInstance', $start, $count, $fields);

    #END all_entities_CompoundInstance
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_CompoundInstance:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_CompoundInstance');
    }
    return($return);
}




=head2 get_entity_ConservedDomainModel

  $return = $obj->get_entity_ConservedDomainModel($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ConservedDomainModel
fields_ConservedDomainModel is a reference to a hash where the following keys are defined:
	id has a value which is a string
	accession has a value which is a string
	short_name has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ConservedDomainModel
fields_ConservedDomainModel is a reference to a hash where the following keys are defined:
	id has a value which is a string
	accession has a value which is a string
	short_name has a value which is a string
	description has a value which is a string


=end text



=item Description

A ConservedDomainModel represents a conserved domain model
as found in the NCBI CDD archive.
The id of a ConservedDomainModel is the PSSM-Id. 

It has the following fields:

=over 4

=item accession

CD accession (starting with 'cd', 'pfam', 'smart', 'COG', 'PRK' or "CHL')

=item short_name

CD short name

=item description

CD description


=back

=back

=cut

sub get_entity_ConservedDomainModel
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_ConservedDomainModel:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ConservedDomainModel');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_ConservedDomainModel

    $return = $self->_get_entity($ctx, 'ConservedDomainModel', $ids, $fields);

    #END get_entity_ConservedDomainModel
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_ConservedDomainModel:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ConservedDomainModel');
    }
    return($return);
}




=head2 query_entity_ConservedDomainModel

  $return = $obj->query_entity_ConservedDomainModel($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ConservedDomainModel
fields_ConservedDomainModel is a reference to a hash where the following keys are defined:
	id has a value which is a string
	accession has a value which is a string
	short_name has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ConservedDomainModel
fields_ConservedDomainModel is a reference to a hash where the following keys are defined:
	id has a value which is a string
	accession has a value which is a string
	short_name has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_ConservedDomainModel
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_ConservedDomainModel:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ConservedDomainModel');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_ConservedDomainModel

    $return = $self->_query_entity($ctx, 'ConservedDomainModel', $qry, $fields);

    #END query_entity_ConservedDomainModel
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_ConservedDomainModel:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ConservedDomainModel');
    }
    return($return);
}




=head2 all_entities_ConservedDomainModel

  $return = $obj->all_entities_ConservedDomainModel($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ConservedDomainModel
fields_ConservedDomainModel is a reference to a hash where the following keys are defined:
	id has a value which is a string
	accession has a value which is a string
	short_name has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ConservedDomainModel
fields_ConservedDomainModel is a reference to a hash where the following keys are defined:
	id has a value which is a string
	accession has a value which is a string
	short_name has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_ConservedDomainModel
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_ConservedDomainModel:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ConservedDomainModel');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_ConservedDomainModel

    $return = $self->_all_entities($ctx, 'ConservedDomainModel', $start, $count, $fields);

    #END all_entities_ConservedDomainModel
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_ConservedDomainModel:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ConservedDomainModel');
    }
    return($return);
}




=head2 get_entity_Contig

  $return = $obj->get_entity_Contig($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Contig
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Contig
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description

A contig is thought of as composing a part of the DNA
associated with a specific genome.  It is represented as an ID
(including the genome ID) and a ContigSequence. We do not think
of strings of DNA from, say, a metgenomic sample as "contigs",
since there is no associated genome (these would be considered
ContigSequences). This use of the term "ContigSequence", rather
than just "DNA sequence", may turn out to be a bad idea.  For now,
you should just realize that a Contig has an associated
genome, but a ContigSequence does not.

It has the following fields:

=over 4

=item source_id

ID of this contig from the core (source) database


=back

=back

=cut

sub get_entity_Contig
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Contig:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Contig');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Contig

    $return = $self->_get_entity($ctx, 'Contig', $ids, $fields);

    #END get_entity_Contig
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Contig:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Contig');
    }
    return($return);
}




=head2 query_entity_Contig

  $return = $obj->query_entity_Contig($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Contig
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Contig
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Contig
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Contig:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Contig');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Contig

    $return = $self->_query_entity($ctx, 'Contig', $qry, $fields);

    #END query_entity_Contig
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Contig:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Contig');
    }
    return($return);
}




=head2 all_entities_Contig

  $return = $obj->all_entities_Contig($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Contig
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Contig
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Contig
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Contig:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Contig');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Contig

    $return = $self->_all_entities($ctx, 'Contig', $start, $count, $fields);

    #END all_entities_Contig
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Contig:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Contig');
    }
    return($return);
}




=head2 get_entity_ContigChunk

  $return = $obj->get_entity_ContigChunk($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ContigChunk
fields_ContigChunk is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ContigChunk
fields_ContigChunk is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string


=end text



=item Description

ContigChunks are strings of DNA thought of as being a
string in a 4-character alphabet with an associated ID.  We
allow a broader alphabet that includes U (for RNA) and
the standard ambiguity characters.

It has the following fields:

=over 4

=item sequence

base pairs that make up this sequence


=back

=back

=cut

sub get_entity_ContigChunk
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_ContigChunk:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ContigChunk');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_ContigChunk

    $return = $self->_get_entity($ctx, 'ContigChunk', $ids, $fields);

    #END get_entity_ContigChunk
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_ContigChunk:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ContigChunk');
    }
    return($return);
}




=head2 query_entity_ContigChunk

  $return = $obj->query_entity_ContigChunk($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ContigChunk
fields_ContigChunk is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ContigChunk
fields_ContigChunk is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_ContigChunk
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_ContigChunk:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ContigChunk');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_ContigChunk

    $return = $self->_query_entity($ctx, 'ContigChunk', $qry, $fields);

    #END query_entity_ContigChunk
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_ContigChunk:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ContigChunk');
    }
    return($return);
}




=head2 all_entities_ContigChunk

  $return = $obj->all_entities_ContigChunk($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ContigChunk
fields_ContigChunk is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ContigChunk
fields_ContigChunk is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_ContigChunk
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_ContigChunk:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ContigChunk');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_ContigChunk

    $return = $self->_all_entities($ctx, 'ContigChunk', $start, $count, $fields);

    #END all_entities_ContigChunk
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_ContigChunk:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ContigChunk');
    }
    return($return);
}




=head2 get_entity_ContigSequence

  $return = $obj->get_entity_ContigSequence($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ContigSequence
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ContigSequence
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int


=end text



=item Description

ContigSequences are strings of DNA.  Contigs have an
associated genome, but ContigSequences do not.  We can think
of random samples of DNA as a set of ContigSequences. There
are no length constraints imposed on ContigSequences -- they
can be either very short or very long.  The basic unit of data
that is moved to/from the database is the ContigChunk, from
which ContigSequences are formed. The key of a ContigSequence
is the sequence's MD5 identifier.

It has the following fields:

=over 4

=item length

number of base pairs in the contig


=back

=back

=cut

sub get_entity_ContigSequence
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_ContigSequence:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ContigSequence');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_ContigSequence

    $return = $self->_get_entity($ctx, 'ContigSequence', $ids, $fields);

    #END get_entity_ContigSequence
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_ContigSequence:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ContigSequence');
    }
    return($return);
}




=head2 query_entity_ContigSequence

  $return = $obj->query_entity_ContigSequence($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ContigSequence
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ContigSequence
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int


=end text



=item Description



=back

=cut

sub query_entity_ContigSequence
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_ContigSequence:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ContigSequence');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_ContigSequence

    $return = $self->_query_entity($ctx, 'ContigSequence', $qry, $fields);

    #END query_entity_ContigSequence
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_ContigSequence:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ContigSequence');
    }
    return($return);
}




=head2 all_entities_ContigSequence

  $return = $obj->all_entities_ContigSequence($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ContigSequence
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ContigSequence
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int


=end text



=item Description



=back

=cut

sub all_entities_ContigSequence
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_ContigSequence:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ContigSequence');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_ContigSequence

    $return = $self->_all_entities($ctx, 'ContigSequence', $start, $count, $fields);

    #END all_entities_ContigSequence
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_ContigSequence:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ContigSequence');
    }
    return($return);
}




=head2 get_entity_CoregulatedSet

  $return = $obj->get_entity_CoregulatedSet($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CoregulatedSet
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CoregulatedSet
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int


=end text



=item Description

We need to represent sets of genes that are coregulated via
some regulatory mechanism.  In particular, we wish to represent
genes that are coregulated using transcription binding sites and
corresponding transcription regulatory proteins. We represent a
coregulated set (which may, or may not, be considered a regulon)
using CoregulatedSet.

It has the following fields:

=over 4

=item source_id

original ID of this coregulated set in the source (core) database

=item binding_location

binding location for this set's transcription factor; there may be none of these or there may be more than one


=back

=back

=cut

sub get_entity_CoregulatedSet
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_CoregulatedSet:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_CoregulatedSet');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_CoregulatedSet

    $return = $self->_get_entity($ctx, 'CoregulatedSet', $ids, $fields);

    #END get_entity_CoregulatedSet
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_CoregulatedSet:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_CoregulatedSet');
    }
    return($return);
}




=head2 query_entity_CoregulatedSet

  $return = $obj->query_entity_CoregulatedSet($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CoregulatedSet
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CoregulatedSet
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int


=end text



=item Description



=back

=cut

sub query_entity_CoregulatedSet
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_CoregulatedSet:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_CoregulatedSet');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_CoregulatedSet

    $return = $self->_query_entity($ctx, 'CoregulatedSet', $qry, $fields);

    #END query_entity_CoregulatedSet
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_CoregulatedSet:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_CoregulatedSet');
    }
    return($return);
}




=head2 all_entities_CoregulatedSet

  $return = $obj->all_entities_CoregulatedSet($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CoregulatedSet
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_CoregulatedSet
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int


=end text



=item Description



=back

=cut

sub all_entities_CoregulatedSet
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_CoregulatedSet:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_CoregulatedSet');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_CoregulatedSet

    $return = $self->_all_entities($ctx, 'CoregulatedSet', $start, $count, $fields);

    #END all_entities_CoregulatedSet
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_CoregulatedSet:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_CoregulatedSet');
    }
    return($return);
}




=head2 get_entity_Diagram

  $return = $obj->get_entity_Diagram($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Diagram
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Diagram
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string


=end text



=item Description

A functional diagram describes a network of chemical
reactions, often comprising a single subsystem.

It has the following fields:

=over 4

=item name

descriptive name of this diagram

=item content

content of the diagram, in PNG format


=back

=back

=cut

sub get_entity_Diagram
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Diagram:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Diagram');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Diagram

    $return = $self->_get_entity($ctx, 'Diagram', $ids, $fields);

    #END get_entity_Diagram
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Diagram:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Diagram');
    }
    return($return);
}




=head2 query_entity_Diagram

  $return = $obj->query_entity_Diagram($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Diagram
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Diagram
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub query_entity_Diagram
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Diagram:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Diagram');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Diagram

    $return = $self->_query_entity($ctx, 'Diagram', $qry, $fields);

    #END query_entity_Diagram
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Diagram:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Diagram');
    }
    return($return);
}




=head2 all_entities_Diagram

  $return = $obj->all_entities_Diagram($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Diagram
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Diagram
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub all_entities_Diagram
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Diagram:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Diagram');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Diagram

    $return = $self->_all_entities($ctx, 'Diagram', $start, $count, $fields);

    #END all_entities_Diagram
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Diagram:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Diagram');
    }
    return($return);
}




=head2 get_entity_EcNumber

  $return = $obj->get_entity_EcNumber($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_EcNumber
fields_EcNumber is a reference to a hash where the following keys are defined:
	id has a value which is a string
	obsolete has a value which is an int
	replacedby has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_EcNumber
fields_EcNumber is a reference to a hash where the following keys are defined:
	id has a value which is a string
	obsolete has a value which is an int
	replacedby has a value which is a string


=end text



=item Description

EC numbers are assigned by the Enzyme Commission, and consist
of four numbers separated by periods, each indicating a successively
smaller cateogry of enzymes.

It has the following fields:

=over 4

=item obsolete

This boolean indicates when an EC number is obsolete.

=item replacedby

When an obsolete EC number is replaced with another EC number, this string will hold the name of the replacement EC number.


=back

=back

=cut

sub get_entity_EcNumber
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_EcNumber:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_EcNumber');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_EcNumber

    $return = $self->_get_entity($ctx, 'EcNumber', $ids, $fields);

    #END get_entity_EcNumber
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_EcNumber:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_EcNumber');
    }
    return($return);
}




=head2 query_entity_EcNumber

  $return = $obj->query_entity_EcNumber($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_EcNumber
fields_EcNumber is a reference to a hash where the following keys are defined:
	id has a value which is a string
	obsolete has a value which is an int
	replacedby has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_EcNumber
fields_EcNumber is a reference to a hash where the following keys are defined:
	id has a value which is a string
	obsolete has a value which is an int
	replacedby has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_EcNumber
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_EcNumber:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_EcNumber');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_EcNumber

    $return = $self->_query_entity($ctx, 'EcNumber', $qry, $fields);

    #END query_entity_EcNumber
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_EcNumber:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_EcNumber');
    }
    return($return);
}




=head2 all_entities_EcNumber

  $return = $obj->all_entities_EcNumber($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_EcNumber
fields_EcNumber is a reference to a hash where the following keys are defined:
	id has a value which is a string
	obsolete has a value which is an int
	replacedby has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_EcNumber
fields_EcNumber is a reference to a hash where the following keys are defined:
	id has a value which is a string
	obsolete has a value which is an int
	replacedby has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_EcNumber
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_EcNumber:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_EcNumber');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_EcNumber

    $return = $self->_all_entities($ctx, 'EcNumber', $start, $count, $fields);

    #END all_entities_EcNumber
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_EcNumber:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_EcNumber');
    }
    return($return);
}




=head2 get_entity_Effector

  $return = $obj->get_entity_Effector($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Effector
fields_Effector is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	effector_class has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Effector
fields_Effector is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	effector_class has a value which is a string


=end text



=item Description

It has the following fields:

=over 4

=item name

Name of this effector.

=item effector_class

The class of this effector.


=back

=back

=cut

sub get_entity_Effector
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Effector:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Effector');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Effector

    $return = $self->_get_entity($ctx, 'Effector', $ids, $fields);

    #END get_entity_Effector
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Effector:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Effector');
    }
    return($return);
}




=head2 query_entity_Effector

  $return = $obj->query_entity_Effector($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Effector
fields_Effector is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	effector_class has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Effector
fields_Effector is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	effector_class has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Effector
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Effector:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Effector');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Effector

    $return = $self->_query_entity($ctx, 'Effector', $qry, $fields);

    #END query_entity_Effector
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Effector:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Effector');
    }
    return($return);
}




=head2 all_entities_Effector

  $return = $obj->all_entities_Effector($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Effector
fields_Effector is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	effector_class has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Effector
fields_Effector is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	effector_class has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Effector
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Effector:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Effector');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Effector

    $return = $self->_all_entities($ctx, 'Effector', $start, $count, $fields);

    #END all_entities_Effector
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Effector:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Effector');
    }
    return($return);
}




=head2 get_entity_Environment

  $return = $obj->get_entity_Environment($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Environment
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Environment
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string


=end text



=item Description

An Environment is a set of conditions for microbial growth,
including temperature, aerobicity, media, and supplementary
conditions.

It has the following fields:

=over 4

=item temperature

The temperature in Kelvin.

=item description

A description of the environment.

=item oxygenConcentration

The oxygen concentration in the environment in Molar (mol/L). A value of -1 indicates that there is oxygen in the environment but the concentration is not known, (e.g. an open air shake flask experiment).

=item pH

The pH of the media used in the environment.

=item source_id

The ID of the environment used by the data source.


=back

=back

=cut

sub get_entity_Environment
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Environment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Environment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Environment

    $return = $self->_get_entity($ctx, 'Environment', $ids, $fields);

    #END get_entity_Environment
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Environment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Environment');
    }
    return($return);
}




=head2 query_entity_Environment

  $return = $obj->query_entity_Environment($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Environment
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Environment
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Environment
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Environment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Environment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Environment

    $return = $self->_query_entity($ctx, 'Environment', $qry, $fields);

    #END query_entity_Environment
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Environment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Environment');
    }
    return($return);
}




=head2 all_entities_Environment

  $return = $obj->all_entities_Environment($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Environment
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Environment
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Environment
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Environment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Environment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Environment

    $return = $self->_all_entities($ctx, 'Environment', $start, $count, $fields);

    #END all_entities_Environment
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Environment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Environment');
    }
    return($return);
}




=head2 get_entity_Experiment

  $return = $obj->get_entity_Experiment($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Experiment
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Experiment
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string


=end text



=item Description

An experiment is a combination of conditions for which gene expression
information is desired. The result of the experiment is a set of expression
levels for features under the given conditions.

It has the following fields:

=over 4

=item source

Publication or lab relevant to this experiment.


=back

=back

=cut

sub get_entity_Experiment
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Experiment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Experiment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Experiment

    $return = $self->_get_entity($ctx, 'Experiment', $ids, $fields);

    #END get_entity_Experiment
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Experiment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Experiment');
    }
    return($return);
}




=head2 query_entity_Experiment

  $return = $obj->query_entity_Experiment($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Experiment
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Experiment
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Experiment
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Experiment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Experiment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Experiment

    $return = $self->_query_entity($ctx, 'Experiment', $qry, $fields);

    #END query_entity_Experiment
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Experiment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Experiment');
    }
    return($return);
}




=head2 all_entities_Experiment

  $return = $obj->all_entities_Experiment($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Experiment
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Experiment
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Experiment
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Experiment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Experiment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Experiment

    $return = $self->_all_entities($ctx, 'Experiment', $start, $count, $fields);

    #END all_entities_Experiment
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Experiment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Experiment');
    }
    return($return);
}




=head2 get_entity_ExperimentMeta

  $return = $obj->get_entity_ExperimentMeta($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentMeta
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentMeta
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string


=end text



=item Description

An Experiment consists of (potentially) multiple
strains, environments, and measurements on
those strains and environments.

It has the following fields:

=over 4

=item title

Title of the experiment.

=item description

Description of the experiment including the experimental plan, general results, and conclusions, if possible.

=item source_id

The ID of the experiment used by the data source.

=item startDate

The date this experiment was started.

=item comments

Any data describing the experiment that is not covered by the description field.


=back

=back

=cut

sub get_entity_ExperimentMeta
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_ExperimentMeta:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ExperimentMeta');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_ExperimentMeta

    $return = $self->_get_entity($ctx, 'ExperimentMeta', $ids, $fields);

    #END get_entity_ExperimentMeta
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_ExperimentMeta:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ExperimentMeta');
    }
    return($return);
}




=head2 query_entity_ExperimentMeta

  $return = $obj->query_entity_ExperimentMeta($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentMeta
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentMeta
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_ExperimentMeta
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_ExperimentMeta:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ExperimentMeta');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_ExperimentMeta

    $return = $self->_query_entity($ctx, 'ExperimentMeta', $qry, $fields);

    #END query_entity_ExperimentMeta
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_ExperimentMeta:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ExperimentMeta');
    }
    return($return);
}




=head2 all_entities_ExperimentMeta

  $return = $obj->all_entities_ExperimentMeta($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentMeta
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentMeta
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_ExperimentMeta
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_ExperimentMeta:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ExperimentMeta');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_ExperimentMeta

    $return = $self->_all_entities($ctx, 'ExperimentMeta', $start, $count, $fields);

    #END all_entities_ExperimentMeta
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_ExperimentMeta:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ExperimentMeta');
    }
    return($return);
}




=head2 get_entity_ExperimentalUnit

  $return = $obj->get_entity_ExperimentalUnit($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentalUnit
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentalUnit
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description

An ExperimentalUnit is a subset of an experiment consisting of
a Strain, an Environment, and one or more Measurements on that
strain in the specified environment. ExperimentalUnits belong to a
single experiment.

It has the following fields:

=over 4

=item source_id

The ID of the experimental unit used by the data source.


=back

=back

=cut

sub get_entity_ExperimentalUnit
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_ExperimentalUnit:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ExperimentalUnit');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_ExperimentalUnit

    $return = $self->_get_entity($ctx, 'ExperimentalUnit', $ids, $fields);

    #END get_entity_ExperimentalUnit
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_ExperimentalUnit:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ExperimentalUnit');
    }
    return($return);
}




=head2 query_entity_ExperimentalUnit

  $return = $obj->query_entity_ExperimentalUnit($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentalUnit
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentalUnit
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_ExperimentalUnit
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_ExperimentalUnit:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ExperimentalUnit');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_ExperimentalUnit

    $return = $self->_query_entity($ctx, 'ExperimentalUnit', $qry, $fields);

    #END query_entity_ExperimentalUnit
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_ExperimentalUnit:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ExperimentalUnit');
    }
    return($return);
}




=head2 all_entities_ExperimentalUnit

  $return = $obj->all_entities_ExperimentalUnit($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentalUnit
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentalUnit
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_ExperimentalUnit
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_ExperimentalUnit:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ExperimentalUnit');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_ExperimentalUnit

    $return = $self->_all_entities($ctx, 'ExperimentalUnit', $start, $count, $fields);

    #END all_entities_ExperimentalUnit
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_ExperimentalUnit:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ExperimentalUnit');
    }
    return($return);
}




=head2 get_entity_ExperimentalUnitGroup

  $return = $obj->get_entity_ExperimentalUnitGroup($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentalUnitGroup
fields_ExperimentalUnitGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	groupType has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentalUnitGroup
fields_ExperimentalUnitGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	groupType has a value which is a string


=end text



=item Description

An ExperimentalUnitGroup allows for grouping related experimental units
and their measurements - for instance measurements that were in the same plate.


It has the following fields:

=over 4

=item source_id

The ID of the experimental unit group used by the data source.

=item name

The name of this group, if any.

=item comments

Any comments about this group.

=item groupType

The type of this grouping, for example '24 well plate', '96 well plate', '384 well plate', 'microarray'.


=back

=back

=cut

sub get_entity_ExperimentalUnitGroup
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_ExperimentalUnitGroup:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ExperimentalUnitGroup');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_ExperimentalUnitGroup

    $return = $self->_get_entity($ctx, 'ExperimentalUnitGroup', $ids, $fields);

    #END get_entity_ExperimentalUnitGroup
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_ExperimentalUnitGroup:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ExperimentalUnitGroup');
    }
    return($return);
}




=head2 query_entity_ExperimentalUnitGroup

  $return = $obj->query_entity_ExperimentalUnitGroup($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentalUnitGroup
fields_ExperimentalUnitGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	groupType has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentalUnitGroup
fields_ExperimentalUnitGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	groupType has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_ExperimentalUnitGroup
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_ExperimentalUnitGroup:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ExperimentalUnitGroup');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_ExperimentalUnitGroup

    $return = $self->_query_entity($ctx, 'ExperimentalUnitGroup', $qry, $fields);

    #END query_entity_ExperimentalUnitGroup
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_ExperimentalUnitGroup:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ExperimentalUnitGroup');
    }
    return($return);
}




=head2 all_entities_ExperimentalUnitGroup

  $return = $obj->all_entities_ExperimentalUnitGroup($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentalUnitGroup
fields_ExperimentalUnitGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	groupType has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ExperimentalUnitGroup
fields_ExperimentalUnitGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	groupType has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_ExperimentalUnitGroup
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_ExperimentalUnitGroup:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ExperimentalUnitGroup');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_ExperimentalUnitGroup

    $return = $self->_all_entities($ctx, 'ExperimentalUnitGroup', $start, $count, $fields);

    #END all_entities_ExperimentalUnitGroup
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_ExperimentalUnitGroup:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ExperimentalUnitGroup');
    }
    return($return);
}




=head2 get_entity_Family

  $return = $obj->get_entity_Family($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Family
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Family
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string


=end text



=item Description

The Kbase will support the maintenance of protein families
(as sets of Features with associated translations).  We are
initially only supporting the notion of a family as composed of
a set of isofunctional homologs.  That is, the families we
initially support should be thought of as containing
protein-encoding genes whose associated sequences all implement
the same function (we do understand that the notion of "function"
is somewhat ambiguous, so let us sweep this under the rug by
calling a functional role a "primitive concept").
We currently support families in which the members are
protein sequences as well. Identical protein sequences
as products of translating distinct genes may or may not
have identical functions.  This may be justified, since
in a very, very, very few cases identical proteins do, in
fact, have distinct functions.

It has the following fields:

=over 4

=item type

type of protein family (e.g. FIGfam, equivalog)

=item release

release number / subtype of protein family

=item family_function

optional free-form description of the family. For function-based families, this would be the functional role for the family members.

=item alignment

FASTA-formatted alignment of the family's protein sequences


=back

=back

=cut

sub get_entity_Family
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Family:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Family');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Family

    $return = $self->_get_entity($ctx, 'Family', $ids, $fields);

    #END get_entity_Family
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Family:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Family');
    }
    return($return);
}




=head2 query_entity_Family

  $return = $obj->query_entity_Family($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Family
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Family
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub query_entity_Family
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Family:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Family');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Family

    $return = $self->_query_entity($ctx, 'Family', $qry, $fields);

    #END query_entity_Family
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Family:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Family');
    }
    return($return);
}




=head2 all_entities_Family

  $return = $obj->all_entities_Family($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Family
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Family
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub all_entities_Family
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Family:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Family');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Family

    $return = $self->_all_entities($ctx, 'Family', $start, $count, $fields);

    #END all_entities_Family
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Family:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Family');
    }
    return($return);
}




=head2 get_entity_Feature

  $return = $obj->get_entity_Feature($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Feature
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Feature
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description

A feature (sometimes also called a gene) is a part of a
genome that is of special interest. Features may be spread across
multiple DNA sequences (contigs) of a genome, but never across more
than one genome. Each feature in the database has a unique
ID that functions as its ID in this table. Normally a Feature is
just a single contigous region on a contig. Features have types,
and an appropriate choice of available types allows the support
of protein-encoding genes, exons, RNA genes, binding sites,
pathogenicity islands, or whatever.

It has the following fields:

=over 4

=item feature_type

Code indicating the type of this feature. Among the codes currently supported are "peg" for a protein encoding gene, "bs" for a binding site, "opr" for an operon, and so forth.

=item source_id

ID for this feature in its original source (core) database

=item sequence_length

Number of base pairs in this feature.

=item function

Functional assignment for this feature. This will often indicate the feature's functional role or roles, and may also have comments.

=item alias

alternative identifier for the feature. These are highly unstructured, and frequently non-unique.


=back

=back

=cut

sub get_entity_Feature
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Feature:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Feature');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Feature

    $return = $self->_get_entity($ctx, 'Feature', $ids, $fields);

    #END get_entity_Feature
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Feature:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Feature');
    }
    return($return);
}




=head2 query_entity_Feature

  $return = $obj->query_entity_Feature($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Feature
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Feature
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub query_entity_Feature
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Feature:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Feature');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Feature

    $return = $self->_query_entity($ctx, 'Feature', $qry, $fields);

    #END query_entity_Feature
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Feature:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Feature');
    }
    return($return);
}




=head2 all_entities_Feature

  $return = $obj->all_entities_Feature($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Feature
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Feature
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub all_entities_Feature
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Feature:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Feature');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Feature

    $return = $self->_all_entities($ctx, 'Feature', $start, $count, $fields);

    #END all_entities_Feature
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Feature:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Feature');
    }
    return($return);
}




=head2 get_entity_Genome

  $return = $obj->get_entity_Genome($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Genome
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Genome
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description

The Kbase houses a large and growing set of genomes.  We
often have multiple genomes that have identical DNA.  These usually
have distinct gene calls and annotations, but not always.  We
consider the Kbase to be a framework for managing hundreds of
thousands of genomes and offering the tools needed to
support compartive analysis on large sets of genomes,
some of which are virtually identical.

It has the following fields:

=over 4

=item pegs

Number of protein encoding genes for this genome.

=item rnas

Number of RNA features found for this organism.

=item scientific_name

Full genus/species/strain name of the genome sequence.

=item complete

TRUE if the genome sequence is complete, else FALSE

=item prokaryotic

TRUE if this is a prokaryotic genome sequence, else FALSE

=item dna_size

Number of base pairs in the genome sequence.

=item contigs

Number of contigs for this genome sequence.

=item domain

Domain for this organism (Archaea, Bacteria, Eukaryota, Virus, Plasmid, or Environmental Sample).

=item genetic_code

Genetic code number used for protein translation on most of this genome sequence's contigs.

=item gc_content

Percent GC content present in the genome sequence's DNA.

=item phenotype

zero or more strings describing phenotypic information about this genome sequence

=item md5

MD5 identifier describing the genome's DNA sequence

=item source_id

identifier assigned to this genome by the original source


=back

=back

=cut

sub get_entity_Genome
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Genome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Genome');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Genome

    $return = $self->_get_entity($ctx, 'Genome', $ids, $fields);

    #END get_entity_Genome
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Genome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Genome');
    }
    return($return);
}




=head2 query_entity_Genome

  $return = $obj->query_entity_Genome($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Genome
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Genome
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Genome
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Genome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Genome');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Genome

    $return = $self->_query_entity($ctx, 'Genome', $qry, $fields);

    #END query_entity_Genome
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Genome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Genome');
    }
    return($return);
}




=head2 all_entities_Genome

  $return = $obj->all_entities_Genome($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Genome
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Genome
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Genome
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Genome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Genome');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Genome

    $return = $self->_all_entities($ctx, 'Genome', $start, $count, $fields);

    #END all_entities_Genome
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Genome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Genome');
    }
    return($return);
}




=head2 get_entity_Locality

  $return = $obj->get_entity_Locality($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Locality
fields_Locality is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	city has a value which is a string
	state has a value which is a string
	country has a value which is a string
	origcty has a value which is a string
	elevation has a value which is an int
	latitude has a value which is an int
	longitude has a value which is an int
	lo_accession has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Locality
fields_Locality is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	city has a value which is a string
	state has a value which is a string
	country has a value which is a string
	origcty has a value which is a string
	elevation has a value which is an int
	latitude has a value which is an int
	longitude has a value which is an int
	lo_accession has a value which is a string


=end text



=item Description

A locality is a geographic location.

It has the following fields:

=over 4

=item source_name

Name or description of the location used as a collection site.

=item city

City of the collecting site.

=item state

State or province of the collecting site.

=item country

Country of the collecting site.

=item origcty

3-letter ISO 3166-1 extended country code for the country of origin.

=item elevation

Elevation of the collecting site, expressed in meters above sea level.  Negative values are allowed.

=item latitude

Latitude of the collecting site, recorded as a decimal number.  North latitudes are positive values and south latitudes are negative numbers.

=item longitude

Longitude of the collecting site, recorded as a decimal number.  West longitudes are positive values and east longitudes are negative numbers.

=item lo_accession

gazeteer ontology term ID


=back

=back

=cut

sub get_entity_Locality
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Locality:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Locality');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Locality

    $return = $self->_get_entity($ctx, 'Locality', $ids, $fields);

    #END get_entity_Locality
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Locality:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Locality');
    }
    return($return);
}




=head2 query_entity_Locality

  $return = $obj->query_entity_Locality($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Locality
fields_Locality is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	city has a value which is a string
	state has a value which is a string
	country has a value which is a string
	origcty has a value which is a string
	elevation has a value which is an int
	latitude has a value which is an int
	longitude has a value which is an int
	lo_accession has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Locality
fields_Locality is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	city has a value which is a string
	state has a value which is a string
	country has a value which is a string
	origcty has a value which is a string
	elevation has a value which is an int
	latitude has a value which is an int
	longitude has a value which is an int
	lo_accession has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Locality
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Locality:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Locality');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Locality

    $return = $self->_query_entity($ctx, 'Locality', $qry, $fields);

    #END query_entity_Locality
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Locality:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Locality');
    }
    return($return);
}




=head2 all_entities_Locality

  $return = $obj->all_entities_Locality($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Locality
fields_Locality is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	city has a value which is a string
	state has a value which is a string
	country has a value which is a string
	origcty has a value which is a string
	elevation has a value which is an int
	latitude has a value which is an int
	longitude has a value which is an int
	lo_accession has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Locality
fields_Locality is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	city has a value which is a string
	state has a value which is a string
	country has a value which is a string
	origcty has a value which is a string
	elevation has a value which is an int
	latitude has a value which is an int
	longitude has a value which is an int
	lo_accession has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Locality
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Locality:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Locality');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Locality

    $return = $self->_all_entities($ctx, 'Locality', $start, $count, $fields);

    #END all_entities_Locality
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Locality:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Locality');
    }
    return($return);
}




=head2 get_entity_LocalizedCompound

  $return = $obj->get_entity_LocalizedCompound($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_LocalizedCompound
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_LocalizedCompound
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

This entity represents a compound occurring in a
specific location. A reaction always involves localized
compounds. If a reaction occurs entirely in a single
location, it will frequently only be represented by the
cytoplasmic versions of the compounds; however, a transport
always uses specifically located compounds.

It has the following fields:

=over 4


=back

=back

=cut

sub get_entity_LocalizedCompound
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_LocalizedCompound:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_LocalizedCompound');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_LocalizedCompound

    $return = $self->_get_entity($ctx, 'LocalizedCompound', $ids, $fields);

    #END get_entity_LocalizedCompound
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_LocalizedCompound:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_LocalizedCompound');
    }
    return($return);
}




=head2 query_entity_LocalizedCompound

  $return = $obj->query_entity_LocalizedCompound($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_LocalizedCompound
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_LocalizedCompound
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_LocalizedCompound
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_LocalizedCompound:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_LocalizedCompound');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_LocalizedCompound

    $return = $self->_query_entity($ctx, 'LocalizedCompound', $qry, $fields);

    #END query_entity_LocalizedCompound
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_LocalizedCompound:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_LocalizedCompound');
    }
    return($return);
}




=head2 all_entities_LocalizedCompound

  $return = $obj->all_entities_LocalizedCompound($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_LocalizedCompound
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_LocalizedCompound
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_LocalizedCompound
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_LocalizedCompound:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_LocalizedCompound');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_LocalizedCompound

    $return = $self->_all_entities($ctx, 'LocalizedCompound', $start, $count, $fields);

    #END all_entities_LocalizedCompound
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_LocalizedCompound:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_LocalizedCompound');
    }
    return($return);
}




=head2 get_entity_Location

  $return = $obj->get_entity_Location($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Location
fields_Location is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Location
fields_Location is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is an int


=end text



=item Description

A location is a region of the cell where reaction compounds
originate from or are transported to (e.g. cell wall, extracellular,
cytoplasm).

It has the following fields:

=over 4

=item mod_date

date and time of the last modification to the compartment's definition

=item name

common name for the location

=item source_id

ID from the source of this location

=item abbr

an abbreviation (usually a single letter) for the location.


=back

=back

=cut

sub get_entity_Location
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Location:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Location');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Location

    $return = $self->_get_entity($ctx, 'Location', $ids, $fields);

    #END get_entity_Location
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Location:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Location');
    }
    return($return);
}




=head2 query_entity_Location

  $return = $obj->query_entity_Location($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Location
fields_Location is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is an int

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Location
fields_Location is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is an int


=end text



=item Description



=back

=cut

sub query_entity_Location
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Location:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Location');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Location

    $return = $self->_query_entity($ctx, 'Location', $qry, $fields);

    #END query_entity_Location
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Location:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Location');
    }
    return($return);
}




=head2 all_entities_Location

  $return = $obj->all_entities_Location($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Location
fields_Location is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is an int

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Location
fields_Location is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is an int


=end text



=item Description



=back

=cut

sub all_entities_Location
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Location:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Location');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Location

    $return = $self->_all_entities($ctx, 'Location', $start, $count, $fields);

    #END all_entities_Location
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Location:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Location');
    }
    return($return);
}




=head2 get_entity_LocationInstance

  $return = $obj->get_entity_LocationInstance($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_LocationInstance
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_LocationInstance
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float


=end text



=item Description

The Location Instance represents a region of a cell
(e.g. cell wall, cytoplasm) as it appears in a specific
model.

It has the following fields:

=over 4

=item index

number used to distinguish between different instances of the same type of location in a single model. Within a model, any two instances of the same location must have difference compartment index values.

=item label

description used to differentiate between instances of the same location in a single model

=item pH

pH of the cell region, which is used to determine compound charge and pH gradient across cell membranes

=item potential

electrochemical potential of the cell region, which is used to determine the electrochemical gradient across cell membranes


=back

=back

=cut

sub get_entity_LocationInstance
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_LocationInstance:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_LocationInstance');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_LocationInstance

    $return = $self->_get_entity($ctx, 'LocationInstance', $ids, $fields);

    #END get_entity_LocationInstance
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_LocationInstance:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_LocationInstance');
    }
    return($return);
}




=head2 query_entity_LocationInstance

  $return = $obj->query_entity_LocationInstance($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_LocationInstance
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_LocationInstance
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float


=end text



=item Description



=back

=cut

sub query_entity_LocationInstance
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_LocationInstance:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_LocationInstance');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_LocationInstance

    $return = $self->_query_entity($ctx, 'LocationInstance', $qry, $fields);

    #END query_entity_LocationInstance
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_LocationInstance:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_LocationInstance');
    }
    return($return);
}




=head2 all_entities_LocationInstance

  $return = $obj->all_entities_LocationInstance($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_LocationInstance
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_LocationInstance
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float


=end text



=item Description



=back

=cut

sub all_entities_LocationInstance
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_LocationInstance:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_LocationInstance');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_LocationInstance

    $return = $self->_all_entities($ctx, 'LocationInstance', $start, $count, $fields);

    #END all_entities_LocationInstance
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_LocationInstance:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_LocationInstance');
    }
    return($return);
}




=head2 get_entity_Measurement

  $return = $obj->get_entity_Measurement($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Measurement
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Measurement
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float


=end text



=item Description

A Measurement is a value generated by performing a protocol to
evaluate a value on an ExperimentalUnit - e.g. a strain in an
environment.

It has the following fields:

=over 4

=item source_id

The ID of the measurement used by the data source.

=item value

The value of the measurement.

=item mean

The mean of multiple replicates if they are included in the measurement.

=item median

The median of multiple replicates if they are included in the measurement.

=item stddev

The standard deviation of multiple replicates if they are included in the measurement.

=item N

The number of replicates if they are included in the measurement.

=item p_value

The p-value of multiple replicates if they are included in the measurement. The exact meaning of the p-value is specified in the MeasurementDescription object for this measurement.

=item Z_score

The Z-score of multiple replicates if they are included in the measurement. The exact meaning of the Z-score is specified in the MeasurementDescription object for this measurement.


=back

=back

=cut

sub get_entity_Measurement
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Measurement:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Measurement');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Measurement

    $return = $self->_get_entity($ctx, 'Measurement', $ids, $fields);

    #END get_entity_Measurement
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Measurement:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Measurement');
    }
    return($return);
}




=head2 query_entity_Measurement

  $return = $obj->query_entity_Measurement($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Measurement
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Measurement
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float


=end text



=item Description



=back

=cut

sub query_entity_Measurement
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Measurement:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Measurement');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Measurement

    $return = $self->_query_entity($ctx, 'Measurement', $qry, $fields);

    #END query_entity_Measurement
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Measurement:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Measurement');
    }
    return($return);
}




=head2 all_entities_Measurement

  $return = $obj->all_entities_Measurement($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Measurement
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Measurement
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float


=end text



=item Description



=back

=cut

sub all_entities_Measurement
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Measurement:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Measurement');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Measurement

    $return = $self->_all_entities($ctx, 'Measurement', $start, $count, $fields);

    #END all_entities_Measurement
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Measurement:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Measurement');
    }
    return($return);
}




=head2 get_entity_MeasurementDescription

  $return = $obj->get_entity_MeasurementDescription($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_MeasurementDescription
fields_MeasurementDescription is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	unitOfMeasure has a value which is a string
	category has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_MeasurementDescription
fields_MeasurementDescription is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	unitOfMeasure has a value which is a string
	category has a value which is a string
	source_id has a value which is a string


=end text



=item Description

A MeasurementDescription provides information about a
measurement value.

It has the following fields:

=over 4

=item name

The name of the measurement.

=item description

The description of the measurement, how it is measured, and what the measurement statistics mean.

=item unitOfMeasure

The units of the measurement.

=item category

The category the measurement fits into, for example phenotype, experimental input, environment.

=item source_id

The ID of the measurement description used by the data source.


=back

=back

=cut

sub get_entity_MeasurementDescription
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_MeasurementDescription:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_MeasurementDescription');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_MeasurementDescription

    $return = $self->_get_entity($ctx, 'MeasurementDescription', $ids, $fields);

    #END get_entity_MeasurementDescription
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_MeasurementDescription:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_MeasurementDescription');
    }
    return($return);
}




=head2 query_entity_MeasurementDescription

  $return = $obj->query_entity_MeasurementDescription($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_MeasurementDescription
fields_MeasurementDescription is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	unitOfMeasure has a value which is a string
	category has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_MeasurementDescription
fields_MeasurementDescription is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	unitOfMeasure has a value which is a string
	category has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_MeasurementDescription
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_MeasurementDescription:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_MeasurementDescription');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_MeasurementDescription

    $return = $self->_query_entity($ctx, 'MeasurementDescription', $qry, $fields);

    #END query_entity_MeasurementDescription
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_MeasurementDescription:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_MeasurementDescription');
    }
    return($return);
}




=head2 all_entities_MeasurementDescription

  $return = $obj->all_entities_MeasurementDescription($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_MeasurementDescription
fields_MeasurementDescription is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	unitOfMeasure has a value which is a string
	category has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_MeasurementDescription
fields_MeasurementDescription is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	unitOfMeasure has a value which is a string
	category has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_MeasurementDescription
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_MeasurementDescription:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_MeasurementDescription');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_MeasurementDescription

    $return = $self->_all_entities($ctx, 'MeasurementDescription', $start, $count, $fields);

    #END all_entities_MeasurementDescription
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_MeasurementDescription:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_MeasurementDescription');
    }
    return($return);
}




=head2 get_entity_Media

  $return = $obj->get_entity_Media($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Media
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Media
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string


=end text



=item Description

A media describes the chemical content of the solution in which cells
are grown in an experiment or for the purposes of a model. The key is the
common media name. The nature of the media is described by its relationship
to its constituent compounds.

It has the following fields:

=over 4

=item mod_date

date and time of the last modification to the media's definition

=item name

descriptive name of the media

=item is_minimal

TRUE if this is a minimal media, else FALSE

=item source_id

The ID of the media used by the data source.

=item type

The general category of the media.


=back

=back

=cut

sub get_entity_Media
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Media:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Media');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Media

    $return = $self->_get_entity($ctx, 'Media', $ids, $fields);

    #END get_entity_Media
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Media:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Media');
    }
    return($return);
}




=head2 query_entity_Media

  $return = $obj->query_entity_Media($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Media
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Media
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Media
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Media:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Media');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Media

    $return = $self->_query_entity($ctx, 'Media', $qry, $fields);

    #END query_entity_Media
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Media:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Media');
    }
    return($return);
}




=head2 all_entities_Media

  $return = $obj->all_entities_Media($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Media
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Media
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Media
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Media:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Media');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Media

    $return = $self->_all_entities($ctx, 'Media', $start, $count, $fields);

    #END all_entities_Media
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Media:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Media');
    }
    return($return);
}




=head2 get_entity_Model

  $return = $obj->get_entity_Model($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Model
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Model
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int


=end text



=item Description

A model specifies a relationship between sets of features and
reactions in a cell. It is used to simulate cell growth and gene
knockouts to validate annotations.

It has the following fields:

=over 4

=item mod_date

date and time of the last change to the model data

=item name

descriptive name of the model

=item version

revision number of the model

=item type

string indicating where the model came from (e.g. single genome, multiple genome, or community model)

=item status

indicator of whether the model is stable, under construction, or under reconstruction

=item reaction_count

number of reactions in the model

=item compound_count

number of compounds in the model

=item annotation_count

number of features associated with one or more reactions in the model


=back

=back

=cut

sub get_entity_Model
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Model:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Model');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Model

    $return = $self->_get_entity($ctx, 'Model', $ids, $fields);

    #END get_entity_Model
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Model:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Model');
    }
    return($return);
}




=head2 query_entity_Model

  $return = $obj->query_entity_Model($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Model
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Model
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int


=end text



=item Description



=back

=cut

sub query_entity_Model
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Model:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Model');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Model

    $return = $self->_query_entity($ctx, 'Model', $qry, $fields);

    #END query_entity_Model
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Model:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Model');
    }
    return($return);
}




=head2 all_entities_Model

  $return = $obj->all_entities_Model($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Model
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Model
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int


=end text



=item Description



=back

=cut

sub all_entities_Model
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Model:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Model');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Model

    $return = $self->_all_entities($ctx, 'Model', $start, $count, $fields);

    #END all_entities_Model
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Model:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Model');
    }
    return($return);
}




=head2 get_entity_OTU

  $return = $obj->get_entity_OTU($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_OTU
fields_OTU is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_OTU
fields_OTU is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

An OTU (Organism Taxonomic Unit) is a named group of related
genomes.

It has the following fields:

=over 4


=back

=back

=cut

sub get_entity_OTU
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_OTU:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_OTU');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_OTU

    $return = $self->_get_entity($ctx, 'OTU', $ids, $fields);

    #END get_entity_OTU
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_OTU:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_OTU');
    }
    return($return);
}




=head2 query_entity_OTU

  $return = $obj->query_entity_OTU($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_OTU
fields_OTU is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_OTU
fields_OTU is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_OTU
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_OTU:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_OTU');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_OTU

    $return = $self->_query_entity($ctx, 'OTU', $qry, $fields);

    #END query_entity_OTU
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_OTU:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_OTU');
    }
    return($return);
}




=head2 all_entities_OTU

  $return = $obj->all_entities_OTU($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_OTU
fields_OTU is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_OTU
fields_OTU is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_OTU
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_OTU:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_OTU');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_OTU

    $return = $self->_all_entities($ctx, 'OTU', $start, $count, $fields);

    #END all_entities_OTU
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_OTU:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_OTU');
    }
    return($return);
}




=head2 get_entity_ObservationalUnit

  $return = $obj->get_entity_ObservationalUnit($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ObservationalUnit
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ObservationalUnit
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string


=end text



=item Description

An ObservationalUnit is an individual plant that 1) is part of an experiment or study, 2) has measured traits, and 3) is assayed for the purpose of determining alleles.  

It has the following fields:

=over 4

=item source_name

Name/ID by which the observational unit may be known by the originator and is used in queries.

=item source_name2

Secondary name/ID by which the observational unit may be known and is queried.

=item plant_id

ID of the plant that was tested to produce this observational unit. Observational units with the same plant ID are different assays of a single physical organism.


=back

=back

=cut

sub get_entity_ObservationalUnit
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_ObservationalUnit:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ObservationalUnit');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_ObservationalUnit

    $return = $self->_get_entity($ctx, 'ObservationalUnit', $ids, $fields);

    #END get_entity_ObservationalUnit
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_ObservationalUnit:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ObservationalUnit');
    }
    return($return);
}




=head2 query_entity_ObservationalUnit

  $return = $obj->query_entity_ObservationalUnit($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ObservationalUnit
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ObservationalUnit
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_ObservationalUnit
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_ObservationalUnit:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ObservationalUnit');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_ObservationalUnit

    $return = $self->_query_entity($ctx, 'ObservationalUnit', $qry, $fields);

    #END query_entity_ObservationalUnit
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_ObservationalUnit:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ObservationalUnit');
    }
    return($return);
}




=head2 all_entities_ObservationalUnit

  $return = $obj->all_entities_ObservationalUnit($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ObservationalUnit
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ObservationalUnit
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_ObservationalUnit
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_ObservationalUnit:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ObservationalUnit');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_ObservationalUnit

    $return = $self->_all_entities($ctx, 'ObservationalUnit', $start, $count, $fields);

    #END all_entities_ObservationalUnit
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_ObservationalUnit:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ObservationalUnit');
    }
    return($return);
}




=head2 get_entity_Ontology

  $return = $obj->get_entity_Ontology($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Ontology
fields_Ontology is a reference to a hash where the following keys are defined:
	id has a value which is a string
	id has a value which is a string
	name has a value which is a string
	definition has a value which is a string
	ontologySource has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Ontology
fields_Ontology is a reference to a hash where the following keys are defined:
	id has a value which is a string
	id has a value which is a string
	name has a value which is a string
	definition has a value which is a string
	ontologySource has a value which is a string


=end text



=item Description

-- Environmental Ontology. (ENVO Terms) http://environmentontology.org/  
-- Plant Ontology (PO Terms). http://www.plantontology.org/   
-- Plant Environmental Ontology (EO Terms). http://www.gramene.org/plant_ontology/index.html#eo
-- ENVO : http://envo.googlecode.com/svn/trunk/src/envo/envo-basic.obo
-- PO : http://palea.cgrb.oregonstate.edu/viewsvn/Poc/tags/live/plant_ontology.obo?view=co
-- EO : http://obo.cvs.sourceforge.net/viewvc/obo/obo/ontology/phenotype/environment/environment_ontology.obo


It has the following fields:

=over 4

=item id

Ontologgy ID.

=item name

Type of the ontology.

=item definition

Definition of the ontology

=item ontologySource

Enumerated value (ENVO, EO, PO).


=back

=back

=cut

sub get_entity_Ontology
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Ontology:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Ontology');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Ontology

    $return = $self->_get_entity($ctx, 'Ontology', $ids, $fields);

    #END get_entity_Ontology
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Ontology:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Ontology');
    }
    return($return);
}




=head2 query_entity_Ontology

  $return = $obj->query_entity_Ontology($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Ontology
fields_Ontology is a reference to a hash where the following keys are defined:
	id has a value which is a string
	id has a value which is a string
	name has a value which is a string
	definition has a value which is a string
	ontologySource has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Ontology
fields_Ontology is a reference to a hash where the following keys are defined:
	id has a value which is a string
	id has a value which is a string
	name has a value which is a string
	definition has a value which is a string
	ontologySource has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Ontology
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Ontology:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Ontology');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Ontology

    $return = $self->_query_entity($ctx, 'Ontology', $qry, $fields);

    #END query_entity_Ontology
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Ontology:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Ontology');
    }
    return($return);
}




=head2 all_entities_Ontology

  $return = $obj->all_entities_Ontology($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Ontology
fields_Ontology is a reference to a hash where the following keys are defined:
	id has a value which is a string
	id has a value which is a string
	name has a value which is a string
	definition has a value which is a string
	ontologySource has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Ontology
fields_Ontology is a reference to a hash where the following keys are defined:
	id has a value which is a string
	id has a value which is a string
	name has a value which is a string
	definition has a value which is a string
	ontologySource has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Ontology
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Ontology:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Ontology');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Ontology

    $return = $self->_all_entities($ctx, 'Ontology', $start, $count, $fields);

    #END all_entities_Ontology
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Ontology:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Ontology');
    }
    return($return);
}




=head2 get_entity_Operon

  $return = $obj->get_entity_Operon($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Operon
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Operon
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

It has the following fields:

=over 4


=back

=back

=cut

sub get_entity_Operon
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Operon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Operon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Operon

    $return = $self->_get_entity($ctx, 'Operon', $ids, $fields);

    #END get_entity_Operon
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Operon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Operon');
    }
    return($return);
}




=head2 query_entity_Operon

  $return = $obj->query_entity_Operon($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Operon
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Operon
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Operon
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Operon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Operon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Operon

    $return = $self->_query_entity($ctx, 'Operon', $qry, $fields);

    #END query_entity_Operon
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Operon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Operon');
    }
    return($return);
}




=head2 all_entities_Operon

  $return = $obj->all_entities_Operon($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Operon
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Operon
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Operon
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Operon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Operon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Operon

    $return = $self->_all_entities($ctx, 'Operon', $start, $count, $fields);

    #END all_entities_Operon
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Operon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Operon');
    }
    return($return);
}




=head2 get_entity_PairSet

  $return = $obj->get_entity_PairSet($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_PairSet
fields_PairSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	score has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_PairSet
fields_PairSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	score has a value which is an int


=end text



=item Description

A PairSet is a precompute set of pairs or genes.  Each
pair occurs close to one another of the chromosome.  We believe
that all of the first members of the pairs correspond to one another
(are quite similar), as do all of the second members of the pairs.
These pairs (from prokaryotic genomes) offer one of the most
powerful clues relating to uncharacterized genes/peroteins.

It has the following fields:

=over 4

=item score

Score for this evidence set. The score indicates the number of significantly different genomes represented by the pairings.


=back

=back

=cut

sub get_entity_PairSet
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_PairSet:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_PairSet');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_PairSet

    $return = $self->_get_entity($ctx, 'PairSet', $ids, $fields);

    #END get_entity_PairSet
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_PairSet:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_PairSet');
    }
    return($return);
}




=head2 query_entity_PairSet

  $return = $obj->query_entity_PairSet($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_PairSet
fields_PairSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	score has a value which is an int

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_PairSet
fields_PairSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	score has a value which is an int


=end text



=item Description



=back

=cut

sub query_entity_PairSet
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_PairSet:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_PairSet');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_PairSet

    $return = $self->_query_entity($ctx, 'PairSet', $qry, $fields);

    #END query_entity_PairSet
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_PairSet:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_PairSet');
    }
    return($return);
}




=head2 all_entities_PairSet

  $return = $obj->all_entities_PairSet($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_PairSet
fields_PairSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	score has a value which is an int

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_PairSet
fields_PairSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	score has a value which is an int


=end text



=item Description



=back

=cut

sub all_entities_PairSet
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_PairSet:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_PairSet');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_PairSet

    $return = $self->_all_entities($ctx, 'PairSet', $start, $count, $fields);

    #END all_entities_PairSet
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_PairSet:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_PairSet');
    }
    return($return);
}




=head2 get_entity_Pairing

  $return = $obj->get_entity_Pairing($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Pairing
fields_Pairing is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Pairing
fields_Pairing is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

A pairing indicates that two features are found
close together in a genome. Not all possible pairings are stored in
the database; only those that are considered for some reason to be
significant for annotation purposes.The key of the pairing is the
concatenation of the feature IDs in alphabetical order with an
intervening colon.

It has the following fields:

=over 4


=back

=back

=cut

sub get_entity_Pairing
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Pairing:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Pairing');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Pairing

    $return = $self->_get_entity($ctx, 'Pairing', $ids, $fields);

    #END get_entity_Pairing
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Pairing:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Pairing');
    }
    return($return);
}




=head2 query_entity_Pairing

  $return = $obj->query_entity_Pairing($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Pairing
fields_Pairing is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Pairing
fields_Pairing is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Pairing
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Pairing:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Pairing');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Pairing

    $return = $self->_query_entity($ctx, 'Pairing', $qry, $fields);

    #END query_entity_Pairing
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Pairing:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Pairing');
    }
    return($return);
}




=head2 all_entities_Pairing

  $return = $obj->all_entities_Pairing($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Pairing
fields_Pairing is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Pairing
fields_Pairing is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Pairing
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Pairing:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Pairing');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Pairing

    $return = $self->_all_entities($ctx, 'Pairing', $start, $count, $fields);

    #END all_entities_Pairing
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Pairing:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Pairing');
    }
    return($return);
}




=head2 get_entity_Parameter

  $return = $obj->get_entity_Parameter($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Parameter
fields_Parameter is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Parameter
fields_Parameter is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

A parameter is the name of some quantity that has a value.


It has the following fields:

=over 4


=back

=back

=cut

sub get_entity_Parameter
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Parameter:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Parameter');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Parameter

    $return = $self->_get_entity($ctx, 'Parameter', $ids, $fields);

    #END get_entity_Parameter
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Parameter:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Parameter');
    }
    return($return);
}




=head2 query_entity_Parameter

  $return = $obj->query_entity_Parameter($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Parameter
fields_Parameter is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Parameter
fields_Parameter is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Parameter
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Parameter:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Parameter');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Parameter

    $return = $self->_query_entity($ctx, 'Parameter', $qry, $fields);

    #END query_entity_Parameter
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Parameter:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Parameter');
    }
    return($return);
}




=head2 all_entities_Parameter

  $return = $obj->all_entities_Parameter($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Parameter
fields_Parameter is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Parameter
fields_Parameter is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Parameter
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Parameter:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Parameter');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Parameter

    $return = $self->_all_entities($ctx, 'Parameter', $start, $count, $fields);

    #END all_entities_Parameter
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Parameter:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Parameter');
    }
    return($return);
}




=head2 get_entity_Person

  $return = $obj->get_entity_Person($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Person
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Person
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string


=end text



=item Description

A person represents a human affiliated in some way with Kbase.

It has the following fields:

=over 4

=item firstName

The given name of the person.

=item lastName

The surname of the person.

=item contactEmail

Email address of the person.

=item institution

The institution where the person works.

=item source_id

The ID of the person used by the data source.


=back

=back

=cut

sub get_entity_Person
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Person:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Person');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Person

    $return = $self->_get_entity($ctx, 'Person', $ids, $fields);

    #END get_entity_Person
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Person:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Person');
    }
    return($return);
}




=head2 query_entity_Person

  $return = $obj->query_entity_Person($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Person
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Person
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Person
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Person:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Person');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Person

    $return = $self->_query_entity($ctx, 'Person', $qry, $fields);

    #END query_entity_Person
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Person:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Person');
    }
    return($return);
}




=head2 all_entities_Person

  $return = $obj->all_entities_Person($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Person
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Person
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Person
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Person:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Person');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Person

    $return = $self->_all_entities($ctx, 'Person', $start, $count, $fields);

    #END all_entities_Person
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Person:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Person');
    }
    return($return);
}




=head2 get_entity_Platform

  $return = $obj->get_entity_Platform($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Platform
fields_Platform is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	externalSourceId has a value which is a string
	technology has a value which is a string
	type has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Platform
fields_Platform is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	externalSourceId has a value which is a string
	technology has a value which is a string
	type has a value which is a string
	source_id has a value which is a string


=end text



=item Description

Platform that the expression sample/experiment was run on.

It has the following fields:

=over 4

=item title

free text title of the comparison

=item externalSourceId

The externalSourceId gives users potentially an easy way to find the data of interest (ex:GPL514). This will keep them from having to do problematic likes on the source-id field.

=item technology

Ideally enumerated values, but may have to make this free text (spotted DNA/cDNA, spotted oligonucleotide, in situ oligonucleotide, antibody, tissue, SARST, RT-PCR, or MPSS).

=item type

Enumerated Microarray, RNA-Seq, qPCR

=item source_id

The ID used as the data source.


=back

=back

=cut

sub get_entity_Platform
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Platform:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Platform');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Platform

    $return = $self->_get_entity($ctx, 'Platform', $ids, $fields);

    #END get_entity_Platform
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Platform:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Platform');
    }
    return($return);
}




=head2 query_entity_Platform

  $return = $obj->query_entity_Platform($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Platform
fields_Platform is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	externalSourceId has a value which is a string
	technology has a value which is a string
	type has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Platform
fields_Platform is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	externalSourceId has a value which is a string
	technology has a value which is a string
	type has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Platform
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Platform:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Platform');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Platform

    $return = $self->_query_entity($ctx, 'Platform', $qry, $fields);

    #END query_entity_Platform
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Platform:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Platform');
    }
    return($return);
}




=head2 all_entities_Platform

  $return = $obj->all_entities_Platform($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Platform
fields_Platform is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	externalSourceId has a value which is a string
	technology has a value which is a string
	type has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Platform
fields_Platform is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	externalSourceId has a value which is a string
	technology has a value which is a string
	type has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Platform
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Platform:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Platform');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Platform

    $return = $self->_all_entities($ctx, 'Platform', $start, $count, $fields);

    #END all_entities_Platform
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Platform:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Platform');
    }
    return($return);
}




=head2 get_entity_ProbeSet

  $return = $obj->get_entity_ProbeSet($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ProbeSet
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ProbeSet
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

A probe set is a device containing multiple probe sequences for use
in gene expression experiments.

It has the following fields:

=over 4


=back

=back

=cut

sub get_entity_ProbeSet
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_ProbeSet:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ProbeSet');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_ProbeSet

    $return = $self->_get_entity($ctx, 'ProbeSet', $ids, $fields);

    #END get_entity_ProbeSet
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_ProbeSet:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ProbeSet');
    }
    return($return);
}




=head2 query_entity_ProbeSet

  $return = $obj->query_entity_ProbeSet($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ProbeSet
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ProbeSet
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_ProbeSet
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_ProbeSet:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ProbeSet');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_ProbeSet

    $return = $self->_query_entity($ctx, 'ProbeSet', $qry, $fields);

    #END query_entity_ProbeSet
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_ProbeSet:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ProbeSet');
    }
    return($return);
}




=head2 all_entities_ProbeSet

  $return = $obj->all_entities_ProbeSet($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ProbeSet
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ProbeSet
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_ProbeSet
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_ProbeSet:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ProbeSet');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_ProbeSet

    $return = $self->_all_entities($ctx, 'ProbeSet', $start, $count, $fields);

    #END all_entities_ProbeSet
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_ProbeSet:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ProbeSet');
    }
    return($return);
}




=head2 get_entity_ProteinSequence

  $return = $obj->get_entity_ProteinSequence($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ProteinSequence
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ProteinSequence
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string


=end text



=item Description

We use the concept of ProteinSequence as an amino acid
string with an associated MD5 value.  It is easy to access the
set of Features that relate to a ProteinSequence.  While function
is still associated with Features (and may be for some time),
publications are associated with ProteinSequences (and the inferred
impact on Features is through the relationship connecting
ProteinSequences to Features).

It has the following fields:

=over 4

=item sequence

The sequence contains the letters corresponding to the protein's amino acids.


=back

=back

=cut

sub get_entity_ProteinSequence
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_ProteinSequence:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ProteinSequence');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_ProteinSequence

    $return = $self->_get_entity($ctx, 'ProteinSequence', $ids, $fields);

    #END get_entity_ProteinSequence
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_ProteinSequence:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ProteinSequence');
    }
    return($return);
}




=head2 query_entity_ProteinSequence

  $return = $obj->query_entity_ProteinSequence($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ProteinSequence
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ProteinSequence
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_ProteinSequence
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_ProteinSequence:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ProteinSequence');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_ProteinSequence

    $return = $self->_query_entity($ctx, 'ProteinSequence', $qry, $fields);

    #END query_entity_ProteinSequence
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_ProteinSequence:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ProteinSequence');
    }
    return($return);
}




=head2 all_entities_ProteinSequence

  $return = $obj->all_entities_ProteinSequence($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ProteinSequence
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ProteinSequence
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_ProteinSequence
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_ProteinSequence:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ProteinSequence');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_ProteinSequence

    $return = $self->_all_entities($ctx, 'ProteinSequence', $start, $count, $fields);

    #END all_entities_ProteinSequence
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_ProteinSequence:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ProteinSequence');
    }
    return($return);
}




=head2 get_entity_Protocol

  $return = $obj->get_entity_Protocol($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Protocol
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Protocol
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string


=end text



=item Description

A Protocol is a step by step set of instructions for
performing a part of an experiment.

It has the following fields:

=over 4

=item name

The name of the protocol.

=item description

The step by step instructions for performing the experiment, including measurement details, materials, and equipment. A researcher should be able to reproduce the experimental results with this information.

=item source_id

The ID of the protocol used by the data source.


=back

=back

=cut

sub get_entity_Protocol
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Protocol:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Protocol');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Protocol

    $return = $self->_get_entity($ctx, 'Protocol', $ids, $fields);

    #END get_entity_Protocol
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Protocol:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Protocol');
    }
    return($return);
}




=head2 query_entity_Protocol

  $return = $obj->query_entity_Protocol($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Protocol
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Protocol
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Protocol
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Protocol:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Protocol');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Protocol

    $return = $self->_query_entity($ctx, 'Protocol', $qry, $fields);

    #END query_entity_Protocol
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Protocol:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Protocol');
    }
    return($return);
}




=head2 all_entities_Protocol

  $return = $obj->all_entities_Protocol($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Protocol
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Protocol
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Protocol
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Protocol:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Protocol');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Protocol

    $return = $self->_all_entities($ctx, 'Protocol', $start, $count, $fields);

    #END all_entities_Protocol
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Protocol:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Protocol');
    }
    return($return);
}




=head2 get_entity_Publication

  $return = $obj->get_entity_Publication($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Publication
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Publication
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string


=end text



=item Description

Experimenters attach publications to experiments and
protocols. Annotators attach publications to ProteinSequences.
The attached publications give an ID (usually a
DOI or Pubmed ID),  a URL to the paper (when we have it), and a title
(when we have it). Pubmed IDs are given unmodified. DOI IDs
are prefixed with [b]doi:[/b], e.g. [i]doi:1002385[/i].

It has the following fields:

=over 4

=item title

title of the article, or (unknown) if the title is not known

=item link

URL of the article, DOI preferred

=item pubdate

publication date of the article


=back

=back

=cut

sub get_entity_Publication
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Publication:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Publication');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Publication

    $return = $self->_get_entity($ctx, 'Publication', $ids, $fields);

    #END get_entity_Publication
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Publication:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Publication');
    }
    return($return);
}




=head2 query_entity_Publication

  $return = $obj->query_entity_Publication($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Publication
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Publication
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Publication
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Publication:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Publication');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Publication

    $return = $self->_query_entity($ctx, 'Publication', $qry, $fields);

    #END query_entity_Publication
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Publication:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Publication');
    }
    return($return);
}




=head2 all_entities_Publication

  $return = $obj->all_entities_Publication($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Publication
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Publication
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Publication
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Publication:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Publication');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Publication

    $return = $self->_all_entities($ctx, 'Publication', $start, $count, $fields);

    #END all_entities_Publication
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Publication:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Publication');
    }
    return($return);
}




=head2 get_entity_Reaction

  $return = $obj->get_entity_Reaction($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Reaction
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Reaction
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string


=end text



=item Description

A reaction is a chemical process that converts one set of
compounds (substrate) to another set (products).

It has the following fields:

=over 4

=item mod_date

date and time of the last modification to this reaction's definition

=item name

descriptive name of this reaction

=item source_id

ID of this reaction in the resource from which it was added

=item abbr

abbreviated name of this reaction

=item direction

direction of this reaction (> for forward-only, < for backward-only, = for bidirectional)

=item deltaG

Gibbs free-energy change for the reaction calculated using the group contribution method (units are kcal/mol)

=item deltaG_error

uncertainty in the [b]deltaG[/b] value (units are kcal/mol)

=item thermodynamic_reversibility

computed reversibility of this reaction in a pH-neutral environment

=item default_protons

number of protons absorbed by this reaction in a pH-neutral environment

=item status

string indicating additional information about this reaction, generally indicating whether the reaction is balanced and/or lumped


=back

=back

=cut

sub get_entity_Reaction
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Reaction:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Reaction');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Reaction

    $return = $self->_get_entity($ctx, 'Reaction', $ids, $fields);

    #END get_entity_Reaction
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Reaction:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Reaction');
    }
    return($return);
}




=head2 query_entity_Reaction

  $return = $obj->query_entity_Reaction($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Reaction
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Reaction
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Reaction
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Reaction:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Reaction');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Reaction

    $return = $self->_query_entity($ctx, 'Reaction', $qry, $fields);

    #END query_entity_Reaction
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Reaction:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Reaction');
    }
    return($return);
}




=head2 all_entities_Reaction

  $return = $obj->all_entities_Reaction($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Reaction
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Reaction
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Reaction
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Reaction:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Reaction');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Reaction

    $return = $self->_all_entities($ctx, 'Reaction', $start, $count, $fields);

    #END all_entities_Reaction
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Reaction:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Reaction');
    }
    return($return);
}




=head2 get_entity_ReactionInstance

  $return = $obj->get_entity_ReactionInstance($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ReactionInstance
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ReactionInstance
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float


=end text



=item Description

A reaction instance describes the specific implementation of
a reaction in a model.

It has the following fields:

=over 4

=item direction

reaction directionality (> for forward, < for backward, = for bidirectional) with respect to this model

=item protons

number of protons produced by this reaction when proceeding in the forward direction. If this is a transport reaction, these protons end up in the reaction instance's main location. If the number is negative, then the protons are consumed by the reaction rather than being produced.


=back

=back

=cut

sub get_entity_ReactionInstance
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_ReactionInstance:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ReactionInstance');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_ReactionInstance

    $return = $self->_get_entity($ctx, 'ReactionInstance', $ids, $fields);

    #END get_entity_ReactionInstance
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_ReactionInstance:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ReactionInstance');
    }
    return($return);
}




=head2 query_entity_ReactionInstance

  $return = $obj->query_entity_ReactionInstance($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ReactionInstance
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ReactionInstance
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float


=end text



=item Description



=back

=cut

sub query_entity_ReactionInstance
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_ReactionInstance:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ReactionInstance');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_ReactionInstance

    $return = $self->_query_entity($ctx, 'ReactionInstance', $qry, $fields);

    #END query_entity_ReactionInstance
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_ReactionInstance:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ReactionInstance');
    }
    return($return);
}




=head2 all_entities_ReactionInstance

  $return = $obj->all_entities_ReactionInstance($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ReactionInstance
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ReactionInstance
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float


=end text



=item Description



=back

=cut

sub all_entities_ReactionInstance
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_ReactionInstance:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ReactionInstance');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_ReactionInstance

    $return = $self->_all_entities($ctx, 'ReactionInstance', $start, $count, $fields);

    #END all_entities_ReactionInstance
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_ReactionInstance:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ReactionInstance');
    }
    return($return);
}




=head2 get_entity_Regulator

  $return = $obj->get_entity_Regulator($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulator
fields_Regulator is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	rfam_id has a value which is a string
	tf_family has a value which is a string
	type has a value which is a string
	taxonomy has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulator
fields_Regulator is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	rfam_id has a value which is a string
	tf_family has a value which is a string
	type has a value which is a string
	taxonomy has a value which is a string


=end text



=item Description

It has the following fields:

=over 4

=item name

A human-readable name for this Regulator. 

=item rfam_id

If this regulator is an RNA regulator, the rfam-id field will contain the RFAM identifier corresponding to it. 

=item tf_family

If this regulator is a transcription factor, then the tf-family field will contain the name of the transcription factor family. 

=item type

Type of the regulator; currently either RNA or TF. 

=item taxonomy

Type of the regulator; currently either RNA or TF. 


=back

=back

=cut

sub get_entity_Regulator
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Regulator:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Regulator');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Regulator

    $return = $self->_get_entity($ctx, 'Regulator', $ids, $fields);

    #END get_entity_Regulator
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Regulator:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Regulator');
    }
    return($return);
}




=head2 query_entity_Regulator

  $return = $obj->query_entity_Regulator($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulator
fields_Regulator is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	rfam_id has a value which is a string
	tf_family has a value which is a string
	type has a value which is a string
	taxonomy has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulator
fields_Regulator is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	rfam_id has a value which is a string
	tf_family has a value which is a string
	type has a value which is a string
	taxonomy has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Regulator
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Regulator:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Regulator');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Regulator

    $return = $self->_query_entity($ctx, 'Regulator', $qry, $fields);

    #END query_entity_Regulator
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Regulator:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Regulator');
    }
    return($return);
}




=head2 all_entities_Regulator

  $return = $obj->all_entities_Regulator($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulator
fields_Regulator is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	rfam_id has a value which is a string
	tf_family has a value which is a string
	type has a value which is a string
	taxonomy has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulator
fields_Regulator is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	rfam_id has a value which is a string
	tf_family has a value which is a string
	type has a value which is a string
	taxonomy has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Regulator
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Regulator:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Regulator');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Regulator

    $return = $self->_all_entities($ctx, 'Regulator', $start, $count, $fields);

    #END all_entities_Regulator
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Regulator:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Regulator');
    }
    return($return);
}




=head2 get_entity_Regulog

  $return = $obj->get_entity_Regulog($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulog
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulog
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description

It has the following fields:

=over 4

=item description




=back

=back

=cut

sub get_entity_Regulog
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Regulog:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Regulog');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Regulog

    $return = $self->_get_entity($ctx, 'Regulog', $ids, $fields);

    #END get_entity_Regulog
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Regulog:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Regulog');
    }
    return($return);
}




=head2 query_entity_Regulog

  $return = $obj->query_entity_Regulog($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulog
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulog
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Regulog
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Regulog:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Regulog');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Regulog

    $return = $self->_query_entity($ctx, 'Regulog', $qry, $fields);

    #END query_entity_Regulog
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Regulog:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Regulog');
    }
    return($return);
}




=head2 all_entities_Regulog

  $return = $obj->all_entities_Regulog($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulog
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulog
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Regulog
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Regulog:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Regulog');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Regulog

    $return = $self->_all_entities($ctx, 'Regulog', $start, $count, $fields);

    #END all_entities_Regulog
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Regulog:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Regulog');
    }
    return($return);
}




=head2 get_entity_RegulogCollection

  $return = $obj->get_entity_RegulogCollection($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_RegulogCollection
fields_RegulogCollection is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_RegulogCollection
fields_RegulogCollection is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string


=end text



=item Description

A RegulogCollection describes a set of regulogs that are being
curated on well-defined set of genomes.


It has the following fields:

=over 4

=item name

The name of this regulog collection. 

=item description

A brief description of this regulog collection. 


=back

=back

=cut

sub get_entity_RegulogCollection
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_RegulogCollection:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_RegulogCollection');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_RegulogCollection

    $return = $self->_get_entity($ctx, 'RegulogCollection', $ids, $fields);

    #END get_entity_RegulogCollection
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_RegulogCollection:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_RegulogCollection');
    }
    return($return);
}




=head2 query_entity_RegulogCollection

  $return = $obj->query_entity_RegulogCollection($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_RegulogCollection
fields_RegulogCollection is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_RegulogCollection
fields_RegulogCollection is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_RegulogCollection
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_RegulogCollection:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_RegulogCollection');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_RegulogCollection

    $return = $self->_query_entity($ctx, 'RegulogCollection', $qry, $fields);

    #END query_entity_RegulogCollection
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_RegulogCollection:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_RegulogCollection');
    }
    return($return);
}




=head2 all_entities_RegulogCollection

  $return = $obj->all_entities_RegulogCollection($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_RegulogCollection
fields_RegulogCollection is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_RegulogCollection
fields_RegulogCollection is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_RegulogCollection
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_RegulogCollection:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_RegulogCollection');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_RegulogCollection

    $return = $self->_all_entities($ctx, 'RegulogCollection', $start, $count, $fields);

    #END all_entities_RegulogCollection
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_RegulogCollection:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_RegulogCollection');
    }
    return($return);
}




=head2 get_entity_Regulome

  $return = $obj->get_entity_Regulome($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulome
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulome
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string


=end text



=item Description

It has the following fields:

=over 4

=item description

A short description for this regulome. 

=item creation_date

Creation date for this regulome.


=back

=back

=cut

sub get_entity_Regulome
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Regulome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Regulome');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Regulome

    $return = $self->_get_entity($ctx, 'Regulome', $ids, $fields);

    #END get_entity_Regulome
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Regulome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Regulome');
    }
    return($return);
}




=head2 query_entity_Regulome

  $return = $obj->query_entity_Regulome($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulome
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulome
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Regulome
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Regulome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Regulome');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Regulome

    $return = $self->_query_entity($ctx, 'Regulome', $qry, $fields);

    #END query_entity_Regulome
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Regulome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Regulome');
    }
    return($return);
}




=head2 all_entities_Regulome

  $return = $obj->all_entities_Regulome($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulome
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulome
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Regulome
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Regulome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Regulome');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Regulome

    $return = $self->_all_entities($ctx, 'Regulome', $start, $count, $fields);

    #END all_entities_Regulome
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Regulome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Regulome');
    }
    return($return);
}




=head2 get_entity_Regulon

  $return = $obj->get_entity_Regulon($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulon
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulon
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description

It has the following fields:

=over 4

=item description

A short description for this regulon. 


=back

=back

=cut

sub get_entity_Regulon
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Regulon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Regulon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Regulon

    $return = $self->_get_entity($ctx, 'Regulon', $ids, $fields);

    #END get_entity_Regulon
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Regulon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Regulon');
    }
    return($return);
}




=head2 query_entity_Regulon

  $return = $obj->query_entity_Regulon($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulon
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulon
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Regulon
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Regulon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Regulon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Regulon

    $return = $self->_query_entity($ctx, 'Regulon', $qry, $fields);

    #END query_entity_Regulon
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Regulon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Regulon');
    }
    return($return);
}




=head2 all_entities_Regulon

  $return = $obj->all_entities_Regulon($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulon
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Regulon
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Regulon
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Regulon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Regulon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Regulon

    $return = $self->_all_entities($ctx, 'Regulon', $start, $count, $fields);

    #END all_entities_Regulon
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Regulon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Regulon');
    }
    return($return);
}




=head2 get_entity_ReplicateGroup

  $return = $obj->get_entity_ReplicateGroup($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ReplicateGroup
fields_ReplicateGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ReplicateGroup
fields_ReplicateGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

Keeps track of Replicate Groups of Expression Samples.  Has only an ID.  Relationship is the important part.


It has the following fields:

=over 4


=back

=back

=cut

sub get_entity_ReplicateGroup
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_ReplicateGroup:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ReplicateGroup');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_ReplicateGroup

    $return = $self->_get_entity($ctx, 'ReplicateGroup', $ids, $fields);

    #END get_entity_ReplicateGroup
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_ReplicateGroup:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_ReplicateGroup');
    }
    return($return);
}




=head2 query_entity_ReplicateGroup

  $return = $obj->query_entity_ReplicateGroup($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ReplicateGroup
fields_ReplicateGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ReplicateGroup
fields_ReplicateGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_ReplicateGroup
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_ReplicateGroup:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ReplicateGroup');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_ReplicateGroup

    $return = $self->_query_entity($ctx, 'ReplicateGroup', $qry, $fields);

    #END query_entity_ReplicateGroup
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_ReplicateGroup:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_ReplicateGroup');
    }
    return($return);
}




=head2 all_entities_ReplicateGroup

  $return = $obj->all_entities_ReplicateGroup($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ReplicateGroup
fields_ReplicateGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_ReplicateGroup
fields_ReplicateGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_ReplicateGroup
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_ReplicateGroup:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ReplicateGroup');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_ReplicateGroup

    $return = $self->_all_entities($ctx, 'ReplicateGroup', $start, $count, $fields);

    #END all_entities_ReplicateGroup
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_ReplicateGroup:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_ReplicateGroup');
    }
    return($return);
}




=head2 get_entity_Role

  $return = $obj->get_entity_Role($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Role
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Role
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int


=end text



=item Description

A role describes a biological function that may be fulfilled
by a feature. One of the main goals of the database is to assign
features to roles. Most roles are effected by the construction of
proteins. Some, however, deal with functional regulation and message
transmission.

It has the following fields:

=over 4

=item hypothetical

TRUE if a role is hypothetical, else FALSE


=back

=back

=cut

sub get_entity_Role
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Role:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Role');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Role

    $return = $self->_get_entity($ctx, 'Role', $ids, $fields);

    #END get_entity_Role
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Role:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Role');
    }
    return($return);
}




=head2 query_entity_Role

  $return = $obj->query_entity_Role($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Role
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Role
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int


=end text



=item Description



=back

=cut

sub query_entity_Role
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Role:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Role');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Role

    $return = $self->_query_entity($ctx, 'Role', $qry, $fields);

    #END query_entity_Role
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Role:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Role');
    }
    return($return);
}




=head2 all_entities_Role

  $return = $obj->all_entities_Role($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Role
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Role
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int


=end text



=item Description



=back

=cut

sub all_entities_Role
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Role:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Role');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Role

    $return = $self->_all_entities($ctx, 'Role', $start, $count, $fields);

    #END all_entities_Role
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Role:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Role');
    }
    return($return);
}




=head2 get_entity_SSCell

  $return = $obj->get_entity_SSCell($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SSCell
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SSCell
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

An SSCell (SpreadSheet Cell) represents a role as it occurs
in a subsystem spreadsheet row. The key is a colon-delimited triple
containing an MD5 hash of the subsystem ID followed by a genome ID
(with optional region string) and a role abbreviation.

It has the following fields:

=over 4


=back

=back

=cut

sub get_entity_SSCell
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_SSCell:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_SSCell');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_SSCell

    $return = $self->_get_entity($ctx, 'SSCell', $ids, $fields);

    #END get_entity_SSCell
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_SSCell:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_SSCell');
    }
    return($return);
}




=head2 query_entity_SSCell

  $return = $obj->query_entity_SSCell($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SSCell
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SSCell
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_SSCell
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_SSCell:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_SSCell');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_SSCell

    $return = $self->_query_entity($ctx, 'SSCell', $qry, $fields);

    #END query_entity_SSCell
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_SSCell:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_SSCell');
    }
    return($return);
}




=head2 all_entities_SSCell

  $return = $obj->all_entities_SSCell($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SSCell
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SSCell
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_SSCell
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_SSCell:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_SSCell');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_SSCell

    $return = $self->_all_entities($ctx, 'SSCell', $start, $count, $fields);

    #END all_entities_SSCell
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_SSCell:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_SSCell');
    }
    return($return);
}




=head2 get_entity_SSRow

  $return = $obj->get_entity_SSRow($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SSRow
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SSRow
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string


=end text



=item Description

An SSRow (that is, a row in a subsystem spreadsheet)
represents a collection of functional roles present in the
Features of a single Genome.  The roles are part of a designated
subsystem, and the features associated with each role are included
in the row. That is, a row amounts to an instance of a subsystem as
it exists in a specific, designated genome.

It has the following fields:

=over 4

=item curated

This flag is TRUE if the assignment of the molecular machine has been curated, and FALSE if it was made by an automated program.

=item region

Region in the genome for which the row is relevant. Normally, this is an empty string, indicating that the machine covers the whole genome. If a subsystem has multiple rows for a genome, this contains a location string describing the region occupied by this particular row.


=back

=back

=cut

sub get_entity_SSRow
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_SSRow:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_SSRow');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_SSRow

    $return = $self->_get_entity($ctx, 'SSRow', $ids, $fields);

    #END get_entity_SSRow
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_SSRow:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_SSRow');
    }
    return($return);
}




=head2 query_entity_SSRow

  $return = $obj->query_entity_SSRow($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SSRow
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SSRow
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_SSRow
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_SSRow:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_SSRow');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_SSRow

    $return = $self->_query_entity($ctx, 'SSRow', $qry, $fields);

    #END query_entity_SSRow
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_SSRow:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_SSRow');
    }
    return($return);
}




=head2 all_entities_SSRow

  $return = $obj->all_entities_SSRow($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SSRow
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SSRow
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_SSRow
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_SSRow:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_SSRow');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_SSRow

    $return = $self->_all_entities($ctx, 'SSRow', $start, $count, $fields);

    #END all_entities_SSRow
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_SSRow:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_SSRow');
    }
    return($return);
}




=head2 get_entity_Sample

  $return = $obj->get_entity_Sample($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Sample
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Sample
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int


=end text



=item Description

A sample is an experiment.  
In intensity experiment situations the sample will map 1 to 1 to the GSM.  
In this case there will be corresponding log2level data stored in the Measurement table.


It has the following fields:

=over 4

=item title

free text title of the sample

=item dataSource

The Data Source will be a way to identify where the data came from.  Examples might be : GEO, SEED Expression Pipeline, Enigma, M3D

=item externalSourceId

The externalSourceId gives users potentially an easy way to find the data of interest (ex:GSM9514). This will keep them from having to do problematic likes on the source-id field.

=item description

Free-text descibing the experiment.

=item molecule

Enumerated field (total RNA, polyA RNA, cytoplasmic RNA, nuclear RNA, genomic DNA).

=item type

Enumerated Microarray, RNA-Seq, qPCR

=item kbaseSubmissionDate

date of submission to Kbase

=item externalSourceDate

date that may exist in the external source metadata (could be to GEO, M3D etc...)

=item custom

A flag to keep track if this series was generated by custom operations (averaging or comparison)

=item originalLog2Median

The Original Median of the sample in log2space.  If null means the original median was not able to be determined.

=item source_id

The ID of the environment used by the data source.

=item dataQualityLevel

The quality of the data.  Lower the number the better.  Details need to be worked out.


=back

=back

=cut

sub get_entity_Sample
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Sample:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Sample');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Sample

    $return = $self->_get_entity($ctx, 'Sample', $ids, $fields);

    #END get_entity_Sample
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Sample:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Sample');
    }
    return($return);
}




=head2 query_entity_Sample

  $return = $obj->query_entity_Sample($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Sample
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Sample
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int


=end text



=item Description



=back

=cut

sub query_entity_Sample
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Sample:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Sample');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Sample

    $return = $self->_query_entity($ctx, 'Sample', $qry, $fields);

    #END query_entity_Sample
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Sample:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Sample');
    }
    return($return);
}




=head2 all_entities_Sample

  $return = $obj->all_entities_Sample($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Sample
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Sample
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int


=end text



=item Description



=back

=cut

sub all_entities_Sample
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Sample:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Sample');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Sample

    $return = $self->_all_entities($ctx, 'Sample', $start, $count, $fields);

    #END all_entities_Sample
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Sample:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Sample');
    }
    return($return);
}




=head2 get_entity_SampleAnnotation

  $return = $obj->get_entity_SampleAnnotation($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SampleAnnotation
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SampleAnnotation
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string


=end text



=item Description

Keeps track of ontology annotation date (and person if not automated).


It has the following fields:

=over 4

=item annotationDate

date of annotation

=item source_id

The ID of the environment used by the data source.


=back

=back

=cut

sub get_entity_SampleAnnotation
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_SampleAnnotation:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_SampleAnnotation');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_SampleAnnotation

    $return = $self->_get_entity($ctx, 'SampleAnnotation', $ids, $fields);

    #END get_entity_SampleAnnotation
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_SampleAnnotation:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_SampleAnnotation');
    }
    return($return);
}




=head2 query_entity_SampleAnnotation

  $return = $obj->query_entity_SampleAnnotation($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SampleAnnotation
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SampleAnnotation
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_SampleAnnotation
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_SampleAnnotation:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_SampleAnnotation');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_SampleAnnotation

    $return = $self->_query_entity($ctx, 'SampleAnnotation', $qry, $fields);

    #END query_entity_SampleAnnotation
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_SampleAnnotation:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_SampleAnnotation');
    }
    return($return);
}




=head2 all_entities_SampleAnnotation

  $return = $obj->all_entities_SampleAnnotation($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SampleAnnotation
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SampleAnnotation
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_SampleAnnotation
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_SampleAnnotation:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_SampleAnnotation');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_SampleAnnotation

    $return = $self->_all_entities($ctx, 'SampleAnnotation', $start, $count, $fields);

    #END all_entities_SampleAnnotation
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_SampleAnnotation:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_SampleAnnotation');
    }
    return($return);
}




=head2 get_entity_Scenario

  $return = $obj->get_entity_Scenario($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Scenario
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Scenario
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string


=end text



=item Description

A scenario is a partial instance of a subsystem with a
defined set of reactions. Each scenario converts input compounds to
output compounds using reactions. The scenario may use all of the
reactions controlled by a subsystem or only some, and may also
incorporate additional reactions. Because scenario names are not
unique, the actual scenario ID is a number.

It has the following fields:

=over 4

=item common_name

Common name of the scenario. The name, rather than the ID number, is usually displayed everywhere.


=back

=back

=cut

sub get_entity_Scenario
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Scenario:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Scenario');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Scenario

    $return = $self->_get_entity($ctx, 'Scenario', $ids, $fields);

    #END get_entity_Scenario
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Scenario:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Scenario');
    }
    return($return);
}




=head2 query_entity_Scenario

  $return = $obj->query_entity_Scenario($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Scenario
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Scenario
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Scenario
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Scenario:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Scenario');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Scenario

    $return = $self->_query_entity($ctx, 'Scenario', $qry, $fields);

    #END query_entity_Scenario
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Scenario:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Scenario');
    }
    return($return);
}




=head2 all_entities_Scenario

  $return = $obj->all_entities_Scenario($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Scenario
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Scenario
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Scenario
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Scenario:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Scenario');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Scenario

    $return = $self->_all_entities($ctx, 'Scenario', $start, $count, $fields);

    #END all_entities_Scenario
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Scenario:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Scenario');
    }
    return($return);
}




=head2 get_entity_Series

  $return = $obj->get_entity_Series($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Series
fields_Series is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	summary has a value which is a string
	design has a value which is a string
	externalSourceId has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Series
fields_Series is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	summary has a value which is a string
	design has a value which is a string
	externalSourceId has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	source_id has a value which is a string


=end text



=item Description

A series refers to a group of samples for expression data.

It has the following fields:

=over 4

=item title

free text title of the series

=item summary

free text summary of the series

=item design

free text design of the series

=item externalSourceId

The externalSourceId gives users potentially an easy way to find the data of interest (ex:GSE2365). This will keep them from having to do problematic likes on the source-id field.

=item kbaseSubmissionDate

date of submission (to Kbase)

=item externalSourceDate

date that may exist in the external source metadata (could be to GEO, M3D etc...)

=item source_id

The ID of the environment used by the data source.


=back

=back

=cut

sub get_entity_Series
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Series:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Series');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Series

    $return = $self->_get_entity($ctx, 'Series', $ids, $fields);

    #END get_entity_Series
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Series:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Series');
    }
    return($return);
}




=head2 query_entity_Series

  $return = $obj->query_entity_Series($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Series
fields_Series is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	summary has a value which is a string
	design has a value which is a string
	externalSourceId has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Series
fields_Series is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	summary has a value which is a string
	design has a value which is a string
	externalSourceId has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Series
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Series:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Series');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Series

    $return = $self->_query_entity($ctx, 'Series', $qry, $fields);

    #END query_entity_Series
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Series:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Series');
    }
    return($return);
}




=head2 all_entities_Series

  $return = $obj->all_entities_Series($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Series
fields_Series is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	summary has a value which is a string
	design has a value which is a string
	externalSourceId has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Series
fields_Series is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	summary has a value which is a string
	design has a value which is a string
	externalSourceId has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Series
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Series:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Series');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Series

    $return = $self->_all_entities($ctx, 'Series', $start, $count, $fields);

    #END all_entities_Series
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Series:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Series');
    }
    return($return);
}




=head2 get_entity_Source

  $return = $obj->get_entity_Source($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Source
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Source
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string


=end text



=item Description

A source is a user or organization that is permitted to
assign its own identifiers or to submit bioinformatic objects
to the database.

It has the following fields:

=over 4

=item name

The user-readable name for this source.

=item url

The URL to a site with information about this source.

=item description

A short textual description of this source.


=back

=back

=cut

sub get_entity_Source
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Source:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Source');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Source

    $return = $self->_get_entity($ctx, 'Source', $ids, $fields);

    #END get_entity_Source
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Source:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Source');
    }
    return($return);
}




=head2 query_entity_Source

  $return = $obj->query_entity_Source($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Source
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Source
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Source
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Source:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Source');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Source

    $return = $self->_query_entity($ctx, 'Source', $qry, $fields);

    #END query_entity_Source
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Source:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Source');
    }
    return($return);
}




=head2 all_entities_Source

  $return = $obj->all_entities_Source($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Source
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Source
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Source
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Source:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Source');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Source

    $return = $self->_all_entities($ctx, 'Source', $start, $count, $fields);

    #END all_entities_Source
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Source:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Source');
    }
    return($return);
}




=head2 get_entity_Strain

  $return = $obj->get_entity_Strain($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Strain
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Strain
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string


=end text



=item Description

This entity represents an organism derived from a genome or
another organism with one or more modifications to the organism's
genome.

It has the following fields:

=over 4

=item name

The common or laboratory name of the strain, e.g. DH5a or JMP1004.

=item description

A description of the strain, e.g. knockout/modification methods, resulting phenotypes, etc.

=item source_id

The ID of the strain used by the data source.

=item aggregateData

Denotes whether this entity represents a physical strain (False) or aggregate data calculated from one or more strains (True).

=item wildtype

Denotes this strain is presumably identical to the parent genome.

=item referenceStrain

Denotes whether this strain is a reference strain; e.g. it is identical to the genome it's related to (True) or not (False). In contrast to wildtype, a referenceStrain is abstract and does not physically exist and is used for data that refers to a genome but not a particular strain. There should only exist one reference strain per genome and all reference strains are wildtype. 


=back

=back

=cut

sub get_entity_Strain
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Strain:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Strain');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Strain

    $return = $self->_get_entity($ctx, 'Strain', $ids, $fields);

    #END get_entity_Strain
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Strain:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Strain');
    }
    return($return);
}




=head2 query_entity_Strain

  $return = $obj->query_entity_Strain($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Strain
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Strain
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Strain
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Strain:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Strain');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Strain

    $return = $self->_query_entity($ctx, 'Strain', $qry, $fields);

    #END query_entity_Strain
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Strain:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Strain');
    }
    return($return);
}




=head2 all_entities_Strain

  $return = $obj->all_entities_Strain($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Strain
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Strain
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Strain
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Strain:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Strain');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Strain

    $return = $self->_all_entities($ctx, 'Strain', $start, $count, $fields);

    #END all_entities_Strain
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Strain:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Strain');
    }
    return($return);
}




=head2 get_entity_StudyExperiment

  $return = $obj->get_entity_StudyExperiment($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_StudyExperiment
fields_StudyExperiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	design has a value which is a string
	originator has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_StudyExperiment
fields_StudyExperiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	design has a value which is a string
	originator has a value which is a string


=end text



=item Description

An Experiment is a collection of observational units with one originator that are part of a specific study.  An experiment may be conducted at more than one location and in more than one season or year.

It has the following fields:

=over 4

=item source_name

Name/ID by which the experiment is known at the source.  

=item design

Design of the experiment including the numbers and types of observational units, traits, replicates, sampling plan, and analysis that are planned.

=item originator

Name of the individual or program that are the originators of the experiment.


=back

=back

=cut

sub get_entity_StudyExperiment
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_StudyExperiment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_StudyExperiment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_StudyExperiment

    $return = $self->_get_entity($ctx, 'StudyExperiment', $ids, $fields);

    #END get_entity_StudyExperiment
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_StudyExperiment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_StudyExperiment');
    }
    return($return);
}




=head2 query_entity_StudyExperiment

  $return = $obj->query_entity_StudyExperiment($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_StudyExperiment
fields_StudyExperiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	design has a value which is a string
	originator has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_StudyExperiment
fields_StudyExperiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	design has a value which is a string
	originator has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_StudyExperiment
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_StudyExperiment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_StudyExperiment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_StudyExperiment

    $return = $self->_query_entity($ctx, 'StudyExperiment', $qry, $fields);

    #END query_entity_StudyExperiment
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_StudyExperiment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_StudyExperiment');
    }
    return($return);
}




=head2 all_entities_StudyExperiment

  $return = $obj->all_entities_StudyExperiment($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_StudyExperiment
fields_StudyExperiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	design has a value which is a string
	originator has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_StudyExperiment
fields_StudyExperiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	design has a value which is a string
	originator has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_StudyExperiment
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_StudyExperiment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_StudyExperiment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_StudyExperiment

    $return = $self->_all_entities($ctx, 'StudyExperiment', $start, $count, $fields);

    #END all_entities_StudyExperiment
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_StudyExperiment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_StudyExperiment');
    }
    return($return);
}




=head2 get_entity_Subsystem

  $return = $obj->get_entity_Subsystem($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Subsystem
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Subsystem
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int


=end text



=item Description

A subsystem is a set of functional roles that have been annotated simultaneously (e.g.,
the roles present in a specific pathway), with an associated subsystem spreadsheet
which encodes the fids in each genome that implement the functional roles in the
subsystem.

It has the following fields:

=over 4

=item version

version number for the subsystem. This value is incremented each time the subsystem is backed up.

=item curator

name of the person currently in charge of the subsystem

=item notes

descriptive notes about the subsystem

=item description

description of the subsystem's function in the cell

=item usable

TRUE if this is a usable subsystem, else FALSE. An unusable subsystem is one that is experimental or is of such low quality that it can negatively affect analysis.

=item private

TRUE if this is a private subsystem, else FALSE. A private subsystem has valid data, but is not considered ready for general distribution.

=item cluster_based

TRUE if this is a clustering-based subsystem, else FALSE. A clustering-based subsystem is one in which there is functional-coupling evidence that genes belong together, but we do not yet know what they do.

=item experimental

TRUE if this is an experimental subsystem, else FALSE. An experimental subsystem is designed for investigation and is not yet ready to be used in comparative analysis and annotation.


=back

=back

=cut

sub get_entity_Subsystem
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Subsystem:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Subsystem');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Subsystem

    $return = $self->_get_entity($ctx, 'Subsystem', $ids, $fields);

    #END get_entity_Subsystem
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Subsystem:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Subsystem');
    }
    return($return);
}




=head2 query_entity_Subsystem

  $return = $obj->query_entity_Subsystem($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Subsystem
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Subsystem
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int


=end text



=item Description



=back

=cut

sub query_entity_Subsystem
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Subsystem:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Subsystem');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Subsystem

    $return = $self->_query_entity($ctx, 'Subsystem', $qry, $fields);

    #END query_entity_Subsystem
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Subsystem:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Subsystem');
    }
    return($return);
}




=head2 all_entities_Subsystem

  $return = $obj->all_entities_Subsystem($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Subsystem
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Subsystem
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int


=end text



=item Description



=back

=cut

sub all_entities_Subsystem
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Subsystem:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Subsystem');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Subsystem

    $return = $self->_all_entities($ctx, 'Subsystem', $start, $count, $fields);

    #END all_entities_Subsystem
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Subsystem:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Subsystem');
    }
    return($return);
}




=head2 get_entity_SubsystemClass

  $return = $obj->get_entity_SubsystemClass($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SubsystemClass
fields_SubsystemClass is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SubsystemClass
fields_SubsystemClass is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

Subsystem classes impose a hierarchical organization on the
subsystems.

It has the following fields:

=over 4


=back

=back

=cut

sub get_entity_SubsystemClass
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_SubsystemClass:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_SubsystemClass');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_SubsystemClass

    $return = $self->_get_entity($ctx, 'SubsystemClass', $ids, $fields);

    #END get_entity_SubsystemClass
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_SubsystemClass:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_SubsystemClass');
    }
    return($return);
}




=head2 query_entity_SubsystemClass

  $return = $obj->query_entity_SubsystemClass($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SubsystemClass
fields_SubsystemClass is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SubsystemClass
fields_SubsystemClass is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_SubsystemClass
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_SubsystemClass:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_SubsystemClass');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_SubsystemClass

    $return = $self->_query_entity($ctx, 'SubsystemClass', $qry, $fields);

    #END query_entity_SubsystemClass
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_SubsystemClass:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_SubsystemClass');
    }
    return($return);
}




=head2 all_entities_SubsystemClass

  $return = $obj->all_entities_SubsystemClass($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SubsystemClass
fields_SubsystemClass is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_SubsystemClass
fields_SubsystemClass is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_SubsystemClass
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_SubsystemClass:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_SubsystemClass');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_SubsystemClass

    $return = $self->_all_entities($ctx, 'SubsystemClass', $start, $count, $fields);

    #END all_entities_SubsystemClass
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_SubsystemClass:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_SubsystemClass');
    }
    return($return);
}




=head2 get_entity_TaxonomicGrouping

  $return = $obj->get_entity_TaxonomicGrouping($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TaxonomicGrouping
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TaxonomicGrouping
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description

We associate with most genomes a "taxonomy" based on
the NCBI taxonomy. This includes, for each genome, a list of
ever larger taxonomic groups. The groups are stored as
instances of this entity, and chained together by the
IsGroupFor relationship.

It has the following fields:

=over 4

=item domain

TRUE if this is a domain grouping, else FALSE.

=item hidden

TRUE if this is a hidden grouping, else FALSE. Hidden groupings are not typically shown in a lineage list.

=item scientific_name

Primary scientific name for this grouping. This is the name used when displaying a taxonomy.

=item alias

Alternate name for this grouping. A grouping may have many alternate names. The scientific name should also be in this list.


=back

=back

=cut

sub get_entity_TaxonomicGrouping
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_TaxonomicGrouping:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_TaxonomicGrouping');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_TaxonomicGrouping

    $return = $self->_get_entity($ctx, 'TaxonomicGrouping', $ids, $fields);

    #END get_entity_TaxonomicGrouping
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_TaxonomicGrouping:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_TaxonomicGrouping');
    }
    return($return);
}




=head2 query_entity_TaxonomicGrouping

  $return = $obj->query_entity_TaxonomicGrouping($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TaxonomicGrouping
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TaxonomicGrouping
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub query_entity_TaxonomicGrouping
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_TaxonomicGrouping:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_TaxonomicGrouping');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_TaxonomicGrouping

    $return = $self->_query_entity($ctx, 'TaxonomicGrouping', $qry, $fields);

    #END query_entity_TaxonomicGrouping
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_TaxonomicGrouping:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_TaxonomicGrouping');
    }
    return($return);
}




=head2 all_entities_TaxonomicGrouping

  $return = $obj->all_entities_TaxonomicGrouping($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TaxonomicGrouping
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TaxonomicGrouping
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub all_entities_TaxonomicGrouping
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_TaxonomicGrouping:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_TaxonomicGrouping');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_TaxonomicGrouping

    $return = $self->_all_entities($ctx, 'TaxonomicGrouping', $start, $count, $fields);

    #END all_entities_TaxonomicGrouping
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_TaxonomicGrouping:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_TaxonomicGrouping');
    }
    return($return);
}




=head2 get_entity_TimeSeries

  $return = $obj->get_entity_TimeSeries($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TimeSeries
fields_TimeSeries is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	timeUnits has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TimeSeries
fields_TimeSeries is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	timeUnits has a value which is a string


=end text



=item Description

A TimeSeries provides a means to specify a series of experimental data
over time by ordering multiple ExperimentalUnits.


It has the following fields:

=over 4

=item source_id

The ID of the time series used by the data source.

=item name

The name of this time series, if any.

=item comments

Any comments regarding this time series.

=item timeUnits

The units of time for this time series, e.g. 'seconds', 'hours', or more abstractly, 'number of times culture grown to saturation.'


=back

=back

=cut

sub get_entity_TimeSeries
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_TimeSeries:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_TimeSeries');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_TimeSeries

    $return = $self->_get_entity($ctx, 'TimeSeries', $ids, $fields);

    #END get_entity_TimeSeries
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_TimeSeries:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_TimeSeries');
    }
    return($return);
}




=head2 query_entity_TimeSeries

  $return = $obj->query_entity_TimeSeries($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TimeSeries
fields_TimeSeries is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	timeUnits has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TimeSeries
fields_TimeSeries is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	timeUnits has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_TimeSeries
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_TimeSeries:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_TimeSeries');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_TimeSeries

    $return = $self->_query_entity($ctx, 'TimeSeries', $qry, $fields);

    #END query_entity_TimeSeries
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_TimeSeries:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_TimeSeries');
    }
    return($return);
}




=head2 all_entities_TimeSeries

  $return = $obj->all_entities_TimeSeries($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TimeSeries
fields_TimeSeries is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	timeUnits has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TimeSeries
fields_TimeSeries is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	timeUnits has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_TimeSeries
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_TimeSeries:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_TimeSeries');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_TimeSeries

    $return = $self->_all_entities($ctx, 'TimeSeries', $start, $count, $fields);

    #END all_entities_TimeSeries
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_TimeSeries:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_TimeSeries');
    }
    return($return);
}




=head2 get_entity_Trait

  $return = $obj->get_entity_Trait($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Trait
fields_Trait is a reference to a hash where the following keys are defined:
	id has a value which is a string
	trait_name has a value which is a string
	unit_of_measure has a value which is a string
	TO_ID has a value which is a string
	protocol has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Trait
fields_Trait is a reference to a hash where the following keys are defined:
	id has a value which is a string
	trait_name has a value which is a string
	unit_of_measure has a value which is a string
	TO_ID has a value which is a string
	protocol has a value which is a string


=end text



=item Description

A Trait is a phenotypic quality that can be measured or observed for an observational unit.  Examples include height, sugar content, color, or cold tolerance.

It has the following fields:

=over 4

=item trait_name

Text name or description of the trait

=item unit_of_measure

The units of measure used when determining this trait.  If multiple units of measure are applicable, each has its own row in the database.  

=item TO_ID

Trait Ontology term ID (http://www.gramene.org/plant-ontology/)

=item protocol

A thorough description of how the trait was collected, and if a rating, the minimum and maximum values


=back

=back

=cut

sub get_entity_Trait
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Trait:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Trait');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Trait

    $return = $self->_get_entity($ctx, 'Trait', $ids, $fields);

    #END get_entity_Trait
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Trait:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Trait');
    }
    return($return);
}




=head2 query_entity_Trait

  $return = $obj->query_entity_Trait($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Trait
fields_Trait is a reference to a hash where the following keys are defined:
	id has a value which is a string
	trait_name has a value which is a string
	unit_of_measure has a value which is a string
	TO_ID has a value which is a string
	protocol has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Trait
fields_Trait is a reference to a hash where the following keys are defined:
	id has a value which is a string
	trait_name has a value which is a string
	unit_of_measure has a value which is a string
	TO_ID has a value which is a string
	protocol has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Trait
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Trait:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Trait');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Trait

    $return = $self->_query_entity($ctx, 'Trait', $qry, $fields);

    #END query_entity_Trait
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Trait:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Trait');
    }
    return($return);
}




=head2 all_entities_Trait

  $return = $obj->all_entities_Trait($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Trait
fields_Trait is a reference to a hash where the following keys are defined:
	id has a value which is a string
	trait_name has a value which is a string
	unit_of_measure has a value which is a string
	TO_ID has a value which is a string
	protocol has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Trait
fields_Trait is a reference to a hash where the following keys are defined:
	id has a value which is a string
	trait_name has a value which is a string
	unit_of_measure has a value which is a string
	TO_ID has a value which is a string
	protocol has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Trait
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Trait:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Trait');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Trait

    $return = $self->_all_entities($ctx, 'Trait', $start, $count, $fields);

    #END all_entities_Trait
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Trait:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Trait');
    }
    return($return);
}




=head2 get_entity_Tree

  $return = $obj->get_entity_Tree($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Tree
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Tree
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string


=end text



=item Description

A tree describes how the sequences in an alignment relate
to each other. Most trees are phylogenetic, but some may be based on
taxonomy or gene content.

It has the following fields:

=over 4

=item status

status of the tree, currently either [i]active[/i], [i]superseded[/i], or [i]bad[/i]

=item data_type

type of data the tree was built from, usually [i]sequence_alignment[/i]

=item timestamp

date and time the tree was loaded

=item method

name of the primary software package or script used to construct the tree

=item parameters

non-default parameters used as input to the software package or script indicated in the method attribute

=item protocol

description of the steps taken to construct the tree, or a reference to an external pipeline

=item source_id

ID of this tree in the source database

=item newick

NEWICK format string containing the structure of the tree


=back

=back

=cut

sub get_entity_Tree
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Tree:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Tree');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Tree

    $return = $self->_get_entity($ctx, 'Tree', $ids, $fields);

    #END get_entity_Tree
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Tree:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Tree');
    }
    return($return);
}




=head2 query_entity_Tree

  $return = $obj->query_entity_Tree($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Tree
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Tree
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Tree
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Tree:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Tree');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Tree

    $return = $self->_query_entity($ctx, 'Tree', $qry, $fields);

    #END query_entity_Tree
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Tree:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Tree');
    }
    return($return);
}




=head2 all_entities_Tree

  $return = $obj->all_entities_Tree($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Tree
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Tree
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Tree
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Tree:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Tree');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Tree

    $return = $self->_all_entities($ctx, 'Tree', $start, $count, $fields);

    #END all_entities_Tree
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Tree:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Tree');
    }
    return($return);
}




=head2 get_entity_TreeAttribute

  $return = $obj->get_entity_TreeAttribute($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TreeAttribute
fields_TreeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TreeAttribute
fields_TreeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

This entity represents an attribute type that can
be assigned to a tree. The attribute
values are stored in the relationships to the target. The
key is the attribute name.

It has the following fields:

=over 4


=back

=back

=cut

sub get_entity_TreeAttribute
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_TreeAttribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_TreeAttribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_TreeAttribute

    $return = $self->_get_entity($ctx, 'TreeAttribute', $ids, $fields);

    #END get_entity_TreeAttribute
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_TreeAttribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_TreeAttribute');
    }
    return($return);
}




=head2 query_entity_TreeAttribute

  $return = $obj->query_entity_TreeAttribute($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TreeAttribute
fields_TreeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TreeAttribute
fields_TreeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_TreeAttribute
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_TreeAttribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_TreeAttribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_TreeAttribute

    $return = $self->_query_entity($ctx, 'TreeAttribute', $qry, $fields);

    #END query_entity_TreeAttribute
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_TreeAttribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_TreeAttribute');
    }
    return($return);
}




=head2 all_entities_TreeAttribute

  $return = $obj->all_entities_TreeAttribute($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TreeAttribute
fields_TreeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TreeAttribute
fields_TreeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_TreeAttribute
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_TreeAttribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_TreeAttribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_TreeAttribute

    $return = $self->_all_entities($ctx, 'TreeAttribute', $start, $count, $fields);

    #END all_entities_TreeAttribute
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_TreeAttribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_TreeAttribute');
    }
    return($return);
}




=head2 get_entity_TreeNodeAttribute

  $return = $obj->get_entity_TreeNodeAttribute($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TreeNodeAttribute
fields_TreeNodeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TreeNodeAttribute
fields_TreeNodeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

This entity represents an attribute type that can
be assigned to a node. The attribute
values are stored in the relationships to the target. The
key is the attribute name.

It has the following fields:

=over 4


=back

=back

=cut

sub get_entity_TreeNodeAttribute
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_TreeNodeAttribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_TreeNodeAttribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_TreeNodeAttribute

    $return = $self->_get_entity($ctx, 'TreeNodeAttribute', $ids, $fields);

    #END get_entity_TreeNodeAttribute
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_TreeNodeAttribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_TreeNodeAttribute');
    }
    return($return);
}




=head2 query_entity_TreeNodeAttribute

  $return = $obj->query_entity_TreeNodeAttribute($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TreeNodeAttribute
fields_TreeNodeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TreeNodeAttribute
fields_TreeNodeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_TreeNodeAttribute
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_TreeNodeAttribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_TreeNodeAttribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_TreeNodeAttribute

    $return = $self->_query_entity($ctx, 'TreeNodeAttribute', $qry, $fields);

    #END query_entity_TreeNodeAttribute
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_TreeNodeAttribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_TreeNodeAttribute');
    }
    return($return);
}




=head2 all_entities_TreeNodeAttribute

  $return = $obj->all_entities_TreeNodeAttribute($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TreeNodeAttribute
fields_TreeNodeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_TreeNodeAttribute
fields_TreeNodeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_TreeNodeAttribute
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_TreeNodeAttribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_TreeNodeAttribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_TreeNodeAttribute

    $return = $self->_all_entities($ctx, 'TreeNodeAttribute', $start, $count, $fields);

    #END all_entities_TreeNodeAttribute
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_TreeNodeAttribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_TreeNodeAttribute');
    }
    return($return);
}




=head2 get_entity_Variant

  $return = $obj->get_entity_Variant($ids, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Variant
fields_Variant is a reference to a hash where the following keys are defined:
	id has a value which is a string
	role_rule has a value which is a reference to a list where each element is a string
	code has a value which is a string
	type has a value which is a string
	comment has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Variant
fields_Variant is a reference to a hash where the following keys are defined:
	id has a value which is a string
	role_rule has a value which is a reference to a list where each element is a string
	code has a value which is a string
	type has a value which is a string
	comment has a value which is a string


=end text



=item Description

Each subsystem may include the designation of distinct
variants.  Thus, there may be three closely-related, but
distinguishable forms of histidine degradation.  Each form
would be called a "variant", with an associated code, and all
genomes implementing a specific variant can easily be accessed. The ID
is an MD5 of the subsystem name followed by the variant code.

It has the following fields:

=over 4

=item role_rule

a space-delimited list of role IDs, in alphabetical order, that represents a possible list of non-auxiliary roles applicable to this variant. The roles are identified by their abbreviations. A variant may have multiple role rules.

=item code

the variant code all by itself

=item type

variant type indicating the quality of the subsystem support. A type of "vacant" means that the subsystem does not appear to be implemented by the variant. A type of "incomplete" means that the subsystem appears to be missing many reactions. In all other cases, the type is "normal".

=item comment

commentary text about the variant


=back

=back

=cut

sub get_entity_Variant
{
    my $self = shift;
    my($ids, $fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_entity_Variant:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Variant');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_entity_Variant

    $return = $self->_get_entity($ctx, 'Variant', $ids, $fields);

    #END get_entity_Variant
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_entity_Variant:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_entity_Variant');
    }
    return($return);
}




=head2 query_entity_Variant

  $return = $obj->query_entity_Variant($qry, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Variant
fields_Variant is a reference to a hash where the following keys are defined:
	id has a value which is a string
	role_rule has a value which is a reference to a list where each element is a string
	code has a value which is a string
	type has a value which is a string
	comment has a value which is a string

</pre>

=end html

=begin text

$qry is a reference to a list where each element is a reference to a list containing 3 items:
	0: a string
	1: a string
	2: a string
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Variant
fields_Variant is a reference to a hash where the following keys are defined:
	id has a value which is a string
	role_rule has a value which is a reference to a list where each element is a string
	code has a value which is a string
	type has a value which is a string
	comment has a value which is a string


=end text



=item Description



=back

=cut

sub query_entity_Variant
{
    my $self = shift;
    my($qry, $fields) = @_;

    my @_bad_arguments;
    (ref($qry) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"qry\" (value was \"$qry\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to query_entity_Variant:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Variant');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN query_entity_Variant

    $return = $self->_query_entity($ctx, 'Variant', $qry, $fields);

    #END query_entity_Variant
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to query_entity_Variant:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'query_entity_Variant');
    }
    return($return);
}




=head2 all_entities_Variant

  $return = $obj->all_entities_Variant($start, $count, $fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Variant
fields_Variant is a reference to a hash where the following keys are defined:
	id has a value which is a string
	role_rule has a value which is a reference to a list where each element is a string
	code has a value which is a string
	type has a value which is a string
	comment has a value which is a string

</pre>

=end html

=begin text

$start is an int
$count is an int
$fields is a reference to a list where each element is a string
$return is a reference to a hash where the key is a string and the value is a fields_Variant
fields_Variant is a reference to a hash where the following keys are defined:
	id has a value which is a string
	role_rule has a value which is a reference to a list where each element is a string
	code has a value which is a string
	type has a value which is a string
	comment has a value which is a string


=end text



=item Description



=back

=cut

sub all_entities_Variant
{
    my $self = shift;
    my($start, $count, $fields) = @_;

    my @_bad_arguments;
    (!ref($start)) or push(@_bad_arguments, "Invalid type for argument \"start\" (value was \"$start\")");
    (!ref($count)) or push(@_bad_arguments, "Invalid type for argument \"count\" (value was \"$count\")");
    (ref($fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"fields\" (value was \"$fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to all_entities_Variant:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Variant');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN all_entities_Variant

    $return = $self->_all_entities($ctx, 'Variant', $start, $count, $fields);

    #END all_entities_Variant
    my @_bad_returns;
    (ref($return) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to all_entities_Variant:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'all_entities_Variant');
    }
    return($return);
}




=head2 get_relationship_AffectsLevelOf

  $return = $obj->get_relationship_AffectsLevelOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Experiment
	1: a fields_AffectsLevelOf
	2: a fields_AtomicRegulon
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string
fields_AffectsLevelOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	level has a value which is an int
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Experiment
	1: a fields_AffectsLevelOf
	2: a fields_AtomicRegulon
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string
fields_AffectsLevelOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	level has a value which is an int
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

This relationship indicates the expression level of an atomic regulon
for a given experiment.

It has the following fields:

=over 4

=item level

Indication of whether the feature is expressed (1), not expressed (-1), or unknown (0).


=back

=back

=cut

sub get_relationship_AffectsLevelOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_AffectsLevelOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AffectsLevelOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_AffectsLevelOf

    $return = $self->_get_relationship($ctx, 'AffectsLevelOf', 'AffectsLevelOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_AffectsLevelOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_AffectsLevelOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AffectsLevelOf');
    }
    return($return);
}




=head2 get_relationship_IsAffectedIn

  $return = $obj->get_relationship_IsAffectedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AtomicRegulon
	1: a fields_AffectsLevelOf
	2: a fields_Experiment
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_AffectsLevelOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	level has a value which is an int
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AtomicRegulon
	1: a fields_AffectsLevelOf
	2: a fields_Experiment
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_AffectsLevelOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	level has a value which is an int
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsAffectedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsAffectedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsAffectedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsAffectedIn

    $return = $self->_get_relationship($ctx, 'IsAffectedIn', 'AffectsLevelOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsAffectedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsAffectedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsAffectedIn');
    }
    return($return);
}




=head2 get_relationship_Aligned

  $return = $obj->get_relationship_Aligned($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_Aligned
	2: a fields_Alignment
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_Aligned is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_Aligned
	2: a fields_Alignment
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_Aligned is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string


=end text



=item Description

This relationship connects an alignment to the database
from which it was generated.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_Aligned
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Aligned:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Aligned');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Aligned

    $return = $self->_get_relationship($ctx, 'Aligned', 'Aligned', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Aligned
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Aligned:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Aligned');
    }
    return($return);
}




=head2 get_relationship_WasAlignedBy

  $return = $obj->get_relationship_WasAlignedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_Aligned
	2: a fields_Source
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_Aligned is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_Aligned
	2: a fields_Source
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_Aligned is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_WasAlignedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_WasAlignedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_WasAlignedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_WasAlignedBy

    $return = $self->_get_relationship($ctx, 'WasAlignedBy', 'Aligned', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_WasAlignedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_WasAlignedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_WasAlignedBy');
    }
    return($return);
}




=head2 get_relationship_AssertsFunctionFor

  $return = $obj->get_relationship_AssertsFunctionFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_AssertsFunctionFor
	2: a fields_ProteinSequence
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_AssertsFunctionFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	function has a value which is a string
	external_id has a value which is a string
	organism has a value which is a string
	gi_number has a value which is an int
	release_date has a value which is a string
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_AssertsFunctionFor
	2: a fields_ProteinSequence
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_AssertsFunctionFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	function has a value which is a string
	external_id has a value which is a string
	organism has a value which is a string
	gi_number has a value which is an int
	release_date has a value which is a string
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string


=end text



=item Description

Sources (users) can make assertions about protein sequence function.
The assertion is associated with an external identifier.

It has the following fields:

=over 4

=item function

text of the assertion made about the identifier. It may be an empty string, indicating the function is unknown.

=item external_id

external identifier used in making the assertion

=item organism

organism name associated with this assertion. If the assertion is not associated with a specific organism, this will be an empty string.

=item gi_number

NCBI GI number associated with the asserted identifier

=item release_date

date and time the assertion was downloaded


=back

=back

=cut

sub get_relationship_AssertsFunctionFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_AssertsFunctionFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AssertsFunctionFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_AssertsFunctionFor

    $return = $self->_get_relationship($ctx, 'AssertsFunctionFor', 'AssertsFunctionFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_AssertsFunctionFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_AssertsFunctionFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AssertsFunctionFor');
    }
    return($return);
}




=head2 get_relationship_HasAssertedFunctionFrom

  $return = $obj->get_relationship_HasAssertedFunctionFrom($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProteinSequence
	1: a fields_AssertsFunctionFor
	2: a fields_Source
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string
fields_AssertsFunctionFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	function has a value which is a string
	external_id has a value which is a string
	organism has a value which is a string
	gi_number has a value which is an int
	release_date has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProteinSequence
	1: a fields_AssertsFunctionFor
	2: a fields_Source
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string
fields_AssertsFunctionFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	function has a value which is a string
	external_id has a value which is a string
	organism has a value which is a string
	gi_number has a value which is an int
	release_date has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasAssertedFunctionFrom
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasAssertedFunctionFrom:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasAssertedFunctionFrom');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasAssertedFunctionFrom

    $return = $self->_get_relationship($ctx, 'HasAssertedFunctionFrom', 'AssertsFunctionFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasAssertedFunctionFrom
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasAssertedFunctionFrom:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasAssertedFunctionFrom');
    }
    return($return);
}




=head2 get_relationship_AssociationFeature

  $return = $obj->get_relationship_AssociationFeature($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Association
	1: a fields_AssociationFeature
	2: a fields_Feature
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string
fields_AssociationFeature is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	stoichiometry has a value which is an int
	strength has a value which is a float
	rank has a value which is an int
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Association
	1: a fields_AssociationFeature
	2: a fields_Feature
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string
fields_AssociationFeature is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	stoichiometry has a value which is an int
	strength has a value which is a float
	rank has a value which is an int
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description

The AssociationFeature relationship links associations to
the features that encode their component proteins.

It has the following fields:

=over 4

=item stoichiometry

Stoichiometry, if applicable (e.g., for a curated complex.

=item strength

Optional numeric measure of strength of the association (e.g., kD or relative estimate of binding affinity)

=item rank

Numbered starting at 1 within an Association, if directional.  Meaning is method-dependent; e.g., for associations derived from pulldown data, rank 1 should be assigned to the bait.


=back

=back

=cut

sub get_relationship_AssociationFeature
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_AssociationFeature:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AssociationFeature');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_AssociationFeature

    $return = $self->_get_relationship($ctx, 'AssociationFeature', 'AssociationFeature', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_AssociationFeature
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_AssociationFeature:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AssociationFeature');
    }
    return($return);
}




=head2 get_relationship_FeatureInteractsIn

  $return = $obj->get_relationship_FeatureInteractsIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_AssociationFeature
	2: a fields_Association
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_AssociationFeature is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	stoichiometry has a value which is an int
	strength has a value which is a float
	rank has a value which is an int
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_AssociationFeature
	2: a fields_Association
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_AssociationFeature is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	stoichiometry has a value which is an int
	strength has a value which is a float
	rank has a value which is an int
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_FeatureInteractsIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_FeatureInteractsIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_FeatureInteractsIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_FeatureInteractsIn

    $return = $self->_get_relationship($ctx, 'FeatureInteractsIn', 'AssociationFeature', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_FeatureInteractsIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_FeatureInteractsIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_FeatureInteractsIn');
    }
    return($return);
}




=head2 get_relationship_CompoundMeasuredBy

  $return = $obj->get_relationship_CompoundMeasuredBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_CompoundMeasuredBy
	2: a fields_Measurement
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_CompoundMeasuredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_CompoundMeasuredBy
	2: a fields_Measurement
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_CompoundMeasuredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float


=end text



=item Description

Denotes the compound that a measurement quantifies.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_CompoundMeasuredBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_CompoundMeasuredBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_CompoundMeasuredBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_CompoundMeasuredBy

    $return = $self->_get_relationship($ctx, 'CompoundMeasuredBy', 'CompoundMeasuredBy', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_CompoundMeasuredBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_CompoundMeasuredBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_CompoundMeasuredBy');
    }
    return($return);
}




=head2 get_relationship_MeasuresCompound

  $return = $obj->get_relationship_MeasuresCompound($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Measurement
	1: a fields_CompoundMeasuredBy
	2: a fields_Compound
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float
fields_CompoundMeasuredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Measurement
	1: a fields_CompoundMeasuredBy
	2: a fields_Compound
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float
fields_CompoundMeasuredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float


=end text



=item Description



=back

=cut

sub get_relationship_MeasuresCompound
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_MeasuresCompound:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_MeasuresCompound');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_MeasuresCompound

    $return = $self->_get_relationship($ctx, 'MeasuresCompound', 'CompoundMeasuredBy', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_MeasuresCompound
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_MeasuresCompound:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_MeasuresCompound');
    }
    return($return);
}




=head2 get_relationship_Concerns

  $return = $obj->get_relationship_Concerns($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Publication
	1: a fields_Concerns
	2: a fields_ProteinSequence
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string
fields_Concerns is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Publication
	1: a fields_Concerns
	2: a fields_ProteinSequence
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string
fields_Concerns is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string


=end text



=item Description

This relationship connects a publication to the protein
sequences it describes.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_Concerns
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Concerns:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Concerns');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Concerns

    $return = $self->_get_relationship($ctx, 'Concerns', 'Concerns', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Concerns
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Concerns:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Concerns');
    }
    return($return);
}




=head2 get_relationship_IsATopicOf

  $return = $obj->get_relationship_IsATopicOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProteinSequence
	1: a fields_Concerns
	2: a fields_Publication
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string
fields_Concerns is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProteinSequence
	1: a fields_Concerns
	2: a fields_Publication
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string
fields_Concerns is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsATopicOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsATopicOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsATopicOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsATopicOf

    $return = $self->_get_relationship($ctx, 'IsATopicOf', 'Concerns', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsATopicOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsATopicOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsATopicOf');
    }
    return($return);
}




=head2 get_relationship_ConsistsOfCompounds

  $return = $obj->get_relationship_ConsistsOfCompounds($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_ConsistsOfCompounds
	2: a fields_Compound
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_ConsistsOfCompounds is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	molar_ratio has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_ConsistsOfCompounds
	2: a fields_Compound
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_ConsistsOfCompounds is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	molar_ratio has a value which is a float


=end text



=item Description

This relationship defines the subcompounds that make up a
compound. For example, CoCl2-6H2O is made up of 1 Co2+, 2 Cl-, and
6 H2O.

It has the following fields:

=over 4

=item molar_ratio

Number of molecules of the subcompound that make up the compound. A -1 in this field signifies that although the subcompound is present in the compound, the molar ratio is unknown.


=back

=back

=cut

sub get_relationship_ConsistsOfCompounds
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ConsistsOfCompounds:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ConsistsOfCompounds');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ConsistsOfCompounds

    $return = $self->_get_relationship($ctx, 'ConsistsOfCompounds', 'ConsistsOfCompounds', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ConsistsOfCompounds
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ConsistsOfCompounds:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ConsistsOfCompounds');
    }
    return($return);
}




=head2 get_relationship_ComponentOf

  $return = $obj->get_relationship_ComponentOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_ConsistsOfCompounds
	2: a fields_Compound
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_ConsistsOfCompounds is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	molar_ratio has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_ConsistsOfCompounds
	2: a fields_Compound
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_ConsistsOfCompounds is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	molar_ratio has a value which is a float


=end text



=item Description



=back

=cut

sub get_relationship_ComponentOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ComponentOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ComponentOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ComponentOf

    $return = $self->_get_relationship($ctx, 'ComponentOf', 'ConsistsOfCompounds', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ComponentOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ComponentOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ComponentOf');
    }
    return($return);
}




=head2 get_relationship_Contains

  $return = $obj->get_relationship_Contains($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SSCell
	1: a fields_Contains
	2: a fields_Feature
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_Contains is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SSCell
	1: a fields_Contains
	2: a fields_Feature
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_Contains is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description

This relationship connects a subsystem spreadsheet cell to the features
that occur in it. A feature may occur in many machine roles and a
machine role may contain many features. The subsystem annotation
process is essentially the maintenance of this relationship.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_Contains
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Contains:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Contains');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Contains

    $return = $self->_get_relationship($ctx, 'Contains', 'Contains', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Contains
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Contains:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Contains');
    }
    return($return);
}




=head2 get_relationship_IsContainedIn

  $return = $obj->get_relationship_IsContainedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_Contains
	2: a fields_SSCell
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_Contains is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_Contains
	2: a fields_SSCell
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_Contains is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsContainedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsContainedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsContainedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsContainedIn

    $return = $self->_get_relationship($ctx, 'IsContainedIn', 'Contains', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsContainedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsContainedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsContainedIn');
    }
    return($return);
}




=head2 get_relationship_ContainsAlignedDNA

  $return = $obj->get_relationship_ContainsAlignedDNA($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AlignmentRow
	1: a fields_ContainsAlignedDNA
	2: a fields_ContigSequence
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string
fields_ContainsAlignedDNA is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	index_in_concatenation has a value which is an int
	beg_pos_in_parent has a value which is an int
	end_pos_in_parent has a value which is an int
	parent_seq_len has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	kb_feature_id has a value which is a string
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AlignmentRow
	1: a fields_ContainsAlignedDNA
	2: a fields_ContigSequence
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string
fields_ContainsAlignedDNA is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	index_in_concatenation has a value which is an int
	beg_pos_in_parent has a value which is an int
	end_pos_in_parent has a value which is an int
	parent_seq_len has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	kb_feature_id has a value which is a string
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int


=end text



=item Description

This relationship connects a nucleotide alignment row to the
contig sequences from which its components are formed.

It has the following fields:

=over 4

=item index_in_concatenation

1-based ordinal position in the alignment row of this nucleotide sequence

=item beg_pos_in_parent

1-based position in the contig sequence of the first nucleotide that appears in the alignment

=item end_pos_in_parent

1-based position in the contig sequence of the last nucleotide that appears in the alignment

=item parent_seq_len

length of original sequence

=item beg_pos_aln

the 1-based column index in the alignment where this nucleotide sequence begins

=item end_pos_aln

the 1-based column index in the alignment where this nucleotide sequence ends

=item kb_feature_id

ID of the feature relevant to this sequence, or an empty string if the sequence is not specific to a genome


=back

=back

=cut

sub get_relationship_ContainsAlignedDNA
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ContainsAlignedDNA:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ContainsAlignedDNA');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ContainsAlignedDNA

    $return = $self->_get_relationship($ctx, 'ContainsAlignedDNA', 'ContainsAlignedDNA', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ContainsAlignedDNA
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ContainsAlignedDNA:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ContainsAlignedDNA');
    }
    return($return);
}




=head2 get_relationship_IsAlignedDNAComponentOf

  $return = $obj->get_relationship_IsAlignedDNAComponentOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ContigSequence
	1: a fields_ContainsAlignedDNA
	2: a fields_AlignmentRow
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int
fields_ContainsAlignedDNA is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	index_in_concatenation has a value which is an int
	beg_pos_in_parent has a value which is an int
	end_pos_in_parent has a value which is an int
	parent_seq_len has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	kb_feature_id has a value which is a string
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ContigSequence
	1: a fields_ContainsAlignedDNA
	2: a fields_AlignmentRow
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int
fields_ContainsAlignedDNA is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	index_in_concatenation has a value which is an int
	beg_pos_in_parent has a value which is an int
	end_pos_in_parent has a value which is an int
	parent_seq_len has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	kb_feature_id has a value which is a string
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsAlignedDNAComponentOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsAlignedDNAComponentOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsAlignedDNAComponentOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsAlignedDNAComponentOf

    $return = $self->_get_relationship($ctx, 'IsAlignedDNAComponentOf', 'ContainsAlignedDNA', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsAlignedDNAComponentOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsAlignedDNAComponentOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsAlignedDNAComponentOf');
    }
    return($return);
}




=head2 get_relationship_ContainsAlignedProtein

  $return = $obj->get_relationship_ContainsAlignedProtein($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AlignmentRow
	1: a fields_ContainsAlignedProtein
	2: a fields_ProteinSequence
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string
fields_ContainsAlignedProtein is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	index_in_concatenation has a value which is an int
	beg_pos_in_parent has a value which is an int
	end_pos_in_parent has a value which is an int
	parent_seq_len has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	kb_feature_id has a value which is a string
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AlignmentRow
	1: a fields_ContainsAlignedProtein
	2: a fields_ProteinSequence
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string
fields_ContainsAlignedProtein is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	index_in_concatenation has a value which is an int
	beg_pos_in_parent has a value which is an int
	end_pos_in_parent has a value which is an int
	parent_seq_len has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	kb_feature_id has a value which is a string
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string


=end text



=item Description

This relationship connects a protein alignment row to the
protein sequences from which its components are formed.

It has the following fields:

=over 4

=item index_in_concatenation

1-based ordinal position in the alignment row of this protein sequence

=item beg_pos_in_parent

1-based position in the protein sequence of the first amino acid that appears in the alignment

=item end_pos_in_parent

1-based position in the protein sequence of the last amino acid that appears in the alignment

=item parent_seq_len

length of original sequence

=item beg_pos_aln

the 1-based column index in the alignment where this protein sequence begins

=item end_pos_aln

the 1-based column index in the alignment where this protein sequence ends

=item kb_feature_id

ID of the feature relevant to this protein, or an empty string if the protein is not specific to a genome


=back

=back

=cut

sub get_relationship_ContainsAlignedProtein
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ContainsAlignedProtein:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ContainsAlignedProtein');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ContainsAlignedProtein

    $return = $self->_get_relationship($ctx, 'ContainsAlignedProtein', 'ContainsAlignedProtein', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ContainsAlignedProtein
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ContainsAlignedProtein:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ContainsAlignedProtein');
    }
    return($return);
}




=head2 get_relationship_IsAlignedProteinComponentOf

  $return = $obj->get_relationship_IsAlignedProteinComponentOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProteinSequence
	1: a fields_ContainsAlignedProtein
	2: a fields_AlignmentRow
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string
fields_ContainsAlignedProtein is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	index_in_concatenation has a value which is an int
	beg_pos_in_parent has a value which is an int
	end_pos_in_parent has a value which is an int
	parent_seq_len has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	kb_feature_id has a value which is a string
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProteinSequence
	1: a fields_ContainsAlignedProtein
	2: a fields_AlignmentRow
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string
fields_ContainsAlignedProtein is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	index_in_concatenation has a value which is an int
	beg_pos_in_parent has a value which is an int
	end_pos_in_parent has a value which is an int
	parent_seq_len has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	kb_feature_id has a value which is a string
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsAlignedProteinComponentOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsAlignedProteinComponentOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsAlignedProteinComponentOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsAlignedProteinComponentOf

    $return = $self->_get_relationship($ctx, 'IsAlignedProteinComponentOf', 'ContainsAlignedProtein', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsAlignedProteinComponentOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsAlignedProteinComponentOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsAlignedProteinComponentOf');
    }
    return($return);
}




=head2 get_relationship_ContainsExperimentalUnit

  $return = $obj->get_relationship_ContainsExperimentalUnit($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnitGroup
	1: a fields_ContainsExperimentalUnit
	2: a fields_ExperimentalUnit
fields_ExperimentalUnitGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	groupType has a value which is a string
fields_ContainsExperimentalUnit is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	location has a value which is a string
	groupMeta has a value which is a string
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnitGroup
	1: a fields_ContainsExperimentalUnit
	2: a fields_ExperimentalUnit
fields_ExperimentalUnitGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	groupType has a value which is a string
fields_ContainsExperimentalUnit is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	location has a value which is a string
	groupMeta has a value which is a string
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description

Experimental units may be collected into groups, such as assay
plates. This relationship describes which experimenal units belong to
which groups.

It has the following fields:

=over 4

=item location

The location, if any, of the experimental unit in the group. Often a plate locator, e.g. 'G11' for 96 well plates.

=item groupMeta

Denotes that the associated ExperimentalUnit's data measures the group as a whole - for example, summary statistics.


=back

=back

=cut

sub get_relationship_ContainsExperimentalUnit
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ContainsExperimentalUnit:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ContainsExperimentalUnit');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ContainsExperimentalUnit

    $return = $self->_get_relationship($ctx, 'ContainsExperimentalUnit', 'ContainsExperimentalUnit', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ContainsExperimentalUnit
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ContainsExperimentalUnit:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ContainsExperimentalUnit');
    }
    return($return);
}




=head2 get_relationship_GroupedBy

  $return = $obj->get_relationship_GroupedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnit
	1: a fields_ContainsExperimentalUnit
	2: a fields_ExperimentalUnitGroup
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_ContainsExperimentalUnit is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	location has a value which is a string
	groupMeta has a value which is a string
fields_ExperimentalUnitGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	groupType has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnit
	1: a fields_ContainsExperimentalUnit
	2: a fields_ExperimentalUnitGroup
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_ContainsExperimentalUnit is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	location has a value which is a string
	groupMeta has a value which is a string
fields_ExperimentalUnitGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	groupType has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_GroupedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_GroupedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_GroupedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_GroupedBy

    $return = $self->_get_relationship($ctx, 'GroupedBy', 'ContainsExperimentalUnit', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_GroupedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_GroupedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_GroupedBy');
    }
    return($return);
}




=head2 get_relationship_Controls

  $return = $obj->get_relationship_Controls($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_Controls
	2: a fields_CoregulatedSet
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_Controls is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_Controls
	2: a fields_CoregulatedSet
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_Controls is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int


=end text



=item Description

This relationship connects a coregulated set to the
features that are used as its transcription factors.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_Controls
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Controls:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Controls');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Controls

    $return = $self->_get_relationship($ctx, 'Controls', 'Controls', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Controls
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Controls:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Controls');
    }
    return($return);
}




=head2 get_relationship_IsControlledUsing

  $return = $obj->get_relationship_IsControlledUsing($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CoregulatedSet
	1: a fields_Controls
	2: a fields_Feature
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int
fields_Controls is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CoregulatedSet
	1: a fields_Controls
	2: a fields_Feature
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int
fields_Controls is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsControlledUsing
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsControlledUsing:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsControlledUsing');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsControlledUsing

    $return = $self->_get_relationship($ctx, 'IsControlledUsing', 'Controls', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsControlledUsing
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsControlledUsing:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsControlledUsing');
    }
    return($return);
}




=head2 get_relationship_DefaultControlSample

  $return = $obj->get_relationship_DefaultControlSample($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_DefaultControlSample
	2: a fields_Sample
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_DefaultControlSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_DefaultControlSample
	2: a fields_Sample
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_DefaultControlSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string


=end text



=item Description

The Default control for samples to compare against.  (Log2 measurments of Test Sample)/(Log2 measurements of Default Control).
Really minus instead of divide since the values are already in Log2 Space.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_DefaultControlSample
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_DefaultControlSample:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DefaultControlSample');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_DefaultControlSample

    $return = $self->_get_relationship($ctx, 'DefaultControlSample', 'DefaultControlSample', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_DefaultControlSample
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_DefaultControlSample:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DefaultControlSample');
    }
    return($return);
}




=head2 get_relationship_SamplesDefaultControl

  $return = $obj->get_relationship_SamplesDefaultControl($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_DefaultControlSample
	2: a fields_Sample
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_DefaultControlSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_DefaultControlSample
	2: a fields_Sample
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_DefaultControlSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_SamplesDefaultControl
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SamplesDefaultControl:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SamplesDefaultControl');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SamplesDefaultControl

    $return = $self->_get_relationship($ctx, 'SamplesDefaultControl', 'DefaultControlSample', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SamplesDefaultControl
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SamplesDefaultControl:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SamplesDefaultControl');
    }
    return($return);
}




=head2 get_relationship_Describes

  $return = $obj->get_relationship_Describes($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Subsystem
	1: a fields_Describes
	2: a fields_Variant
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int
fields_Describes is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Variant is a reference to a hash where the following keys are defined:
	id has a value which is a string
	role_rule has a value which is a reference to a list where each element is a string
	code has a value which is a string
	type has a value which is a string
	comment has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Subsystem
	1: a fields_Describes
	2: a fields_Variant
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int
fields_Describes is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Variant is a reference to a hash where the following keys are defined:
	id has a value which is a string
	role_rule has a value which is a reference to a list where each element is a string
	code has a value which is a string
	type has a value which is a string
	comment has a value which is a string


=end text



=item Description

This relationship connects a subsystem to the individual
variants used to implement it. Each variant contains a slightly
different subset of the roles in the parent subsystem.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_Describes
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Describes:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Describes');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Describes

    $return = $self->_get_relationship($ctx, 'Describes', 'Describes', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Describes
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Describes:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Describes');
    }
    return($return);
}




=head2 get_relationship_IsDescribedBy

  $return = $obj->get_relationship_IsDescribedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Variant
	1: a fields_Describes
	2: a fields_Subsystem
fields_Variant is a reference to a hash where the following keys are defined:
	id has a value which is a string
	role_rule has a value which is a reference to a list where each element is a string
	code has a value which is a string
	type has a value which is a string
	comment has a value which is a string
fields_Describes is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Variant
	1: a fields_Describes
	2: a fields_Subsystem
fields_Variant is a reference to a hash where the following keys are defined:
	id has a value which is a string
	role_rule has a value which is a reference to a list where each element is a string
	code has a value which is a string
	type has a value which is a string
	comment has a value which is a string
fields_Describes is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_IsDescribedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsDescribedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsDescribedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsDescribedBy

    $return = $self->_get_relationship($ctx, 'IsDescribedBy', 'Describes', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsDescribedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsDescribedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsDescribedBy');
    }
    return($return);
}




=head2 get_relationship_DescribesAlignment

  $return = $obj->get_relationship_DescribesAlignment($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AlignmentAttribute
	1: a fields_DescribesAlignment
	2: a fields_Alignment
fields_AlignmentAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_DescribesAlignment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AlignmentAttribute
	1: a fields_DescribesAlignment
	2: a fields_Alignment
fields_AlignmentAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_DescribesAlignment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string


=end text



=item Description

This relationship connects an alignment to its free-form
attributes.

It has the following fields:

=over 4

=item value

value of this attribute


=back

=back

=cut

sub get_relationship_DescribesAlignment
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_DescribesAlignment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DescribesAlignment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_DescribesAlignment

    $return = $self->_get_relationship($ctx, 'DescribesAlignment', 'DescribesAlignment', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_DescribesAlignment
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_DescribesAlignment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DescribesAlignment');
    }
    return($return);
}




=head2 get_relationship_HasAlignmentAttribute

  $return = $obj->get_relationship_HasAlignmentAttribute($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_DescribesAlignment
	2: a fields_AlignmentAttribute
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_DescribesAlignment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_AlignmentAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_DescribesAlignment
	2: a fields_AlignmentAttribute
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_DescribesAlignment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_AlignmentAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasAlignmentAttribute
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasAlignmentAttribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasAlignmentAttribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasAlignmentAttribute

    $return = $self->_get_relationship($ctx, 'HasAlignmentAttribute', 'DescribesAlignment', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasAlignmentAttribute
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasAlignmentAttribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasAlignmentAttribute');
    }
    return($return);
}




=head2 get_relationship_DescribesMeasurement

  $return = $obj->get_relationship_DescribesMeasurement($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_MeasurementDescription
	1: a fields_DescribesMeasurement
	2: a fields_Measurement
fields_MeasurementDescription is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	unitOfMeasure has a value which is a string
	category has a value which is a string
	source_id has a value which is a string
fields_DescribesMeasurement is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_MeasurementDescription
	1: a fields_DescribesMeasurement
	2: a fields_Measurement
fields_MeasurementDescription is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	unitOfMeasure has a value which is a string
	category has a value which is a string
	source_id has a value which is a string
fields_DescribesMeasurement is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float


=end text



=item Description

The DescribesMeasurement relationship specifies a description
for a particular measurement.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_DescribesMeasurement
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_DescribesMeasurement:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DescribesMeasurement');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_DescribesMeasurement

    $return = $self->_get_relationship($ctx, 'DescribesMeasurement', 'DescribesMeasurement', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_DescribesMeasurement
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_DescribesMeasurement:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DescribesMeasurement');
    }
    return($return);
}




=head2 get_relationship_IsDefinedBy

  $return = $obj->get_relationship_IsDefinedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Measurement
	1: a fields_DescribesMeasurement
	2: a fields_MeasurementDescription
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float
fields_DescribesMeasurement is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_MeasurementDescription is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	unitOfMeasure has a value which is a string
	category has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Measurement
	1: a fields_DescribesMeasurement
	2: a fields_MeasurementDescription
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float
fields_DescribesMeasurement is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_MeasurementDescription is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	unitOfMeasure has a value which is a string
	category has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsDefinedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsDefinedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsDefinedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsDefinedBy

    $return = $self->_get_relationship($ctx, 'IsDefinedBy', 'DescribesMeasurement', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsDefinedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsDefinedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsDefinedBy');
    }
    return($return);
}




=head2 get_relationship_DescribesTree

  $return = $obj->get_relationship_DescribesTree($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_TreeAttribute
	1: a fields_DescribesTree
	2: a fields_Tree
fields_TreeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_DescribesTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_TreeAttribute
	1: a fields_DescribesTree
	2: a fields_Tree
fields_TreeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_DescribesTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string


=end text



=item Description

This relationship connects a tree to its free-form
attributes.

It has the following fields:

=over 4

=item value

value of this attribute


=back

=back

=cut

sub get_relationship_DescribesTree
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_DescribesTree:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DescribesTree');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_DescribesTree

    $return = $self->_get_relationship($ctx, 'DescribesTree', 'DescribesTree', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_DescribesTree
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_DescribesTree:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DescribesTree');
    }
    return($return);
}




=head2 get_relationship_HasTreeAttribute

  $return = $obj->get_relationship_HasTreeAttribute($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_DescribesTree
	2: a fields_TreeAttribute
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_DescribesTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_TreeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_DescribesTree
	2: a fields_TreeAttribute
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_DescribesTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_TreeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasTreeAttribute
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasTreeAttribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasTreeAttribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasTreeAttribute

    $return = $self->_get_relationship($ctx, 'HasTreeAttribute', 'DescribesTree', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasTreeAttribute
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasTreeAttribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasTreeAttribute');
    }
    return($return);
}




=head2 get_relationship_DescribesTreeNode

  $return = $obj->get_relationship_DescribesTreeNode($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_TreeNodeAttribute
	1: a fields_DescribesTreeNode
	2: a fields_Tree
fields_TreeNodeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_DescribesTreeNode is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
	node_id has a value which is a string
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_TreeNodeAttribute
	1: a fields_DescribesTreeNode
	2: a fields_Tree
fields_TreeNodeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_DescribesTreeNode is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
	node_id has a value which is a string
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string


=end text



=item Description

This relationship connects an tree to the free-form
attributes of its nodes.

It has the following fields:

=over 4

=item value

value of this attribute

=item node_id

ID of the node described by the attribute


=back

=back

=cut

sub get_relationship_DescribesTreeNode
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_DescribesTreeNode:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DescribesTreeNode');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_DescribesTreeNode

    $return = $self->_get_relationship($ctx, 'DescribesTreeNode', 'DescribesTreeNode', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_DescribesTreeNode
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_DescribesTreeNode:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DescribesTreeNode');
    }
    return($return);
}




=head2 get_relationship_HasNodeAttribute

  $return = $obj->get_relationship_HasNodeAttribute($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_DescribesTreeNode
	2: a fields_TreeNodeAttribute
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_DescribesTreeNode is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
	node_id has a value which is a string
fields_TreeNodeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_DescribesTreeNode
	2: a fields_TreeNodeAttribute
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_DescribesTreeNode is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
	node_id has a value which is a string
fields_TreeNodeAttribute is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasNodeAttribute
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasNodeAttribute:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasNodeAttribute');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasNodeAttribute

    $return = $self->_get_relationship($ctx, 'HasNodeAttribute', 'DescribesTreeNode', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasNodeAttribute
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasNodeAttribute:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasNodeAttribute');
    }
    return($return);
}




=head2 get_relationship_DetectedWithMethod

  $return = $obj->get_relationship_DetectedWithMethod($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AssociationDetectionType
	1: a fields_DetectedWithMethod
	2: a fields_Association
fields_AssociationDetectionType is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_DetectedWithMethod is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AssociationDetectionType
	1: a fields_DetectedWithMethod
	2: a fields_Association
fields_AssociationDetectionType is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_DetectedWithMethod is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string


=end text



=item Description

The DetectedWithMethod relationship describes which
protein-protein associations were detected or annotated by
particular methods

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_DetectedWithMethod
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_DetectedWithMethod:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DetectedWithMethod');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_DetectedWithMethod

    $return = $self->_get_relationship($ctx, 'DetectedWithMethod', 'DetectedWithMethod', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_DetectedWithMethod
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_DetectedWithMethod:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DetectedWithMethod');
    }
    return($return);
}




=head2 get_relationship_DetectedBy

  $return = $obj->get_relationship_DetectedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Association
	1: a fields_DetectedWithMethod
	2: a fields_AssociationDetectionType
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string
fields_DetectedWithMethod is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_AssociationDetectionType is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Association
	1: a fields_DetectedWithMethod
	2: a fields_AssociationDetectionType
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string
fields_DetectedWithMethod is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_AssociationDetectionType is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_DetectedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_DetectedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DetectedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_DetectedBy

    $return = $self->_get_relationship($ctx, 'DetectedBy', 'DetectedWithMethod', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_DetectedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_DetectedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DetectedBy');
    }
    return($return);
}




=head2 get_relationship_Displays

  $return = $obj->get_relationship_Displays($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Diagram
	1: a fields_Displays
	2: a fields_Reaction
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string
fields_Displays is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	location has a value which is a rectangle
rectangle is a string
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Diagram
	1: a fields_Displays
	2: a fields_Reaction
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string
fields_Displays is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	location has a value which is a rectangle
rectangle is a string
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string


=end text



=item Description

This relationship connects a diagram to its reactions. A
diagram shows multiple reactions, and a reaction can be on many
diagrams.

It has the following fields:

=over 4

=item location

Location of the reaction's node on the diagram.


=back

=back

=cut

sub get_relationship_Displays
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Displays:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Displays');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Displays

    $return = $self->_get_relationship($ctx, 'Displays', 'Displays', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Displays
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Displays:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Displays');
    }
    return($return);
}




=head2 get_relationship_IsDisplayedOn

  $return = $obj->get_relationship_IsDisplayedOn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Reaction
	1: a fields_Displays
	2: a fields_Diagram
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string
fields_Displays is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	location has a value which is a rectangle
rectangle is a string
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Reaction
	1: a fields_Displays
	2: a fields_Diagram
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string
fields_Displays is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	location has a value which is a rectangle
rectangle is a string
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsDisplayedOn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsDisplayedOn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsDisplayedOn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsDisplayedOn

    $return = $self->_get_relationship($ctx, 'IsDisplayedOn', 'Displays', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsDisplayedOn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsDisplayedOn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsDisplayedOn');
    }
    return($return);
}




=head2 get_relationship_Encompasses

  $return = $obj->get_relationship_Encompasses($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_Encompasses
	2: a fields_Feature
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_Encompasses is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_Encompasses
	2: a fields_Feature
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_Encompasses is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string


=end text



=item Description

This relationship connects a feature to a related
feature; for example, it would connect a gene to its
constituent splice variants, and the splice variants to their
exons.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_Encompasses
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Encompasses:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Encompasses');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Encompasses

    $return = $self->_get_relationship($ctx, 'Encompasses', 'Encompasses', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Encompasses
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Encompasses:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Encompasses');
    }
    return($return);
}




=head2 get_relationship_IsEncompassedIn

  $return = $obj->get_relationship_IsEncompassedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_Encompasses
	2: a fields_Feature
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_Encompasses is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_Encompasses
	2: a fields_Feature
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_Encompasses is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsEncompassedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsEncompassedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsEncompassedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsEncompassedIn

    $return = $self->_get_relationship($ctx, 'IsEncompassedIn', 'Encompasses', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsEncompassedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsEncompassedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsEncompassedIn');
    }
    return($return);
}




=head2 get_relationship_EvaluatedIn

  $return = $obj->get_relationship_EvaluatedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Strain
	1: a fields_EvaluatedIn
	2: a fields_ExperimentalUnit
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string
fields_EvaluatedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Strain
	1: a fields_EvaluatedIn
	2: a fields_ExperimentalUnit
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string
fields_EvaluatedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description

The EvaluatedIn relationship specifies the experimental
units performed on a particular strain.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_EvaluatedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_EvaluatedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_EvaluatedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_EvaluatedIn

    $return = $self->_get_relationship($ctx, 'EvaluatedIn', 'EvaluatedIn', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_EvaluatedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_EvaluatedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_EvaluatedIn');
    }
    return($return);
}




=head2 get_relationship_IncludesStrain

  $return = $obj->get_relationship_IncludesStrain($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnit
	1: a fields_EvaluatedIn
	2: a fields_Strain
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_EvaluatedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnit
	1: a fields_EvaluatedIn
	2: a fields_Strain
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_EvaluatedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IncludesStrain
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IncludesStrain:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IncludesStrain');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IncludesStrain

    $return = $self->_get_relationship($ctx, 'IncludesStrain', 'EvaluatedIn', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IncludesStrain
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IncludesStrain:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IncludesStrain');
    }
    return($return);
}




=head2 get_relationship_FeatureIsTranscriptionFactorFor

  $return = $obj->get_relationship_FeatureIsTranscriptionFactorFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_FeatureIsTranscriptionFactorFor
	2: a fields_Regulon
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_FeatureIsTranscriptionFactorFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_FeatureIsTranscriptionFactorFor
	2: a fields_Regulon
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_FeatureIsTranscriptionFactorFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_FeatureIsTranscriptionFactorFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_FeatureIsTranscriptionFactorFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_FeatureIsTranscriptionFactorFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_FeatureIsTranscriptionFactorFor

    $return = $self->_get_relationship($ctx, 'FeatureIsTranscriptionFactorFor', 'FeatureIsTranscriptionFactorFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_FeatureIsTranscriptionFactorFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_FeatureIsTranscriptionFactorFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_FeatureIsTranscriptionFactorFor');
    }
    return($return);
}




=head2 get_relationship_HasTranscriptionFactorFeature

  $return = $obj->get_relationship_HasTranscriptionFactorFeature($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulon
	1: a fields_FeatureIsTranscriptionFactorFor
	2: a fields_Feature
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_FeatureIsTranscriptionFactorFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulon
	1: a fields_FeatureIsTranscriptionFactorFor
	2: a fields_Feature
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_FeatureIsTranscriptionFactorFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasTranscriptionFactorFeature
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasTranscriptionFactorFeature:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasTranscriptionFactorFeature');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasTranscriptionFactorFeature

    $return = $self->_get_relationship($ctx, 'HasTranscriptionFactorFeature', 'FeatureIsTranscriptionFactorFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasTranscriptionFactorFeature
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasTranscriptionFactorFeature:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasTranscriptionFactorFeature');
    }
    return($return);
}




=head2 get_relationship_FeatureMeasuredBy

  $return = $obj->get_relationship_FeatureMeasuredBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_FeatureMeasuredBy
	2: a fields_Measurement
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_FeatureMeasuredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_FeatureMeasuredBy
	2: a fields_Measurement
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_FeatureMeasuredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float


=end text



=item Description

Denotes the feature that a measurement quantifies.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_FeatureMeasuredBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_FeatureMeasuredBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_FeatureMeasuredBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_FeatureMeasuredBy

    $return = $self->_get_relationship($ctx, 'FeatureMeasuredBy', 'FeatureMeasuredBy', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_FeatureMeasuredBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_FeatureMeasuredBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_FeatureMeasuredBy');
    }
    return($return);
}




=head2 get_relationship_MeasuresFeature

  $return = $obj->get_relationship_MeasuresFeature($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Measurement
	1: a fields_FeatureMeasuredBy
	2: a fields_Feature
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float
fields_FeatureMeasuredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Measurement
	1: a fields_FeatureMeasuredBy
	2: a fields_Feature
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float
fields_FeatureMeasuredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_MeasuresFeature
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_MeasuresFeature:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_MeasuresFeature');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_MeasuresFeature

    $return = $self->_get_relationship($ctx, 'MeasuresFeature', 'FeatureMeasuredBy', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_MeasuresFeature
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_MeasuresFeature:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_MeasuresFeature');
    }
    return($return);
}




=head2 get_relationship_Formulated

  $return = $obj->get_relationship_Formulated($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_Formulated
	2: a fields_CoregulatedSet
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_Formulated is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_Formulated
	2: a fields_CoregulatedSet
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_Formulated is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int


=end text



=item Description

This relationship connects a coregulated set to the
source organization that originally computed it.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_Formulated
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Formulated:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Formulated');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Formulated

    $return = $self->_get_relationship($ctx, 'Formulated', 'Formulated', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Formulated
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Formulated:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Formulated');
    }
    return($return);
}




=head2 get_relationship_WasFormulatedBy

  $return = $obj->get_relationship_WasFormulatedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CoregulatedSet
	1: a fields_Formulated
	2: a fields_Source
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int
fields_Formulated is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CoregulatedSet
	1: a fields_Formulated
	2: a fields_Source
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int
fields_Formulated is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_WasFormulatedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_WasFormulatedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_WasFormulatedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_WasFormulatedBy

    $return = $self->_get_relationship($ctx, 'WasFormulatedBy', 'Formulated', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_WasFormulatedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_WasFormulatedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_WasFormulatedBy');
    }
    return($return);
}




=head2 get_relationship_GeneratedLevelsFor

  $return = $obj->get_relationship_GeneratedLevelsFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProbeSet
	1: a fields_GeneratedLevelsFor
	2: a fields_AtomicRegulon
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_GeneratedLevelsFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	level_vector has a value which is a countVector
countVector is a string
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProbeSet
	1: a fields_GeneratedLevelsFor
	2: a fields_AtomicRegulon
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_GeneratedLevelsFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	level_vector has a value which is a countVector
countVector is a string
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

This relationship connects an atomic regulon to a probe set from which experimental
data was produced for its features. It contains a vector of the expression levels.

It has the following fields:

=over 4

=item level_vector

Vector of expression levels (-1, 0, 1) for the experiments, in sequence order.


=back

=back

=cut

sub get_relationship_GeneratedLevelsFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_GeneratedLevelsFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_GeneratedLevelsFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_GeneratedLevelsFor

    $return = $self->_get_relationship($ctx, 'GeneratedLevelsFor', 'GeneratedLevelsFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_GeneratedLevelsFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_GeneratedLevelsFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_GeneratedLevelsFor');
    }
    return($return);
}




=head2 get_relationship_WasGeneratedFrom

  $return = $obj->get_relationship_WasGeneratedFrom($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AtomicRegulon
	1: a fields_GeneratedLevelsFor
	2: a fields_ProbeSet
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_GeneratedLevelsFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	level_vector has a value which is a countVector
countVector is a string
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AtomicRegulon
	1: a fields_GeneratedLevelsFor
	2: a fields_ProbeSet
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_GeneratedLevelsFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	level_vector has a value which is a countVector
countVector is a string
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_WasGeneratedFrom
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_WasGeneratedFrom:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_WasGeneratedFrom');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_WasGeneratedFrom

    $return = $self->_get_relationship($ctx, 'WasGeneratedFrom', 'GeneratedLevelsFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_WasGeneratedFrom
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_WasGeneratedFrom:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_WasGeneratedFrom');
    }
    return($return);
}




=head2 get_relationship_GenomeParentOf

  $return = $obj->get_relationship_GenomeParentOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_GenomeParentOf
	2: a fields_Strain
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_GenomeParentOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_GenomeParentOf
	2: a fields_Strain
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_GenomeParentOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string


=end text



=item Description

The GenomeParentOf relationship specifies the direct child
strains of a specific genome.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_GenomeParentOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_GenomeParentOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_GenomeParentOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_GenomeParentOf

    $return = $self->_get_relationship($ctx, 'GenomeParentOf', 'GenomeParentOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_GenomeParentOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_GenomeParentOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_GenomeParentOf');
    }
    return($return);
}




=head2 get_relationship_DerivedFromGenome

  $return = $obj->get_relationship_DerivedFromGenome($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Strain
	1: a fields_GenomeParentOf
	2: a fields_Genome
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string
fields_GenomeParentOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Strain
	1: a fields_GenomeParentOf
	2: a fields_Genome
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string
fields_GenomeParentOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_DerivedFromGenome
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_DerivedFromGenome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DerivedFromGenome');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_DerivedFromGenome

    $return = $self->_get_relationship($ctx, 'DerivedFromGenome', 'GenomeParentOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_DerivedFromGenome
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_DerivedFromGenome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DerivedFromGenome');
    }
    return($return);
}




=head2 get_relationship_HasAliasAssertedFrom

  $return = $obj->get_relationship_HasAliasAssertedFrom($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_HasAliasAssertedFrom
	2: a fields_Source
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_HasAliasAssertedFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	alias has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_HasAliasAssertedFrom
	2: a fields_Source
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_HasAliasAssertedFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	alias has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string


=end text



=item Description

A Source may assert aliases for features.

It has the following fields:

=over 4

=item alias

text of the alias for the feature.


=back

=back

=cut

sub get_relationship_HasAliasAssertedFrom
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasAliasAssertedFrom:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasAliasAssertedFrom');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasAliasAssertedFrom

    $return = $self->_get_relationship($ctx, 'HasAliasAssertedFrom', 'HasAliasAssertedFrom', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasAliasAssertedFrom
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasAliasAssertedFrom:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasAliasAssertedFrom');
    }
    return($return);
}




=head2 get_relationship_AssertsAliasFor

  $return = $obj->get_relationship_AssertsAliasFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_HasAliasAssertedFrom
	2: a fields_Feature
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_HasAliasAssertedFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	alias has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_HasAliasAssertedFrom
	2: a fields_Feature
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_HasAliasAssertedFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	alias has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_AssertsAliasFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_AssertsAliasFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AssertsAliasFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_AssertsAliasFor

    $return = $self->_get_relationship($ctx, 'AssertsAliasFor', 'HasAliasAssertedFrom', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_AssertsAliasFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_AssertsAliasFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AssertsAliasFor');
    }
    return($return);
}




=head2 get_relationship_HasCompoundAliasFrom

  $return = $obj->get_relationship_HasCompoundAliasFrom($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_HasCompoundAliasFrom
	2: a fields_Compound
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_HasCompoundAliasFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	alias has a value which is a string
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_HasCompoundAliasFrom
	2: a fields_Compound
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_HasCompoundAliasFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	alias has a value which is a string
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float


=end text



=item Description

This relationship connects a source (database or organization)
with the compounds for which it has assigned names (aliases).
The alias itself is stored as intersection data.

It has the following fields:

=over 4

=item alias

alias for the compound assigned by the source


=back

=back

=cut

sub get_relationship_HasCompoundAliasFrom
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasCompoundAliasFrom:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasCompoundAliasFrom');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasCompoundAliasFrom

    $return = $self->_get_relationship($ctx, 'HasCompoundAliasFrom', 'HasCompoundAliasFrom', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasCompoundAliasFrom
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasCompoundAliasFrom:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasCompoundAliasFrom');
    }
    return($return);
}




=head2 get_relationship_UsesAliasForCompound

  $return = $obj->get_relationship_UsesAliasForCompound($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_HasCompoundAliasFrom
	2: a fields_Source
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_HasCompoundAliasFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	alias has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_HasCompoundAliasFrom
	2: a fields_Source
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_HasCompoundAliasFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	alias has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_UsesAliasForCompound
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_UsesAliasForCompound:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_UsesAliasForCompound');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_UsesAliasForCompound

    $return = $self->_get_relationship($ctx, 'UsesAliasForCompound', 'HasCompoundAliasFrom', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_UsesAliasForCompound
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_UsesAliasForCompound:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_UsesAliasForCompound');
    }
    return($return);
}




=head2 get_relationship_HasEffector

  $return = $obj->get_relationship_HasEffector($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulon
	1: a fields_HasEffector
	2: a fields_Effector
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_HasEffector is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Effector is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	effector_class has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulon
	1: a fields_HasEffector
	2: a fields_Effector
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_HasEffector is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Effector is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	effector_class has a value which is a string


=end text



=item Description

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_HasEffector
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasEffector:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasEffector');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasEffector

    $return = $self->_get_relationship($ctx, 'HasEffector', 'HasEffector', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasEffector
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasEffector:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasEffector');
    }
    return($return);
}




=head2 get_relationship_IsEffectorFor

  $return = $obj->get_relationship_IsEffectorFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Effector
	1: a fields_HasEffector
	2: a fields_Regulon
fields_Effector is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	effector_class has a value which is a string
fields_HasEffector is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Effector
	1: a fields_HasEffector
	2: a fields_Regulon
fields_Effector is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	effector_class has a value which is a string
fields_HasEffector is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsEffectorFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsEffectorFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsEffectorFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsEffectorFor

    $return = $self->_get_relationship($ctx, 'IsEffectorFor', 'HasEffector', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsEffectorFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsEffectorFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsEffectorFor');
    }
    return($return);
}




=head2 get_relationship_HasExperimentalUnit

  $return = $obj->get_relationship_HasExperimentalUnit($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentMeta
	1: a fields_HasExperimentalUnit
	2: a fields_ExperimentalUnit
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string
fields_HasExperimentalUnit is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentMeta
	1: a fields_HasExperimentalUnit
	2: a fields_ExperimentalUnit
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string
fields_HasExperimentalUnit is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description

The HasExperimentalUnit relationship describes which
ExperimentalUnits are part of a Experiment.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_HasExperimentalUnit
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasExperimentalUnit:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasExperimentalUnit');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasExperimentalUnit

    $return = $self->_get_relationship($ctx, 'HasExperimentalUnit', 'HasExperimentalUnit', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasExperimentalUnit
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasExperimentalUnit:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasExperimentalUnit');
    }
    return($return);
}




=head2 get_relationship_IsExperimentalUnitOf

  $return = $obj->get_relationship_IsExperimentalUnitOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnit
	1: a fields_HasExperimentalUnit
	2: a fields_ExperimentMeta
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_HasExperimentalUnit is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnit
	1: a fields_HasExperimentalUnit
	2: a fields_ExperimentMeta
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_HasExperimentalUnit is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsExperimentalUnitOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsExperimentalUnitOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsExperimentalUnitOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsExperimentalUnitOf

    $return = $self->_get_relationship($ctx, 'IsExperimentalUnitOf', 'HasExperimentalUnit', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsExperimentalUnitOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsExperimentalUnitOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsExperimentalUnitOf');
    }
    return($return);
}




=head2 get_relationship_HasExpressionSample

  $return = $obj->get_relationship_HasExpressionSample($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnit
	1: a fields_HasExpressionSample
	2: a fields_Sample
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_HasExpressionSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnit
	1: a fields_HasExpressionSample
	2: a fields_Sample
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_HasExpressionSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int


=end text



=item Description

This relationship indicating the expression samples for an experimental unit.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_HasExpressionSample
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasExpressionSample:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasExpressionSample');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasExpressionSample

    $return = $self->_get_relationship($ctx, 'HasExpressionSample', 'HasExpressionSample', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasExpressionSample
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasExpressionSample:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasExpressionSample');
    }
    return($return);
}




=head2 get_relationship_SampleBelongsToExperimentalUnit

  $return = $obj->get_relationship_SampleBelongsToExperimentalUnit($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_HasExpressionSample
	2: a fields_ExperimentalUnit
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_HasExpressionSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_HasExpressionSample
	2: a fields_ExperimentalUnit
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_HasExpressionSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_SampleBelongsToExperimentalUnit
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SampleBelongsToExperimentalUnit:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleBelongsToExperimentalUnit');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SampleBelongsToExperimentalUnit

    $return = $self->_get_relationship($ctx, 'SampleBelongsToExperimentalUnit', 'HasExpressionSample', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SampleBelongsToExperimentalUnit
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SampleBelongsToExperimentalUnit:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleBelongsToExperimentalUnit');
    }
    return($return);
}




=head2 get_relationship_HasGenomes

  $return = $obj->get_relationship_HasGenomes($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_RegulogCollection
	1: a fields_HasGenomes
	2: a fields_Genome
fields_RegulogCollection is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
fields_HasGenomes is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_RegulogCollection
	1: a fields_HasGenomes
	2: a fields_Genome
fields_RegulogCollection is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
fields_HasGenomes is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_HasGenomes
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasGenomes:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasGenomes');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasGenomes

    $return = $self->_get_relationship($ctx, 'HasGenomes', 'HasGenomes', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasGenomes
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasGenomes:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasGenomes');
    }
    return($return);
}




=head2 get_relationship_IsInRegulogCollection

  $return = $obj->get_relationship_IsInRegulogCollection($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_HasGenomes
	2: a fields_RegulogCollection
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_HasGenomes is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_RegulogCollection is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_HasGenomes
	2: a fields_RegulogCollection
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_HasGenomes is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_RegulogCollection is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsInRegulogCollection
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsInRegulogCollection:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInRegulogCollection');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsInRegulogCollection

    $return = $self->_get_relationship($ctx, 'IsInRegulogCollection', 'HasGenomes', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsInRegulogCollection
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsInRegulogCollection:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInRegulogCollection');
    }
    return($return);
}




=head2 get_relationship_HasIndicatedSignalFrom

  $return = $obj->get_relationship_HasIndicatedSignalFrom($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_HasIndicatedSignalFrom
	2: a fields_Experiment
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_HasIndicatedSignalFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	rma_value has a value which is a float
	level has a value which is an int
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_HasIndicatedSignalFrom
	2: a fields_Experiment
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_HasIndicatedSignalFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	rma_value has a value which is a float
	level has a value which is an int
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string


=end text



=item Description

This relationship connects an experiment to a feature. The feature
expression levels inferred from the experimental results are stored here.

It has the following fields:

=over 4

=item rma_value

Normalized expression value for this feature under the experiment's conditions.

=item level

Indication of whether the feature is expressed (1), not expressed (-1), or unknown (0).


=back

=back

=cut

sub get_relationship_HasIndicatedSignalFrom
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasIndicatedSignalFrom:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasIndicatedSignalFrom');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasIndicatedSignalFrom

    $return = $self->_get_relationship($ctx, 'HasIndicatedSignalFrom', 'HasIndicatedSignalFrom', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasIndicatedSignalFrom
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasIndicatedSignalFrom:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasIndicatedSignalFrom');
    }
    return($return);
}




=head2 get_relationship_IndicatesSignalFor

  $return = $obj->get_relationship_IndicatesSignalFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Experiment
	1: a fields_HasIndicatedSignalFrom
	2: a fields_Feature
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string
fields_HasIndicatedSignalFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	rma_value has a value which is a float
	level has a value which is an int
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Experiment
	1: a fields_HasIndicatedSignalFrom
	2: a fields_Feature
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string
fields_HasIndicatedSignalFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	rma_value has a value which is a float
	level has a value which is an int
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_IndicatesSignalFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IndicatesSignalFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IndicatesSignalFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IndicatesSignalFor

    $return = $self->_get_relationship($ctx, 'IndicatesSignalFor', 'HasIndicatedSignalFrom', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IndicatesSignalFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IndicatesSignalFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IndicatesSignalFor');
    }
    return($return);
}




=head2 get_relationship_HasKnockoutIn

  $return = $obj->get_relationship_HasKnockoutIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Strain
	1: a fields_HasKnockoutIn
	2: a fields_Feature
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string
fields_HasKnockoutIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Strain
	1: a fields_HasKnockoutIn
	2: a fields_Feature
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string
fields_HasKnockoutIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description

The HasKnockoutIn relationship specifies the gene knockouts in
a particular strain.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_HasKnockoutIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasKnockoutIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasKnockoutIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasKnockoutIn

    $return = $self->_get_relationship($ctx, 'HasKnockoutIn', 'HasKnockoutIn', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasKnockoutIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasKnockoutIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasKnockoutIn');
    }
    return($return);
}




=head2 get_relationship_KnockedOutIn

  $return = $obj->get_relationship_KnockedOutIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_HasKnockoutIn
	2: a fields_Strain
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_HasKnockoutIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_HasKnockoutIn
	2: a fields_Strain
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_HasKnockoutIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_KnockedOutIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_KnockedOutIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_KnockedOutIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_KnockedOutIn

    $return = $self->_get_relationship($ctx, 'KnockedOutIn', 'HasKnockoutIn', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_KnockedOutIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_KnockedOutIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_KnockedOutIn');
    }
    return($return);
}




=head2 get_relationship_HasMeasurement

  $return = $obj->get_relationship_HasMeasurement($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnit
	1: a fields_HasMeasurement
	2: a fields_Measurement
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_HasMeasurement is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnit
	1: a fields_HasMeasurement
	2: a fields_Measurement
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_HasMeasurement is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float


=end text



=item Description

The HasMeasurement relationship specifies a measurement(s)
performed on a particular experimental unit.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_HasMeasurement
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasMeasurement:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasMeasurement');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasMeasurement

    $return = $self->_get_relationship($ctx, 'HasMeasurement', 'HasMeasurement', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasMeasurement
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasMeasurement:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasMeasurement');
    }
    return($return);
}




=head2 get_relationship_IsMeasureOf

  $return = $obj->get_relationship_IsMeasureOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Measurement
	1: a fields_HasMeasurement
	2: a fields_ExperimentalUnit
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float
fields_HasMeasurement is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Measurement
	1: a fields_HasMeasurement
	2: a fields_ExperimentalUnit
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float
fields_HasMeasurement is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsMeasureOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsMeasureOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsMeasureOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsMeasureOf

    $return = $self->_get_relationship($ctx, 'IsMeasureOf', 'HasMeasurement', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsMeasureOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsMeasureOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsMeasureOf');
    }
    return($return);
}




=head2 get_relationship_HasMember

  $return = $obj->get_relationship_HasMember($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Family
	1: a fields_HasMember
	2: a fields_Feature
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string
fields_HasMember is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Family
	1: a fields_HasMember
	2: a fields_Feature
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string
fields_HasMember is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description

This relationship connects each feature family to its
constituent features. A family always has many features, and a
single feature can be found in many families.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_HasMember
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasMember:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasMember');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasMember

    $return = $self->_get_relationship($ctx, 'HasMember', 'HasMember', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasMember
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasMember:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasMember');
    }
    return($return);
}




=head2 get_relationship_IsMemberOf

  $return = $obj->get_relationship_IsMemberOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_HasMember
	2: a fields_Family
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_HasMember is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_HasMember
	2: a fields_Family
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_HasMember is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsMemberOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsMemberOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsMemberOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsMemberOf

    $return = $self->_get_relationship($ctx, 'IsMemberOf', 'HasMember', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsMemberOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsMemberOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsMemberOf');
    }
    return($return);
}




=head2 get_relationship_HasParameter

  $return = $obj->get_relationship_HasParameter($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Environment
	1: a fields_HasParameter
	2: a fields_Parameter
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string
fields_HasParameter is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_Parameter is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Environment
	1: a fields_HasParameter
	2: a fields_Parameter
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string
fields_HasParameter is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_Parameter is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

This relationship denotes which parameters each environment has,
as well as the value of the parameter.

It has the following fields:

=over 4

=item value

The value of the parameter.


=back

=back

=cut

sub get_relationship_HasParameter
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasParameter:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasParameter');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasParameter

    $return = $self->_get_relationship($ctx, 'HasParameter', 'HasParameter', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasParameter
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasParameter:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasParameter');
    }
    return($return);
}




=head2 get_relationship_OfEnvironment

  $return = $obj->get_relationship_OfEnvironment($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Parameter
	1: a fields_HasParameter
	2: a fields_Environment
fields_Parameter is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_HasParameter is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Parameter
	1: a fields_HasParameter
	2: a fields_Environment
fields_Parameter is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_HasParameter is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_OfEnvironment
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_OfEnvironment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_OfEnvironment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_OfEnvironment

    $return = $self->_get_relationship($ctx, 'OfEnvironment', 'HasParameter', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_OfEnvironment
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_OfEnvironment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_OfEnvironment');
    }
    return($return);
}




=head2 get_relationship_HasParticipant

  $return = $obj->get_relationship_HasParticipant($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Scenario
	1: a fields_HasParticipant
	2: a fields_Reaction
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string
fields_HasParticipant is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
	type has a value which is an int
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Scenario
	1: a fields_HasParticipant
	2: a fields_Reaction
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string
fields_HasParticipant is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
	type has a value which is an int
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string


=end text



=item Description

A scenario consists of many participant reactions that
convert the input compounds to output compounds. A single reaction
may participate in many scenarios.

It has the following fields:

=over 4

=item type

Indicates the type of participaton. If 0, the reaction is in the main pathway of the scenario. If 1, the reaction is necessary to make the model work but is not in the subsystem. If 2, the reaction is part of the subsystem but should not be included in the modelling process.


=back

=back

=cut

sub get_relationship_HasParticipant
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasParticipant:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasParticipant');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasParticipant

    $return = $self->_get_relationship($ctx, 'HasParticipant', 'HasParticipant', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasParticipant
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasParticipant:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasParticipant');
    }
    return($return);
}




=head2 get_relationship_ParticipatesIn

  $return = $obj->get_relationship_ParticipatesIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Reaction
	1: a fields_HasParticipant
	2: a fields_Scenario
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string
fields_HasParticipant is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
	type has a value which is an int
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Reaction
	1: a fields_HasParticipant
	2: a fields_Scenario
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string
fields_HasParticipant is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
	type has a value which is an int
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_ParticipatesIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ParticipatesIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ParticipatesIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ParticipatesIn

    $return = $self->_get_relationship($ctx, 'ParticipatesIn', 'HasParticipant', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ParticipatesIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ParticipatesIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ParticipatesIn');
    }
    return($return);
}




=head2 get_relationship_HasPresenceOf

  $return = $obj->get_relationship_HasPresenceOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Media
	1: a fields_HasPresenceOf
	2: a fields_Compound
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string
fields_HasPresenceOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	concentration has a value which is a float
	minimum_flux has a value which is a float
	maximum_flux has a value which is a float
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Media
	1: a fields_HasPresenceOf
	2: a fields_Compound
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string
fields_HasPresenceOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	concentration has a value which is a float
	minimum_flux has a value which is a float
	maximum_flux has a value which is a float
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float


=end text



=item Description

This relationship connects a media to the compounds that
occur in it. The intersection data describes how much of each
compound can be found.

It has the following fields:

=over 4

=item concentration

The concentration of the compound in the media. A null value indicates that although the compound is present in the media, its concentration is not specified. This is typically the case for model medias which do not have physical analogs.

=item minimum_flux

minimum flux level for the compound in the medium.

=item maximum_flux

maximum flux level for the compound in the medium.


=back

=back

=cut

sub get_relationship_HasPresenceOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasPresenceOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasPresenceOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasPresenceOf

    $return = $self->_get_relationship($ctx, 'HasPresenceOf', 'HasPresenceOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasPresenceOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasPresenceOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasPresenceOf');
    }
    return($return);
}




=head2 get_relationship_IsPresentIn

  $return = $obj->get_relationship_IsPresentIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_HasPresenceOf
	2: a fields_Media
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_HasPresenceOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	concentration has a value which is a float
	minimum_flux has a value which is a float
	maximum_flux has a value which is a float
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_HasPresenceOf
	2: a fields_Media
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_HasPresenceOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	concentration has a value which is a float
	minimum_flux has a value which is a float
	maximum_flux has a value which is a float
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsPresentIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsPresentIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsPresentIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsPresentIn

    $return = $self->_get_relationship($ctx, 'IsPresentIn', 'HasPresenceOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsPresentIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsPresentIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsPresentIn');
    }
    return($return);
}




=head2 get_relationship_HasProteinMember

  $return = $obj->get_relationship_HasProteinMember($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Family
	1: a fields_HasProteinMember
	2: a fields_ProteinSequence
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string
fields_HasProteinMember is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	source_id has a value which is a string
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Family
	1: a fields_HasProteinMember
	2: a fields_ProteinSequence
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string
fields_HasProteinMember is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	source_id has a value which is a string
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string


=end text



=item Description

This relationship connects each feature family to its
constituent protein sequences. A family always has many protein sequences,
and a single sequence can be found in many families.

It has the following fields:

=over 4

=item source_id

Native identifier used for the protein in the definition of the family. This will be its ID in the alignment, if one exists.


=back

=back

=cut

sub get_relationship_HasProteinMember
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasProteinMember:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasProteinMember');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasProteinMember

    $return = $self->_get_relationship($ctx, 'HasProteinMember', 'HasProteinMember', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasProteinMember
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasProteinMember:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasProteinMember');
    }
    return($return);
}




=head2 get_relationship_IsProteinMemberOf

  $return = $obj->get_relationship_IsProteinMemberOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProteinSequence
	1: a fields_HasProteinMember
	2: a fields_Family
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string
fields_HasProteinMember is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	source_id has a value which is a string
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProteinSequence
	1: a fields_HasProteinMember
	2: a fields_Family
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string
fields_HasProteinMember is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	source_id has a value which is a string
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsProteinMemberOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsProteinMemberOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsProteinMemberOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsProteinMemberOf

    $return = $self->_get_relationship($ctx, 'IsProteinMemberOf', 'HasProteinMember', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsProteinMemberOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsProteinMemberOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsProteinMemberOf');
    }
    return($return);
}




=head2 get_relationship_HasReactionAliasFrom

  $return = $obj->get_relationship_HasReactionAliasFrom($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_HasReactionAliasFrom
	2: a fields_Reaction
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_HasReactionAliasFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	alias has a value which is a string
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_HasReactionAliasFrom
	2: a fields_Reaction
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_HasReactionAliasFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	alias has a value which is a string
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string


=end text



=item Description

This relationship connects a source (database or organization)
with the reactions for which it has assigned names (aliases).
The alias itself is stored as intersection data.

It has the following fields:

=over 4

=item alias

alias for the reaction assigned by the source


=back

=back

=cut

sub get_relationship_HasReactionAliasFrom
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasReactionAliasFrom:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasReactionAliasFrom');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasReactionAliasFrom

    $return = $self->_get_relationship($ctx, 'HasReactionAliasFrom', 'HasReactionAliasFrom', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasReactionAliasFrom
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasReactionAliasFrom:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasReactionAliasFrom');
    }
    return($return);
}




=head2 get_relationship_UsesAliasForReaction

  $return = $obj->get_relationship_UsesAliasForReaction($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Reaction
	1: a fields_HasReactionAliasFrom
	2: a fields_Source
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string
fields_HasReactionAliasFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	alias has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Reaction
	1: a fields_HasReactionAliasFrom
	2: a fields_Source
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string
fields_HasReactionAliasFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	alias has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_UsesAliasForReaction
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_UsesAliasForReaction:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_UsesAliasForReaction');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_UsesAliasForReaction

    $return = $self->_get_relationship($ctx, 'UsesAliasForReaction', 'HasReactionAliasFrom', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_UsesAliasForReaction
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_UsesAliasForReaction:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_UsesAliasForReaction');
    }
    return($return);
}




=head2 get_relationship_HasRegulogs

  $return = $obj->get_relationship_HasRegulogs($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_RegulogCollection
	1: a fields_HasRegulogs
	2: a fields_Regulog
fields_RegulogCollection is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
fields_HasRegulogs is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_RegulogCollection
	1: a fields_HasRegulogs
	2: a fields_Regulog
fields_RegulogCollection is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
fields_HasRegulogs is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_HasRegulogs
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasRegulogs:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasRegulogs');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasRegulogs

    $return = $self->_get_relationship($ctx, 'HasRegulogs', 'HasRegulogs', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasRegulogs
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasRegulogs:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasRegulogs');
    }
    return($return);
}




=head2 get_relationship_IsInCollection

  $return = $obj->get_relationship_IsInCollection($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulog
	1: a fields_HasRegulogs
	2: a fields_RegulogCollection
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_HasRegulogs is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_RegulogCollection is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulog
	1: a fields_HasRegulogs
	2: a fields_RegulogCollection
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_HasRegulogs is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_RegulogCollection is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsInCollection
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsInCollection:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInCollection');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsInCollection

    $return = $self->_get_relationship($ctx, 'IsInCollection', 'HasRegulogs', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsInCollection
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsInCollection:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInCollection');
    }
    return($return);
}




=head2 get_relationship_HasRepresentativeOf

  $return = $obj->get_relationship_HasRepresentativeOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_HasRepresentativeOf
	2: a fields_Family
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_HasRepresentativeOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_HasRepresentativeOf
	2: a fields_Family
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_HasRepresentativeOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string


=end text



=item Description

This relationship connects a genome to the FIGfam protein families
for which it has representative proteins. This information can be computed
from other relationships, but it is provided explicitly to allow fast access
to a genome's FIGfam profile.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_HasRepresentativeOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasRepresentativeOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasRepresentativeOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasRepresentativeOf

    $return = $self->_get_relationship($ctx, 'HasRepresentativeOf', 'HasRepresentativeOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasRepresentativeOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasRepresentativeOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasRepresentativeOf');
    }
    return($return);
}




=head2 get_relationship_IsRepresentedIn

  $return = $obj->get_relationship_IsRepresentedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Family
	1: a fields_HasRepresentativeOf
	2: a fields_Genome
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string
fields_HasRepresentativeOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Family
	1: a fields_HasRepresentativeOf
	2: a fields_Genome
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string
fields_HasRepresentativeOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsRepresentedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsRepresentedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRepresentedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsRepresentedIn

    $return = $self->_get_relationship($ctx, 'IsRepresentedIn', 'HasRepresentativeOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsRepresentedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsRepresentedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRepresentedIn');
    }
    return($return);
}




=head2 get_relationship_HasRequirementOf

  $return = $obj->get_relationship_HasRequirementOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Model
	1: a fields_HasRequirementOf
	2: a fields_ReactionInstance
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int
fields_HasRequirementOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Model
	1: a fields_HasRequirementOf
	2: a fields_ReactionInstance
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int
fields_HasRequirementOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float


=end text



=item Description

This relationship connects a model to the instances of
reactions that represent how the reactions occur in the model.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_HasRequirementOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasRequirementOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasRequirementOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasRequirementOf

    $return = $self->_get_relationship($ctx, 'HasRequirementOf', 'HasRequirementOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasRequirementOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasRequirementOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasRequirementOf');
    }
    return($return);
}




=head2 get_relationship_IsARequirementOf

  $return = $obj->get_relationship_IsARequirementOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ReactionInstance
	1: a fields_HasRequirementOf
	2: a fields_Model
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float
fields_HasRequirementOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ReactionInstance
	1: a fields_HasRequirementOf
	2: a fields_Model
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float
fields_HasRequirementOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_IsARequirementOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsARequirementOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsARequirementOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsARequirementOf

    $return = $self->_get_relationship($ctx, 'IsARequirementOf', 'HasRequirementOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsARequirementOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsARequirementOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsARequirementOf');
    }
    return($return);
}




=head2 get_relationship_HasResultsIn

  $return = $obj->get_relationship_HasResultsIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProbeSet
	1: a fields_HasResultsIn
	2: a fields_Experiment
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_HasResultsIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	sequence has a value which is an int
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProbeSet
	1: a fields_HasResultsIn
	2: a fields_Experiment
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_HasResultsIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	sequence has a value which is an int
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string


=end text



=item Description

This relationship connects a probe set to the experiments that were
applied to it.

It has the following fields:

=over 4

=item sequence

Sequence number of this experiment in the various result vectors.


=back

=back

=cut

sub get_relationship_HasResultsIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasResultsIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasResultsIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasResultsIn

    $return = $self->_get_relationship($ctx, 'HasResultsIn', 'HasResultsIn', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasResultsIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasResultsIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasResultsIn');
    }
    return($return);
}




=head2 get_relationship_HasResultsFor

  $return = $obj->get_relationship_HasResultsFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Experiment
	1: a fields_HasResultsIn
	2: a fields_ProbeSet
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string
fields_HasResultsIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	sequence has a value which is an int
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Experiment
	1: a fields_HasResultsIn
	2: a fields_ProbeSet
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string
fields_HasResultsIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	sequence has a value which is an int
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasResultsFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasResultsFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasResultsFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasResultsFor

    $return = $self->_get_relationship($ctx, 'HasResultsFor', 'HasResultsIn', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasResultsFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasResultsFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasResultsFor');
    }
    return($return);
}




=head2 get_relationship_HasSection

  $return = $obj->get_relationship_HasSection($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ContigSequence
	1: a fields_HasSection
	2: a fields_ContigChunk
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int
fields_HasSection is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ContigChunk is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ContigSequence
	1: a fields_HasSection
	2: a fields_ContigChunk
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int
fields_HasSection is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ContigChunk is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string


=end text



=item Description

This relationship connects a contig's sequence to its DNA
sequences.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_HasSection
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasSection:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasSection');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasSection

    $return = $self->_get_relationship($ctx, 'HasSection', 'HasSection', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasSection
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasSection:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasSection');
    }
    return($return);
}




=head2 get_relationship_IsSectionOf

  $return = $obj->get_relationship_IsSectionOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ContigChunk
	1: a fields_HasSection
	2: a fields_ContigSequence
fields_ContigChunk is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string
fields_HasSection is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ContigChunk
	1: a fields_HasSection
	2: a fields_ContigSequence
fields_ContigChunk is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string
fields_HasSection is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_IsSectionOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsSectionOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSectionOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsSectionOf

    $return = $self->_get_relationship($ctx, 'IsSectionOf', 'HasSection', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsSectionOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsSectionOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSectionOf');
    }
    return($return);
}




=head2 get_relationship_HasStep

  $return = $obj->get_relationship_HasStep($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Complex
	1: a fields_HasStep
	2: a fields_Reaction
fields_Complex is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a reference to a list where each element is a string
	source_id has a value which is a string
	mod_date has a value which is a string
fields_HasStep is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Complex
	1: a fields_HasStep
	2: a fields_Reaction
fields_Complex is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a reference to a list where each element is a string
	source_id has a value which is a string
	mod_date has a value which is a string
fields_HasStep is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string


=end text



=item Description

This relationship connects a complex to the reactions it
catalyzes.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_HasStep
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasStep:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasStep');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasStep

    $return = $self->_get_relationship($ctx, 'HasStep', 'HasStep', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasStep
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasStep:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasStep');
    }
    return($return);
}




=head2 get_relationship_IsStepOf

  $return = $obj->get_relationship_IsStepOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Reaction
	1: a fields_HasStep
	2: a fields_Complex
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string
fields_HasStep is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Complex is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a reference to a list where each element is a string
	source_id has a value which is a string
	mod_date has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Reaction
	1: a fields_HasStep
	2: a fields_Complex
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string
fields_HasStep is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Complex is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a reference to a list where each element is a string
	source_id has a value which is a string
	mod_date has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsStepOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsStepOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsStepOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsStepOf

    $return = $self->_get_relationship($ctx, 'IsStepOf', 'HasStep', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsStepOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsStepOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsStepOf');
    }
    return($return);
}




=head2 get_relationship_HasTrait

  $return = $obj->get_relationship_HasTrait($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ObservationalUnit
	1: a fields_HasTrait
	2: a fields_Trait
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string
fields_HasTrait is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a float
	statistic_type has a value which is a string
	measure_id has a value which is a string
fields_Trait is a reference to a hash where the following keys are defined:
	id has a value which is a string
	trait_name has a value which is a string
	unit_of_measure has a value which is a string
	TO_ID has a value which is a string
	protocol has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ObservationalUnit
	1: a fields_HasTrait
	2: a fields_Trait
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string
fields_HasTrait is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a float
	statistic_type has a value which is a string
	measure_id has a value which is a string
fields_Trait is a reference to a hash where the following keys are defined:
	id has a value which is a string
	trait_name has a value which is a string
	unit_of_measure has a value which is a string
	TO_ID has a value which is a string
	protocol has a value which is a string


=end text



=item Description

This relationship contains the measurement values of a trait on a specific observational Unit

It has the following fields:

=over 4

=item value

value of the trait measurement

=item statistic_type

text description of the statistic type (e.g. mean, median)

=item measure_id

internal ID given to this measurement


=back

=back

=cut

sub get_relationship_HasTrait
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasTrait:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasTrait');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasTrait

    $return = $self->_get_relationship($ctx, 'HasTrait', 'HasTrait', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasTrait
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasTrait:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasTrait');
    }
    return($return);
}




=head2 get_relationship_Measures

  $return = $obj->get_relationship_Measures($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Trait
	1: a fields_HasTrait
	2: a fields_ObservationalUnit
fields_Trait is a reference to a hash where the following keys are defined:
	id has a value which is a string
	trait_name has a value which is a string
	unit_of_measure has a value which is a string
	TO_ID has a value which is a string
	protocol has a value which is a string
fields_HasTrait is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a float
	statistic_type has a value which is a string
	measure_id has a value which is a string
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Trait
	1: a fields_HasTrait
	2: a fields_ObservationalUnit
fields_Trait is a reference to a hash where the following keys are defined:
	id has a value which is a string
	trait_name has a value which is a string
	unit_of_measure has a value which is a string
	TO_ID has a value which is a string
	protocol has a value which is a string
fields_HasTrait is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a float
	statistic_type has a value which is a string
	measure_id has a value which is a string
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_Measures
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Measures:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Measures');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Measures

    $return = $self->_get_relationship($ctx, 'Measures', 'HasTrait', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Measures
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Measures:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Measures');
    }
    return($return);
}




=head2 get_relationship_HasUnits

  $return = $obj->get_relationship_HasUnits($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Locality
	1: a fields_HasUnits
	2: a fields_ObservationalUnit
fields_Locality is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	city has a value which is a string
	state has a value which is a string
	country has a value which is a string
	origcty has a value which is a string
	elevation has a value which is an int
	latitude has a value which is an int
	longitude has a value which is an int
	lo_accession has a value which is a string
fields_HasUnits is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Locality
	1: a fields_HasUnits
	2: a fields_ObservationalUnit
fields_Locality is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	city has a value which is a string
	state has a value which is a string
	country has a value which is a string
	origcty has a value which is a string
	elevation has a value which is an int
	latitude has a value which is an int
	longitude has a value which is an int
	lo_accession has a value which is a string
fields_HasUnits is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string


=end text



=item Description

This relationship associates observational units with the
geographic location where the unit is planted.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_HasUnits
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasUnits:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasUnits');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasUnits

    $return = $self->_get_relationship($ctx, 'HasUnits', 'HasUnits', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasUnits
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasUnits:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasUnits');
    }
    return($return);
}




=head2 get_relationship_IsLocated

  $return = $obj->get_relationship_IsLocated($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ObservationalUnit
	1: a fields_HasUnits
	2: a fields_Locality
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string
fields_HasUnits is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Locality is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	city has a value which is a string
	state has a value which is a string
	country has a value which is a string
	origcty has a value which is a string
	elevation has a value which is an int
	latitude has a value which is an int
	longitude has a value which is an int
	lo_accession has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ObservationalUnit
	1: a fields_HasUnits
	2: a fields_Locality
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string
fields_HasUnits is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Locality is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	city has a value which is a string
	state has a value which is a string
	country has a value which is a string
	origcty has a value which is a string
	elevation has a value which is an int
	latitude has a value which is an int
	longitude has a value which is an int
	lo_accession has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsLocated
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsLocated:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsLocated');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsLocated

    $return = $self->_get_relationship($ctx, 'IsLocated', 'HasUnits', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsLocated
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsLocated:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsLocated');
    }
    return($return);
}




=head2 get_relationship_HasUsage

  $return = $obj->get_relationship_HasUsage($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_LocalizedCompound
	1: a fields_HasUsage
	2: a fields_CompoundInstance
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_HasUsage is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_LocalizedCompound
	1: a fields_HasUsage
	2: a fields_CompoundInstance
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_HasUsage is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string


=end text



=item Description

This relationship connects a specific compound in a model to the localized
compound to which it corresponds.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_HasUsage
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasUsage:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasUsage');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasUsage

    $return = $self->_get_relationship($ctx, 'HasUsage', 'HasUsage', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasUsage
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasUsage:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasUsage');
    }
    return($return);
}




=head2 get_relationship_IsUsageOf

  $return = $obj->get_relationship_IsUsageOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CompoundInstance
	1: a fields_HasUsage
	2: a fields_LocalizedCompound
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string
fields_HasUsage is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CompoundInstance
	1: a fields_HasUsage
	2: a fields_LocalizedCompound
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string
fields_HasUsage is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsUsageOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsUsageOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsUsageOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsUsageOf

    $return = $self->_get_relationship($ctx, 'IsUsageOf', 'HasUsage', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsUsageOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsUsageOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsUsageOf');
    }
    return($return);
}




=head2 get_relationship_HasValueFor

  $return = $obj->get_relationship_HasValueFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Experiment
	1: a fields_HasValueFor
	2: a fields_Attribute
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string
fields_HasValueFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_Attribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Experiment
	1: a fields_HasValueFor
	2: a fields_Attribute
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string
fields_HasValueFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_Attribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description

This relationship connects an experiment to its attributes. The attribute
values are stored here.

It has the following fields:

=over 4

=item value

Value of this attribute in the given experiment. This is always encoded as a string, but may in fact be a number.


=back

=back

=cut

sub get_relationship_HasValueFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasValueFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasValueFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasValueFor

    $return = $self->_get_relationship($ctx, 'HasValueFor', 'HasValueFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasValueFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasValueFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasValueFor');
    }
    return($return);
}




=head2 get_relationship_HasValueIn

  $return = $obj->get_relationship_HasValueIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Attribute
	1: a fields_HasValueFor
	2: a fields_Experiment
fields_Attribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_HasValueFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Attribute
	1: a fields_HasValueFor
	2: a fields_Experiment
fields_Attribute is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_HasValueFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	value has a value which is a string
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasValueIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasValueIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasValueIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasValueIn

    $return = $self->_get_relationship($ctx, 'HasValueIn', 'HasValueFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasValueIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasValueIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasValueIn');
    }
    return($return);
}




=head2 get_relationship_HasVariationIn

  $return = $obj->get_relationship_HasVariationIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Contig
	1: a fields_HasVariationIn
	2: a fields_ObservationalUnit
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_HasVariationIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	position has a value which is an int
	len has a value which is an int
	data has a value which is a string
	data2 has a value which is a string
	quality has a value which is a float
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Contig
	1: a fields_HasVariationIn
	2: a fields_ObservationalUnit
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_HasVariationIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	position has a value which is an int
	len has a value which is an int
	data has a value which is a string
	data2 has a value which is a string
	quality has a value which is a float
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string


=end text



=item Description

This relationship defines an observational unit's DNA variation
from a contig in the reference genome.

It has the following fields:

=over 4

=item position

Position of this variation in the reference contig.

=item len

Length of the variation in the reference contig. A length of zero indicates an insertion.

=item data

Replacement DNA for the variation on the primary chromosome. An empty string indicates a deletion. The primary chromosome is chosen arbitrarily among the two chromosomes of a plant's chromosome pair (one coming from the mother and one from the father).

=item data2

Replacement DNA for the variation on the secondary chromosome. This will frequently be the same as the primary chromosome string.

=item quality

Quality score assigned to this variation.


=back

=back

=cut

sub get_relationship_HasVariationIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasVariationIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasVariationIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasVariationIn

    $return = $self->_get_relationship($ctx, 'HasVariationIn', 'HasVariationIn', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasVariationIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasVariationIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasVariationIn');
    }
    return($return);
}




=head2 get_relationship_IsVariedIn

  $return = $obj->get_relationship_IsVariedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ObservationalUnit
	1: a fields_HasVariationIn
	2: a fields_Contig
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string
fields_HasVariationIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	position has a value which is an int
	len has a value which is an int
	data has a value which is a string
	data2 has a value which is a string
	quality has a value which is a float
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ObservationalUnit
	1: a fields_HasVariationIn
	2: a fields_Contig
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string
fields_HasVariationIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	position has a value which is an int
	len has a value which is an int
	data has a value which is a string
	data2 has a value which is a string
	quality has a value which is a float
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsVariedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsVariedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsVariedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsVariedIn

    $return = $self->_get_relationship($ctx, 'IsVariedIn', 'HasVariationIn', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsVariedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsVariedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsVariedIn');
    }
    return($return);
}




=head2 get_relationship_Impacts

  $return = $obj->get_relationship_Impacts($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Trait
	1: a fields_Impacts
	2: a fields_Contig
fields_Trait is a reference to a hash where the following keys are defined:
	id has a value which is a string
	trait_name has a value which is a string
	unit_of_measure has a value which is a string
	TO_ID has a value which is a string
	protocol has a value which is a string
fields_Impacts is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	source_name has a value which is a string
	rank has a value which is an int
	pvalue has a value which is a float
	position has a value which is an int
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Trait
	1: a fields_Impacts
	2: a fields_Contig
fields_Trait is a reference to a hash where the following keys are defined:
	id has a value which is a string
	trait_name has a value which is a string
	unit_of_measure has a value which is a string
	TO_ID has a value which is a string
	protocol has a value which is a string
fields_Impacts is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	source_name has a value which is a string
	rank has a value which is an int
	pvalue has a value which is a float
	position has a value which is an int
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description

This relationship contains the best scoring statistical correlations between measured traits and the responsible alleles.

It has the following fields:

=over 4

=item source_name

Name of the study which analyzed the data and determined that a variation has impact on a trait

=item rank

Rank of the position among all positions correlated with this trait.

=item pvalue

P-value of the correlation between the variation and the trait

=item position

Position in the reference contig where the trait has an impact.


=back

=back

=cut

sub get_relationship_Impacts
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Impacts:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Impacts');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Impacts

    $return = $self->_get_relationship($ctx, 'Impacts', 'Impacts', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Impacts
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Impacts:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Impacts');
    }
    return($return);
}




=head2 get_relationship_IsImpactedBy

  $return = $obj->get_relationship_IsImpactedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Contig
	1: a fields_Impacts
	2: a fields_Trait
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_Impacts is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	source_name has a value which is a string
	rank has a value which is an int
	pvalue has a value which is a float
	position has a value which is an int
fields_Trait is a reference to a hash where the following keys are defined:
	id has a value which is a string
	trait_name has a value which is a string
	unit_of_measure has a value which is a string
	TO_ID has a value which is a string
	protocol has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Contig
	1: a fields_Impacts
	2: a fields_Trait
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_Impacts is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	source_name has a value which is a string
	rank has a value which is an int
	pvalue has a value which is a float
	position has a value which is an int
fields_Trait is a reference to a hash where the following keys are defined:
	id has a value which is a string
	trait_name has a value which is a string
	unit_of_measure has a value which is a string
	TO_ID has a value which is a string
	protocol has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsImpactedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsImpactedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsImpactedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsImpactedBy

    $return = $self->_get_relationship($ctx, 'IsImpactedBy', 'Impacts', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsImpactedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsImpactedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsImpactedBy');
    }
    return($return);
}




=head2 get_relationship_ImplementsReaction

  $return = $obj->get_relationship_ImplementsReaction($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_ImplementsReaction
	2: a fields_ReactionInstance
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_ImplementsReaction is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_ImplementsReaction
	2: a fields_ReactionInstance
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_ImplementsReaction is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float


=end text



=item Description

This relationship connects features to reaction instances
that exist because the feature is included in a model.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_ImplementsReaction
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ImplementsReaction:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ImplementsReaction');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ImplementsReaction

    $return = $self->_get_relationship($ctx, 'ImplementsReaction', 'ImplementsReaction', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ImplementsReaction
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ImplementsReaction:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ImplementsReaction');
    }
    return($return);
}




=head2 get_relationship_ImplementedBasedOn

  $return = $obj->get_relationship_ImplementedBasedOn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ReactionInstance
	1: a fields_ImplementsReaction
	2: a fields_Feature
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float
fields_ImplementsReaction is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ReactionInstance
	1: a fields_ImplementsReaction
	2: a fields_Feature
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float
fields_ImplementsReaction is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_ImplementedBasedOn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ImplementedBasedOn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ImplementedBasedOn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ImplementedBasedOn

    $return = $self->_get_relationship($ctx, 'ImplementedBasedOn', 'ImplementsReaction', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ImplementedBasedOn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ImplementedBasedOn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ImplementedBasedOn');
    }
    return($return);
}




=head2 get_relationship_Includes

  $return = $obj->get_relationship_Includes($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Subsystem
	1: a fields_Includes
	2: a fields_Role
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int
fields_Includes is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	sequence has a value which is an int
	abbreviation has a value which is a string
	auxiliary has a value which is an int
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Subsystem
	1: a fields_Includes
	2: a fields_Role
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int
fields_Includes is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	sequence has a value which is an int
	abbreviation has a value which is a string
	auxiliary has a value which is an int
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int


=end text



=item Description

A subsystem is defined by its roles. The subsystem's variants
contain slightly different sets of roles, but all of the roles in a
variant must be connected to the parent subsystem by this
relationship. A subsystem always has at least one role, and a role
always belongs to at least one subsystem.

It has the following fields:

=over 4

=item sequence

Sequence number of the role within the subsystem. When the roles are formed into a variant, they will generally appear in sequence order.

=item abbreviation

Abbreviation for this role in this subsystem. The abbreviations are used in columnar displays, and they also appear on diagrams.

=item auxiliary

TRUE if this is an auxiliary role, or FALSE if this role is a functioning part of the subsystem.


=back

=back

=cut

sub get_relationship_Includes
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Includes:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Includes');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Includes

    $return = $self->_get_relationship($ctx, 'Includes', 'Includes', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Includes
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Includes:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Includes');
    }
    return($return);
}




=head2 get_relationship_IsIncludedIn

  $return = $obj->get_relationship_IsIncludedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Role
	1: a fields_Includes
	2: a fields_Subsystem
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int
fields_Includes is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	sequence has a value which is an int
	abbreviation has a value which is a string
	auxiliary has a value which is an int
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Role
	1: a fields_Includes
	2: a fields_Subsystem
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int
fields_Includes is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	sequence has a value which is an int
	abbreviation has a value which is a string
	auxiliary has a value which is an int
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_IsIncludedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsIncludedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsIncludedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsIncludedIn

    $return = $self->_get_relationship($ctx, 'IsIncludedIn', 'Includes', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsIncludedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsIncludedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsIncludedIn');
    }
    return($return);
}




=head2 get_relationship_IncludesAdditionalCompounds

  $return = $obj->get_relationship_IncludesAdditionalCompounds($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Environment
	1: a fields_IncludesAdditionalCompounds
	2: a fields_Compound
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string
fields_IncludesAdditionalCompounds is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	concentration has a value which is a float
	units has a value which is a string
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Environment
	1: a fields_IncludesAdditionalCompounds
	2: a fields_Compound
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string
fields_IncludesAdditionalCompounds is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	concentration has a value which is a float
	units has a value which is a string
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float


=end text



=item Description

This relationship connects a environment to the compounds that
occur in it. The intersection data describes how much of each
compound can be found.

It has the following fields:

=over 4

=item concentration

The concentration of the compound in the environment. A null value indicates that although the compound is present in the environment, its concentration is not specified. This is typically the case for model environments which do not have physical analogs.

=item units

vol%, g/L, or molar (mol/L).


=back

=back

=cut

sub get_relationship_IncludesAdditionalCompounds
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IncludesAdditionalCompounds:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IncludesAdditionalCompounds');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IncludesAdditionalCompounds

    $return = $self->_get_relationship($ctx, 'IncludesAdditionalCompounds', 'IncludesAdditionalCompounds', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IncludesAdditionalCompounds
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IncludesAdditionalCompounds:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IncludesAdditionalCompounds');
    }
    return($return);
}




=head2 get_relationship_IncludedIn

  $return = $obj->get_relationship_IncludedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_IncludesAdditionalCompounds
	2: a fields_Environment
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_IncludesAdditionalCompounds is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	concentration has a value which is a float
	units has a value which is a string
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_IncludesAdditionalCompounds
	2: a fields_Environment
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_IncludesAdditionalCompounds is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	concentration has a value which is a float
	units has a value which is a string
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IncludedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IncludedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IncludedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IncludedIn

    $return = $self->_get_relationship($ctx, 'IncludedIn', 'IncludesAdditionalCompounds', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IncludedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IncludedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IncludedIn');
    }
    return($return);
}




=head2 get_relationship_IncludesAlignmentRow

  $return = $obj->get_relationship_IncludesAlignmentRow($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_IncludesAlignmentRow
	2: a fields_AlignmentRow
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_IncludesAlignmentRow is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_IncludesAlignmentRow
	2: a fields_AlignmentRow
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_IncludesAlignmentRow is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string


=end text



=item Description

This relationship connects an alignment to its component
rows.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IncludesAlignmentRow
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IncludesAlignmentRow:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IncludesAlignmentRow');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IncludesAlignmentRow

    $return = $self->_get_relationship($ctx, 'IncludesAlignmentRow', 'IncludesAlignmentRow', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IncludesAlignmentRow
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IncludesAlignmentRow:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IncludesAlignmentRow');
    }
    return($return);
}




=head2 get_relationship_IsAlignmentRowIn

  $return = $obj->get_relationship_IsAlignmentRowIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AlignmentRow
	1: a fields_IncludesAlignmentRow
	2: a fields_Alignment
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string
fields_IncludesAlignmentRow is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AlignmentRow
	1: a fields_IncludesAlignmentRow
	2: a fields_Alignment
fields_AlignmentRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	row_number has a value which is an int
	row_id has a value which is a string
	row_description has a value which is a string
	n_components has a value which is an int
	beg_pos_aln has a value which is an int
	end_pos_aln has a value which is an int
	md5_of_ungapped_sequence has a value which is a string
	sequence has a value which is a string
fields_IncludesAlignmentRow is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsAlignmentRowIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsAlignmentRowIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsAlignmentRowIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsAlignmentRowIn

    $return = $self->_get_relationship($ctx, 'IsAlignmentRowIn', 'IncludesAlignmentRow', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsAlignmentRowIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsAlignmentRowIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsAlignmentRowIn');
    }
    return($return);
}




=head2 get_relationship_IncludesPart

  $return = $obj->get_relationship_IncludesPart($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_StudyExperiment
	1: a fields_IncludesPart
	2: a fields_ObservationalUnit
fields_StudyExperiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	design has a value which is a string
	originator has a value which is a string
fields_IncludesPart is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_StudyExperiment
	1: a fields_IncludesPart
	2: a fields_ObservationalUnit
fields_StudyExperiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	design has a value which is a string
	originator has a value which is a string
fields_IncludesPart is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string


=end text



=item Description

This relationship associates observational units with the
experiments that generated the data on them.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IncludesPart
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IncludesPart:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IncludesPart');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IncludesPart

    $return = $self->_get_relationship($ctx, 'IncludesPart', 'IncludesPart', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IncludesPart
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IncludesPart:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IncludesPart');
    }
    return($return);
}




=head2 get_relationship_IsPartOf

  $return = $obj->get_relationship_IsPartOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ObservationalUnit
	1: a fields_IncludesPart
	2: a fields_StudyExperiment
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string
fields_IncludesPart is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_StudyExperiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	design has a value which is a string
	originator has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ObservationalUnit
	1: a fields_IncludesPart
	2: a fields_StudyExperiment
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string
fields_IncludesPart is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_StudyExperiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	design has a value which is a string
	originator has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsPartOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsPartOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsPartOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsPartOf

    $return = $self->_get_relationship($ctx, 'IsPartOf', 'IncludesPart', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsPartOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsPartOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsPartOf');
    }
    return($return);
}




=head2 get_relationship_IndicatedLevelsFor

  $return = $obj->get_relationship_IndicatedLevelsFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProbeSet
	1: a fields_IndicatedLevelsFor
	2: a fields_Feature
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IndicatedLevelsFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	level_vector has a value which is a countVector
countVector is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProbeSet
	1: a fields_IndicatedLevelsFor
	2: a fields_Feature
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IndicatedLevelsFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	level_vector has a value which is a countVector
countVector is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description

This relationship connects a feature to a probe set from which experimental
data was produced for the feature. It contains a vector of the expression levels.

It has the following fields:

=over 4

=item level_vector

Vector of expression levels (-1, 0, 1) for the experiments, in sequence order.


=back

=back

=cut

sub get_relationship_IndicatedLevelsFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IndicatedLevelsFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IndicatedLevelsFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IndicatedLevelsFor

    $return = $self->_get_relationship($ctx, 'IndicatedLevelsFor', 'IndicatedLevelsFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IndicatedLevelsFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IndicatedLevelsFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IndicatedLevelsFor');
    }
    return($return);
}




=head2 get_relationship_HasLevelsFrom

  $return = $obj->get_relationship_HasLevelsFrom($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IndicatedLevelsFor
	2: a fields_ProbeSet
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IndicatedLevelsFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	level_vector has a value which is a countVector
countVector is a string
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IndicatedLevelsFor
	2: a fields_ProbeSet
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IndicatedLevelsFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	level_vector has a value which is a countVector
countVector is a string
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasLevelsFrom
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasLevelsFrom:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasLevelsFrom');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasLevelsFrom

    $return = $self->_get_relationship($ctx, 'HasLevelsFrom', 'IndicatedLevelsFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasLevelsFrom
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasLevelsFrom:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasLevelsFrom');
    }
    return($return);
}




=head2 get_relationship_Involves

  $return = $obj->get_relationship_Involves($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Reaction
	1: a fields_Involves
	2: a fields_LocalizedCompound
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string
fields_Involves is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float
	cofactor has a value which is an int
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Reaction
	1: a fields_Involves
	2: a fields_LocalizedCompound
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string
fields_Involves is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float
	cofactor has a value which is an int
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

This relationship connects a reaction to the
specific localized compounds that participate in it.

It has the following fields:

=over 4

=item coefficient

Number of molecules of the compound that participate in a single instance of the reaction. For example, if a reaction produces two water molecules, the stoichiometry of water for the reaction would be two. When a reaction is written on paper in chemical notation, the stoichiometry is the number next to the chemical formula of the compound. The value is negative for substrates and positive for products.

=item cofactor

TRUE if the compound is a cofactor; FALSE if it is a major component of the reaction.


=back

=back

=cut

sub get_relationship_Involves
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Involves:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Involves');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Involves

    $return = $self->_get_relationship($ctx, 'Involves', 'Involves', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Involves
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Involves:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Involves');
    }
    return($return);
}




=head2 get_relationship_IsInvolvedIn

  $return = $obj->get_relationship_IsInvolvedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_LocalizedCompound
	1: a fields_Involves
	2: a fields_Reaction
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_Involves is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float
	cofactor has a value which is an int
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_LocalizedCompound
	1: a fields_Involves
	2: a fields_Reaction
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_Involves is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float
	cofactor has a value which is an int
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsInvolvedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsInvolvedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInvolvedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsInvolvedIn

    $return = $self->_get_relationship($ctx, 'IsInvolvedIn', 'Involves', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsInvolvedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsInvolvedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInvolvedIn');
    }
    return($return);
}




=head2 get_relationship_IsAnnotatedBy

  $return = $obj->get_relationship_IsAnnotatedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsAnnotatedBy
	2: a fields_Annotation
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsAnnotatedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Annotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotator has a value which is a string
	comment has a value which is a string
	annotation_time has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsAnnotatedBy
	2: a fields_Annotation
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsAnnotatedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Annotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotator has a value which is a string
	comment has a value which is a string
	annotation_time has a value which is a string


=end text



=item Description

This relationship connects a feature to its annotations. A
feature may have multiple annotations, but an annotation belongs to
only one feature.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsAnnotatedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsAnnotatedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsAnnotatedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsAnnotatedBy

    $return = $self->_get_relationship($ctx, 'IsAnnotatedBy', 'IsAnnotatedBy', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsAnnotatedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsAnnotatedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsAnnotatedBy');
    }
    return($return);
}




=head2 get_relationship_Annotates

  $return = $obj->get_relationship_Annotates($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Annotation
	1: a fields_IsAnnotatedBy
	2: a fields_Feature
fields_Annotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotator has a value which is a string
	comment has a value which is a string
	annotation_time has a value which is a string
fields_IsAnnotatedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Annotation
	1: a fields_IsAnnotatedBy
	2: a fields_Feature
fields_Annotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotator has a value which is a string
	comment has a value which is a string
	annotation_time has a value which is a string
fields_IsAnnotatedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_Annotates
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Annotates:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Annotates');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Annotates

    $return = $self->_get_relationship($ctx, 'Annotates', 'IsAnnotatedBy', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Annotates
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Annotates:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Annotates');
    }
    return($return);
}




=head2 get_relationship_IsAssayOf

  $return = $obj->get_relationship_IsAssayOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Assay
	1: a fields_IsAssayOf
	2: a fields_StudyExperiment
fields_Assay is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	assay_type has a value which is a string
	assay_type_id has a value which is a string
fields_IsAssayOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_StudyExperiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	design has a value which is a string
	originator has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Assay
	1: a fields_IsAssayOf
	2: a fields_StudyExperiment
fields_Assay is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	assay_type has a value which is a string
	assay_type_id has a value which is a string
fields_IsAssayOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_StudyExperiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	design has a value which is a string
	originator has a value which is a string


=end text



=item Description

This relationship associates each assay with the relevant
experiments.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsAssayOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsAssayOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsAssayOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsAssayOf

    $return = $self->_get_relationship($ctx, 'IsAssayOf', 'IsAssayOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsAssayOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsAssayOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsAssayOf');
    }
    return($return);
}




=head2 get_relationship_IsAssayedBy

  $return = $obj->get_relationship_IsAssayedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_StudyExperiment
	1: a fields_IsAssayOf
	2: a fields_Assay
fields_StudyExperiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	design has a value which is a string
	originator has a value which is a string
fields_IsAssayOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Assay is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	assay_type has a value which is a string
	assay_type_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_StudyExperiment
	1: a fields_IsAssayOf
	2: a fields_Assay
fields_StudyExperiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	design has a value which is a string
	originator has a value which is a string
fields_IsAssayOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Assay is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	assay_type has a value which is a string
	assay_type_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsAssayedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsAssayedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsAssayedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsAssayedBy

    $return = $self->_get_relationship($ctx, 'IsAssayedBy', 'IsAssayOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsAssayedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsAssayedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsAssayedBy');
    }
    return($return);
}




=head2 get_relationship_IsClassFor

  $return = $obj->get_relationship_IsClassFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SubsystemClass
	1: a fields_IsClassFor
	2: a fields_Subsystem
fields_SubsystemClass is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsClassFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SubsystemClass
	1: a fields_IsClassFor
	2: a fields_Subsystem
fields_SubsystemClass is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsClassFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int


=end text



=item Description

This relationship connects each subsystem class with the
subsystems that belong to it. A class can contain many subsystems,
but a subsystem is only in one class. Some subsystems are not in any
class, but this is usually a temporary condition.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsClassFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsClassFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsClassFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsClassFor

    $return = $self->_get_relationship($ctx, 'IsClassFor', 'IsClassFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsClassFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsClassFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsClassFor');
    }
    return($return);
}




=head2 get_relationship_IsInClass

  $return = $obj->get_relationship_IsInClass($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Subsystem
	1: a fields_IsClassFor
	2: a fields_SubsystemClass
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int
fields_IsClassFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SubsystemClass is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Subsystem
	1: a fields_IsClassFor
	2: a fields_SubsystemClass
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int
fields_IsClassFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SubsystemClass is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsInClass
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsInClass:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInClass');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsInClass

    $return = $self->_get_relationship($ctx, 'IsInClass', 'IsClassFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsInClass
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsInClass:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInClass');
    }
    return($return);
}




=head2 get_relationship_IsCollectionOf

  $return = $obj->get_relationship_IsCollectionOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_OTU
	1: a fields_IsCollectionOf
	2: a fields_Genome
fields_OTU is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsCollectionOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	representative has a value which is an int
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_OTU
	1: a fields_IsCollectionOf
	2: a fields_Genome
fields_OTU is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsCollectionOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	representative has a value which is an int
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description

A genome belongs to only one genome set. For each set, this relationship marks the genome to be used as its representative.

It has the following fields:

=over 4

=item representative

TRUE for the representative genome of the set, else FALSE.


=back

=back

=cut

sub get_relationship_IsCollectionOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsCollectionOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsCollectionOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsCollectionOf

    $return = $self->_get_relationship($ctx, 'IsCollectionOf', 'IsCollectionOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsCollectionOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsCollectionOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsCollectionOf');
    }
    return($return);
}




=head2 get_relationship_IsCollectedInto

  $return = $obj->get_relationship_IsCollectedInto($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsCollectionOf
	2: a fields_OTU
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsCollectionOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	representative has a value which is an int
fields_OTU is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsCollectionOf
	2: a fields_OTU
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsCollectionOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	representative has a value which is an int
fields_OTU is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsCollectedInto
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsCollectedInto:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsCollectedInto');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsCollectedInto

    $return = $self->_get_relationship($ctx, 'IsCollectedInto', 'IsCollectionOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsCollectedInto
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsCollectedInto:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsCollectedInto');
    }
    return($return);
}




=head2 get_relationship_IsComposedOf

  $return = $obj->get_relationship_IsComposedOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsComposedOf
	2: a fields_Contig
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsComposedOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsComposedOf
	2: a fields_Contig
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsComposedOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description

This relationship connects a genome to its
constituent contigs. Unlike contig sequences, a
contig belongs to only one genome.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsComposedOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsComposedOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsComposedOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsComposedOf

    $return = $self->_get_relationship($ctx, 'IsComposedOf', 'IsComposedOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsComposedOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsComposedOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsComposedOf');
    }
    return($return);
}




=head2 get_relationship_IsComponentOf

  $return = $obj->get_relationship_IsComponentOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Contig
	1: a fields_IsComposedOf
	2: a fields_Genome
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_IsComposedOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Contig
	1: a fields_IsComposedOf
	2: a fields_Genome
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_IsComposedOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsComponentOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsComponentOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsComponentOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsComponentOf

    $return = $self->_get_relationship($ctx, 'IsComponentOf', 'IsComposedOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsComponentOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsComponentOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsComponentOf');
    }
    return($return);
}




=head2 get_relationship_IsComprisedOf

  $return = $obj->get_relationship_IsComprisedOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Biomass
	1: a fields_IsComprisedOf
	2: a fields_CompoundInstance
fields_Biomass is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a reference to a list where each element is a string
	dna has a value which is a float
	protein has a value which is a float
	cell_wall has a value which is a float
	lipid has a value which is a float
	cofactor has a value which is a float
	energy has a value which is a float
fields_IsComprisedOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Biomass
	1: a fields_IsComprisedOf
	2: a fields_CompoundInstance
fields_Biomass is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a reference to a list where each element is a string
	dna has a value which is a float
	protein has a value which is a float
	cell_wall has a value which is a float
	lipid has a value which is a float
	cofactor has a value which is a float
	energy has a value which is a float
fields_IsComprisedOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string


=end text



=item Description

This relationship connects a biomass composition reaction to the
compounds specified as contained in the biomass.

It has the following fields:

=over 4

=item coefficient

number of millimoles of the compound instance that exists in one gram cell dry weight of biomass


=back

=back

=cut

sub get_relationship_IsComprisedOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsComprisedOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsComprisedOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsComprisedOf

    $return = $self->_get_relationship($ctx, 'IsComprisedOf', 'IsComprisedOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsComprisedOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsComprisedOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsComprisedOf');
    }
    return($return);
}




=head2 get_relationship_Comprises

  $return = $obj->get_relationship_Comprises($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CompoundInstance
	1: a fields_IsComprisedOf
	2: a fields_Biomass
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string
fields_IsComprisedOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float
fields_Biomass is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a reference to a list where each element is a string
	dna has a value which is a float
	protein has a value which is a float
	cell_wall has a value which is a float
	lipid has a value which is a float
	cofactor has a value which is a float
	energy has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CompoundInstance
	1: a fields_IsComprisedOf
	2: a fields_Biomass
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string
fields_IsComprisedOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float
fields_Biomass is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a reference to a list where each element is a string
	dna has a value which is a float
	protein has a value which is a float
	cell_wall has a value which is a float
	lipid has a value which is a float
	cofactor has a value which is a float
	energy has a value which is a float


=end text



=item Description



=back

=cut

sub get_relationship_Comprises
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Comprises:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Comprises');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Comprises

    $return = $self->_get_relationship($ctx, 'Comprises', 'IsComprisedOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Comprises
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Comprises:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Comprises');
    }
    return($return);
}




=head2 get_relationship_IsConfiguredBy

  $return = $obj->get_relationship_IsConfiguredBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsConfiguredBy
	2: a fields_AtomicRegulon
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsConfiguredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsConfiguredBy
	2: a fields_AtomicRegulon
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsConfiguredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

This relationship connects a genome to the atomic regulons that
describe its state.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsConfiguredBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsConfiguredBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsConfiguredBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsConfiguredBy

    $return = $self->_get_relationship($ctx, 'IsConfiguredBy', 'IsConfiguredBy', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsConfiguredBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsConfiguredBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsConfiguredBy');
    }
    return($return);
}




=head2 get_relationship_ReflectsStateOf

  $return = $obj->get_relationship_ReflectsStateOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AtomicRegulon
	1: a fields_IsConfiguredBy
	2: a fields_Genome
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsConfiguredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AtomicRegulon
	1: a fields_IsConfiguredBy
	2: a fields_Genome
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsConfiguredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_ReflectsStateOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ReflectsStateOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ReflectsStateOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ReflectsStateOf

    $return = $self->_get_relationship($ctx, 'ReflectsStateOf', 'IsConfiguredBy', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ReflectsStateOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ReflectsStateOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ReflectsStateOf');
    }
    return($return);
}




=head2 get_relationship_IsConservedDomainModelFor

  $return = $obj->get_relationship_IsConservedDomainModelFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ConservedDomainModel
	1: a fields_IsConservedDomainModelFor
	2: a fields_ProteinSequence
fields_ConservedDomainModel is a reference to a hash where the following keys are defined:
	id has a value which is a string
	accession has a value which is a string
	short_name has a value which is a string
	description has a value which is a string
fields_IsConservedDomainModelFor is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
	percent_identity has a value which is a float
	alignment_length has a value which is an int
	mismatches has a value which is an int
	gap_openings has a value which is an int
	protein_start has a value which is an int
	protein_end has a value which is an int
	domain_start has a value which is an int
	domain_end has a value which is an int
	e_value has a value which is a float
	bit_score has a value which is a float
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ConservedDomainModel
	1: a fields_IsConservedDomainModelFor
	2: a fields_ProteinSequence
fields_ConservedDomainModel is a reference to a hash where the following keys are defined:
	id has a value which is a string
	accession has a value which is a string
	short_name has a value which is a string
	description has a value which is a string
fields_IsConservedDomainModelFor is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
	percent_identity has a value which is a float
	alignment_length has a value which is an int
	mismatches has a value which is an int
	gap_openings has a value which is an int
	protein_start has a value which is an int
	protein_end has a value which is an int
	domain_start has a value which is an int
	domain_end has a value which is an int
	e_value has a value which is a float
	bit_score has a value which is a float
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string


=end text



=item Description

This relationship connects a protein sequence with the conserved domains
that have been computed to be associated with it.


It has the following fields:

=over 4

=item percent_identity



=item alignment_length



=item mismatches



=item gap_openings



=item protein_start



=item protein_end



=item domain_start



=item domain_end



=item e_value



=item bit_score




=back

=back

=cut

sub get_relationship_IsConservedDomainModelFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsConservedDomainModelFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsConservedDomainModelFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsConservedDomainModelFor

    $return = $self->_get_relationship($ctx, 'IsConservedDomainModelFor', 'IsConservedDomainModelFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsConservedDomainModelFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsConservedDomainModelFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsConservedDomainModelFor');
    }
    return($return);
}




=head2 get_relationship_HasConservedDomainModel

  $return = $obj->get_relationship_HasConservedDomainModel($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProteinSequence
	1: a fields_IsConservedDomainModelFor
	2: a fields_ConservedDomainModel
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string
fields_IsConservedDomainModelFor is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
	percent_identity has a value which is a float
	alignment_length has a value which is an int
	mismatches has a value which is an int
	gap_openings has a value which is an int
	protein_start has a value which is an int
	protein_end has a value which is an int
	domain_start has a value which is an int
	domain_end has a value which is an int
	e_value has a value which is a float
	bit_score has a value which is a float
fields_ConservedDomainModel is a reference to a hash where the following keys are defined:
	id has a value which is a string
	accession has a value which is a string
	short_name has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProteinSequence
	1: a fields_IsConservedDomainModelFor
	2: a fields_ConservedDomainModel
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string
fields_IsConservedDomainModelFor is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
	percent_identity has a value which is a float
	alignment_length has a value which is an int
	mismatches has a value which is an int
	gap_openings has a value which is an int
	protein_start has a value which is an int
	protein_end has a value which is an int
	domain_start has a value which is an int
	domain_end has a value which is an int
	e_value has a value which is a float
	bit_score has a value which is a float
fields_ConservedDomainModel is a reference to a hash where the following keys are defined:
	id has a value which is a string
	accession has a value which is a string
	short_name has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasConservedDomainModel
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasConservedDomainModel:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasConservedDomainModel');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasConservedDomainModel

    $return = $self->_get_relationship($ctx, 'HasConservedDomainModel', 'IsConservedDomainModelFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasConservedDomainModel
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasConservedDomainModel:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasConservedDomainModel');
    }
    return($return);
}




=head2 get_relationship_IsConsistentWith

  $return = $obj->get_relationship_IsConsistentWith($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_EcNumber
	1: a fields_IsConsistentWith
	2: a fields_Role
fields_EcNumber is a reference to a hash where the following keys are defined:
	id has a value which is a string
	obsolete has a value which is an int
	replacedby has a value which is a string
fields_IsConsistentWith is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_EcNumber
	1: a fields_IsConsistentWith
	2: a fields_Role
fields_EcNumber is a reference to a hash where the following keys are defined:
	id has a value which is a string
	obsolete has a value which is an int
	replacedby has a value which is a string
fields_IsConsistentWith is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int


=end text



=item Description

This relationship connects a functional role to the EC numbers consistent
with the chemistry described in the role.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsConsistentWith
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsConsistentWith:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsConsistentWith');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsConsistentWith

    $return = $self->_get_relationship($ctx, 'IsConsistentWith', 'IsConsistentWith', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsConsistentWith
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsConsistentWith:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsConsistentWith');
    }
    return($return);
}




=head2 get_relationship_IsConsistentTo

  $return = $obj->get_relationship_IsConsistentTo($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Role
	1: a fields_IsConsistentWith
	2: a fields_EcNumber
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int
fields_IsConsistentWith is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_EcNumber is a reference to a hash where the following keys are defined:
	id has a value which is a string
	obsolete has a value which is an int
	replacedby has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Role
	1: a fields_IsConsistentWith
	2: a fields_EcNumber
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int
fields_IsConsistentWith is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_EcNumber is a reference to a hash where the following keys are defined:
	id has a value which is a string
	obsolete has a value which is an int
	replacedby has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsConsistentTo
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsConsistentTo:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsConsistentTo');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsConsistentTo

    $return = $self->_get_relationship($ctx, 'IsConsistentTo', 'IsConsistentWith', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsConsistentTo
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsConsistentTo:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsConsistentTo');
    }
    return($return);
}




=head2 get_relationship_IsContextOf

  $return = $obj->get_relationship_IsContextOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Environment
	1: a fields_IsContextOf
	2: a fields_ExperimentalUnit
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string
fields_IsContextOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Environment
	1: a fields_IsContextOf
	2: a fields_ExperimentalUnit
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string
fields_IsContextOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description

The IsContextOf relationship describes the enviroment a
subexperiment defined by an ExperimentalUnit was performed in.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsContextOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsContextOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsContextOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsContextOf

    $return = $self->_get_relationship($ctx, 'IsContextOf', 'IsContextOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsContextOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsContextOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsContextOf');
    }
    return($return);
}




=head2 get_relationship_HasEnvironment

  $return = $obj->get_relationship_HasEnvironment($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnit
	1: a fields_IsContextOf
	2: a fields_Environment
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_IsContextOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnit
	1: a fields_IsContextOf
	2: a fields_Environment
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_IsContextOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasEnvironment
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasEnvironment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasEnvironment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasEnvironment

    $return = $self->_get_relationship($ctx, 'HasEnvironment', 'IsContextOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasEnvironment
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasEnvironment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasEnvironment');
    }
    return($return);
}




=head2 get_relationship_IsCoregulatedWith

  $return = $obj->get_relationship_IsCoregulatedWith($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsCoregulatedWith
	2: a fields_Feature
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsCoregulatedWith is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsCoregulatedWith
	2: a fields_Feature
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsCoregulatedWith is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float


=end text



=item Description

This relationship connects a feature with another feature in the
same genome with which it appears to be coregulated as a result of
expression data analysis.

It has the following fields:

=over 4

=item coefficient

Pearson correlation coefficient for this coregulation.


=back

=back

=cut

sub get_relationship_IsCoregulatedWith
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsCoregulatedWith:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsCoregulatedWith');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsCoregulatedWith

    $return = $self->_get_relationship($ctx, 'IsCoregulatedWith', 'IsCoregulatedWith', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsCoregulatedWith
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsCoregulatedWith:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsCoregulatedWith');
    }
    return($return);
}




=head2 get_relationship_HasCoregulationWith

  $return = $obj->get_relationship_HasCoregulationWith($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsCoregulatedWith
	2: a fields_Feature
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsCoregulatedWith is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsCoregulatedWith
	2: a fields_Feature
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsCoregulatedWith is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float


=end text



=item Description



=back

=cut

sub get_relationship_HasCoregulationWith
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasCoregulationWith:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasCoregulationWith');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasCoregulationWith

    $return = $self->_get_relationship($ctx, 'HasCoregulationWith', 'IsCoregulatedWith', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasCoregulationWith
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasCoregulationWith:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasCoregulationWith');
    }
    return($return);
}




=head2 get_relationship_IsCoupledTo

  $return = $obj->get_relationship_IsCoupledTo($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Family
	1: a fields_IsCoupledTo
	2: a fields_Family
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string
fields_IsCoupledTo is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	co_occurrence_evidence has a value which is an int
	co_expression_evidence has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Family
	1: a fields_IsCoupledTo
	2: a fields_Family
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string
fields_IsCoupledTo is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	co_occurrence_evidence has a value which is an int
	co_expression_evidence has a value which is an int


=end text



=item Description

This relationship connects two FIGfams that we believe to be related
either because their members occur in proximity on chromosomes or because
the members are expressed together. Such a relationship is evidence the
functions of the FIGfams are themselves related. This relationship is
commutative; only the instance in which the first FIGfam has a lower ID
than the second is stored.

It has the following fields:

=over 4

=item co_occurrence_evidence

number of times members of the two FIGfams occur close to each other on chromosomes

=item co_expression_evidence

number of times members of the two FIGfams are co-expressed in expression data experiments


=back

=back

=cut

sub get_relationship_IsCoupledTo
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsCoupledTo:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsCoupledTo');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsCoupledTo

    $return = $self->_get_relationship($ctx, 'IsCoupledTo', 'IsCoupledTo', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsCoupledTo
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsCoupledTo:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsCoupledTo');
    }
    return($return);
}




=head2 get_relationship_IsCoupledWith

  $return = $obj->get_relationship_IsCoupledWith($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Family
	1: a fields_IsCoupledTo
	2: a fields_Family
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string
fields_IsCoupledTo is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	co_occurrence_evidence has a value which is an int
	co_expression_evidence has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Family
	1: a fields_IsCoupledTo
	2: a fields_Family
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string
fields_IsCoupledTo is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	co_occurrence_evidence has a value which is an int
	co_expression_evidence has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_IsCoupledWith
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsCoupledWith:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsCoupledWith');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsCoupledWith

    $return = $self->_get_relationship($ctx, 'IsCoupledWith', 'IsCoupledTo', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsCoupledWith
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsCoupledWith:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsCoupledWith');
    }
    return($return);
}




=head2 get_relationship_IsDatasetFor

  $return = $obj->get_relationship_IsDatasetFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AssociationDataset
	1: a fields_IsDatasetFor
	2: a fields_Genome
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string
fields_IsDatasetFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AssociationDataset
	1: a fields_IsDatasetFor
	2: a fields_Genome
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string
fields_IsDatasetFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description

The IsDatasetFor relationship describes which genomes
are covered by particular association datasets.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsDatasetFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsDatasetFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsDatasetFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsDatasetFor

    $return = $self->_get_relationship($ctx, 'IsDatasetFor', 'IsDatasetFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsDatasetFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsDatasetFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsDatasetFor');
    }
    return($return);
}




=head2 get_relationship_HasAssociationDataset

  $return = $obj->get_relationship_HasAssociationDataset($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsDatasetFor
	2: a fields_AssociationDataset
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsDatasetFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsDatasetFor
	2: a fields_AssociationDataset
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsDatasetFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasAssociationDataset
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasAssociationDataset:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasAssociationDataset');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasAssociationDataset

    $return = $self->_get_relationship($ctx, 'HasAssociationDataset', 'IsDatasetFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasAssociationDataset
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasAssociationDataset:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasAssociationDataset');
    }
    return($return);
}




=head2 get_relationship_IsDeterminedBy

  $return = $obj->get_relationship_IsDeterminedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_PairSet
	1: a fields_IsDeterminedBy
	2: a fields_Pairing
fields_PairSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	score has a value which is an int
fields_IsDeterminedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	inverted has a value which is an int
fields_Pairing is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_PairSet
	1: a fields_IsDeterminedBy
	2: a fields_Pairing
fields_PairSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	score has a value which is an int
fields_IsDeterminedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	inverted has a value which is an int
fields_Pairing is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

A functional coupling evidence set exists because it has
pairings in it, and this relationship connects the evidence set to
its constituent pairings. A pairing cam belong to multiple evidence
sets.

It has the following fields:

=over 4

=item inverted

A pairing is an unordered pair of protein sequences, but its similarity to other pairings in a pair set is ordered. Let (A,B) be a pairing and (X,Y) be another pairing in the same set. If this flag is FALSE, then (A =~ X) and (B =~ Y). If this flag is TRUE, then (A =~ Y) and (B =~ X).


=back

=back

=cut

sub get_relationship_IsDeterminedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsDeterminedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsDeterminedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsDeterminedBy

    $return = $self->_get_relationship($ctx, 'IsDeterminedBy', 'IsDeterminedBy', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsDeterminedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsDeterminedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsDeterminedBy');
    }
    return($return);
}




=head2 get_relationship_Determines

  $return = $obj->get_relationship_Determines($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Pairing
	1: a fields_IsDeterminedBy
	2: a fields_PairSet
fields_Pairing is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsDeterminedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	inverted has a value which is an int
fields_PairSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	score has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Pairing
	1: a fields_IsDeterminedBy
	2: a fields_PairSet
fields_Pairing is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsDeterminedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	inverted has a value which is an int
fields_PairSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	score has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_Determines
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Determines:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Determines');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Determines

    $return = $self->_get_relationship($ctx, 'Determines', 'IsDeterminedBy', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Determines
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Determines:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Determines');
    }
    return($return);
}




=head2 get_relationship_IsDividedInto

  $return = $obj->get_relationship_IsDividedInto($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Model
	1: a fields_IsDividedInto
	2: a fields_LocationInstance
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int
fields_IsDividedInto is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Model
	1: a fields_IsDividedInto
	2: a fields_LocationInstance
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int
fields_IsDividedInto is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float


=end text



=item Description

This relationship connects a model to its instances of
subcellular locations that participate in the model.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsDividedInto
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsDividedInto:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsDividedInto');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsDividedInto

    $return = $self->_get_relationship($ctx, 'IsDividedInto', 'IsDividedInto', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsDividedInto
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsDividedInto:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsDividedInto');
    }
    return($return);
}




=head2 get_relationship_IsDivisionOf

  $return = $obj->get_relationship_IsDivisionOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_LocationInstance
	1: a fields_IsDividedInto
	2: a fields_Model
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float
fields_IsDividedInto is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_LocationInstance
	1: a fields_IsDividedInto
	2: a fields_Model
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float
fields_IsDividedInto is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_IsDivisionOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsDivisionOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsDivisionOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsDivisionOf

    $return = $self->_get_relationship($ctx, 'IsDivisionOf', 'IsDividedInto', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsDivisionOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsDivisionOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsDivisionOf');
    }
    return($return);
}




=head2 get_relationship_IsExecutedAs

  $return = $obj->get_relationship_IsExecutedAs($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Reaction
	1: a fields_IsExecutedAs
	2: a fields_ReactionInstance
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string
fields_IsExecutedAs is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Reaction
	1: a fields_IsExecutedAs
	2: a fields_ReactionInstance
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string
fields_IsExecutedAs is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float


=end text



=item Description

This relationship links a reaction to the way it is used in a model.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsExecutedAs
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsExecutedAs:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsExecutedAs');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsExecutedAs

    $return = $self->_get_relationship($ctx, 'IsExecutedAs', 'IsExecutedAs', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsExecutedAs
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsExecutedAs:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsExecutedAs');
    }
    return($return);
}




=head2 get_relationship_IsExecutionOf

  $return = $obj->get_relationship_IsExecutionOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ReactionInstance
	1: a fields_IsExecutedAs
	2: a fields_Reaction
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float
fields_IsExecutedAs is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ReactionInstance
	1: a fields_IsExecutedAs
	2: a fields_Reaction
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float
fields_IsExecutedAs is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is a string
	direction has a value which is a string
	deltaG has a value which is a float
	deltaG_error has a value which is a float
	thermodynamic_reversibility has a value which is a string
	default_protons has a value which is a float
	status has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsExecutionOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsExecutionOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsExecutionOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsExecutionOf

    $return = $self->_get_relationship($ctx, 'IsExecutionOf', 'IsExecutedAs', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsExecutionOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsExecutionOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsExecutionOf');
    }
    return($return);
}




=head2 get_relationship_IsExemplarOf

  $return = $obj->get_relationship_IsExemplarOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsExemplarOf
	2: a fields_Role
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsExemplarOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsExemplarOf
	2: a fields_Role
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsExemplarOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int


=end text



=item Description

This relationship links a role to a feature that provides a typical
example of how the role is implemented.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsExemplarOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsExemplarOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsExemplarOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsExemplarOf

    $return = $self->_get_relationship($ctx, 'IsExemplarOf', 'IsExemplarOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsExemplarOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsExemplarOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsExemplarOf');
    }
    return($return);
}




=head2 get_relationship_HasAsExemplar

  $return = $obj->get_relationship_HasAsExemplar($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Role
	1: a fields_IsExemplarOf
	2: a fields_Feature
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int
fields_IsExemplarOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Role
	1: a fields_IsExemplarOf
	2: a fields_Feature
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int
fields_IsExemplarOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasAsExemplar
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasAsExemplar:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasAsExemplar');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasAsExemplar

    $return = $self->_get_relationship($ctx, 'HasAsExemplar', 'IsExemplarOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasAsExemplar
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasAsExemplar:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasAsExemplar');
    }
    return($return);
}




=head2 get_relationship_IsFamilyFor

  $return = $obj->get_relationship_IsFamilyFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Family
	1: a fields_IsFamilyFor
	2: a fields_Role
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string
fields_IsFamilyFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Family
	1: a fields_IsFamilyFor
	2: a fields_Role
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string
fields_IsFamilyFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int


=end text



=item Description

This relationship connects an isofunctional family to the roles that
make up its assigned function.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsFamilyFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsFamilyFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsFamilyFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsFamilyFor

    $return = $self->_get_relationship($ctx, 'IsFamilyFor', 'IsFamilyFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsFamilyFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsFamilyFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsFamilyFor');
    }
    return($return);
}




=head2 get_relationship_DeterminesFunctionOf

  $return = $obj->get_relationship_DeterminesFunctionOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Role
	1: a fields_IsFamilyFor
	2: a fields_Family
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int
fields_IsFamilyFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Role
	1: a fields_IsFamilyFor
	2: a fields_Family
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int
fields_IsFamilyFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Family is a reference to a hash where the following keys are defined:
	id has a value which is a string
	type has a value which is a string
	release has a value which is a string
	family_function has a value which is a reference to a list where each element is a string
	alignment has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_DeterminesFunctionOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_DeterminesFunctionOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DeterminesFunctionOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_DeterminesFunctionOf

    $return = $self->_get_relationship($ctx, 'DeterminesFunctionOf', 'IsFamilyFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_DeterminesFunctionOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_DeterminesFunctionOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DeterminesFunctionOf');
    }
    return($return);
}




=head2 get_relationship_IsFormedOf

  $return = $obj->get_relationship_IsFormedOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AtomicRegulon
	1: a fields_IsFormedOf
	2: a fields_Feature
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsFormedOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AtomicRegulon
	1: a fields_IsFormedOf
	2: a fields_Feature
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsFormedOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description

This relationship connects each feature to the atomic regulon to
which it belongs.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsFormedOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsFormedOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsFormedOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsFormedOf

    $return = $self->_get_relationship($ctx, 'IsFormedOf', 'IsFormedOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsFormedOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsFormedOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsFormedOf');
    }
    return($return);
}




=head2 get_relationship_IsFormedInto

  $return = $obj->get_relationship_IsFormedInto($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsFormedOf
	2: a fields_AtomicRegulon
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsFormedOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsFormedOf
	2: a fields_AtomicRegulon
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsFormedOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_AtomicRegulon is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsFormedInto
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsFormedInto:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsFormedInto');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsFormedInto

    $return = $self->_get_relationship($ctx, 'IsFormedInto', 'IsFormedOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsFormedInto
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsFormedInto:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsFormedInto');
    }
    return($return);
}




=head2 get_relationship_IsFunctionalIn

  $return = $obj->get_relationship_IsFunctionalIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Role
	1: a fields_IsFunctionalIn
	2: a fields_Feature
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int
fields_IsFunctionalIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Role
	1: a fields_IsFunctionalIn
	2: a fields_Feature
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int
fields_IsFunctionalIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description

This relationship connects a role with the features in which
it plays a functional part.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsFunctionalIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsFunctionalIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsFunctionalIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsFunctionalIn

    $return = $self->_get_relationship($ctx, 'IsFunctionalIn', 'IsFunctionalIn', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsFunctionalIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsFunctionalIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsFunctionalIn');
    }
    return($return);
}




=head2 get_relationship_HasFunctional

  $return = $obj->get_relationship_HasFunctional($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsFunctionalIn
	2: a fields_Role
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsFunctionalIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsFunctionalIn
	2: a fields_Role
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsFunctionalIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_HasFunctional
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasFunctional:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasFunctional');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasFunctional

    $return = $self->_get_relationship($ctx, 'HasFunctional', 'IsFunctionalIn', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasFunctional
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasFunctional:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasFunctional');
    }
    return($return);
}




=head2 get_relationship_IsGroupFor

  $return = $obj->get_relationship_IsGroupFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_TaxonomicGrouping
	1: a fields_IsGroupFor
	2: a fields_TaxonomicGrouping
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsGroupFor is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_TaxonomicGrouping
	1: a fields_IsGroupFor
	2: a fields_TaxonomicGrouping
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsGroupFor is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is an int


=end text



=item Description

The recursive IsGroupFor relationship organizes
taxonomic groupings into a hierarchy based on the standard organism
taxonomy.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsGroupFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsGroupFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsGroupFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsGroupFor

    $return = $self->_get_relationship($ctx, 'IsGroupFor', 'IsGroupFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsGroupFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsGroupFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsGroupFor');
    }
    return($return);
}




=head2 get_relationship_IsInGroup

  $return = $obj->get_relationship_IsInGroup($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_TaxonomicGrouping
	1: a fields_IsGroupFor
	2: a fields_TaxonomicGrouping
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsGroupFor is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_TaxonomicGrouping
	1: a fields_IsGroupFor
	2: a fields_TaxonomicGrouping
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsGroupFor is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_IsInGroup
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsInGroup:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInGroup');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsInGroup

    $return = $self->_get_relationship($ctx, 'IsInGroup', 'IsGroupFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsInGroup
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsInGroup:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInGroup');
    }
    return($return);
}




=head2 get_relationship_IsGroupingOf

  $return = $obj->get_relationship_IsGroupingOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AssociationDataset
	1: a fields_IsGroupingOf
	2: a fields_Association
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string
fields_IsGroupingOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AssociationDataset
	1: a fields_IsGroupingOf
	2: a fields_Association
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string
fields_IsGroupingOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string


=end text



=item Description

The IsGroupingOf relationship describes which
associations are part of a particular association
dataset.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsGroupingOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsGroupingOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsGroupingOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsGroupingOf

    $return = $self->_get_relationship($ctx, 'IsGroupingOf', 'IsGroupingOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsGroupingOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsGroupingOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsGroupingOf');
    }
    return($return);
}




=head2 get_relationship_InAssociationDataset

  $return = $obj->get_relationship_InAssociationDataset($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Association
	1: a fields_IsGroupingOf
	2: a fields_AssociationDataset
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string
fields_IsGroupingOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Association
	1: a fields_IsGroupingOf
	2: a fields_AssociationDataset
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string
fields_IsGroupingOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_InAssociationDataset
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_InAssociationDataset:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_InAssociationDataset');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_InAssociationDataset

    $return = $self->_get_relationship($ctx, 'InAssociationDataset', 'IsGroupingOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_InAssociationDataset
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_InAssociationDataset:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_InAssociationDataset');
    }
    return($return);
}




=head2 get_relationship_IsImplementedBy

  $return = $obj->get_relationship_IsImplementedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Variant
	1: a fields_IsImplementedBy
	2: a fields_SSRow
fields_Variant is a reference to a hash where the following keys are defined:
	id has a value which is a string
	role_rule has a value which is a reference to a list where each element is a string
	code has a value which is a string
	type has a value which is a string
	comment has a value which is a string
fields_IsImplementedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Variant
	1: a fields_IsImplementedBy
	2: a fields_SSRow
fields_Variant is a reference to a hash where the following keys are defined:
	id has a value which is a string
	role_rule has a value which is a reference to a list where each element is a string
	code has a value which is a string
	type has a value which is a string
	comment has a value which is a string
fields_IsImplementedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string


=end text



=item Description

This relationship connects a variant to the physical machines
that implement it in the genomes. A variant is implemented by many
machines, but a machine belongs to only one variant.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsImplementedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsImplementedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsImplementedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsImplementedBy

    $return = $self->_get_relationship($ctx, 'IsImplementedBy', 'IsImplementedBy', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsImplementedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsImplementedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsImplementedBy');
    }
    return($return);
}




=head2 get_relationship_Implements

  $return = $obj->get_relationship_Implements($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SSRow
	1: a fields_IsImplementedBy
	2: a fields_Variant
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string
fields_IsImplementedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Variant is a reference to a hash where the following keys are defined:
	id has a value which is a string
	role_rule has a value which is a reference to a list where each element is a string
	code has a value which is a string
	type has a value which is a string
	comment has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SSRow
	1: a fields_IsImplementedBy
	2: a fields_Variant
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string
fields_IsImplementedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Variant is a reference to a hash where the following keys are defined:
	id has a value which is a string
	role_rule has a value which is a reference to a list where each element is a string
	code has a value which is a string
	type has a value which is a string
	comment has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_Implements
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Implements:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Implements');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Implements

    $return = $self->_get_relationship($ctx, 'Implements', 'IsImplementedBy', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Implements
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Implements:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Implements');
    }
    return($return);
}




=head2 get_relationship_IsInOperon

  $return = $obj->get_relationship_IsInOperon($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsInOperon
	2: a fields_Operon
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsInOperon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	rank has a value which is an int
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsInOperon
	2: a fields_Operon
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsInOperon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	rank has a value which is an int
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

It has the following fields:

=over 4

=item rank

The rank (order) of this feature in the operon.


=back

=back

=cut

sub get_relationship_IsInOperon
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsInOperon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInOperon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsInOperon

    $return = $self->_get_relationship($ctx, 'IsInOperon', 'IsInOperon', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsInOperon
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsInOperon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInOperon');
    }
    return($return);
}




=head2 get_relationship_OperonContains

  $return = $obj->get_relationship_OperonContains($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Operon
	1: a fields_IsInOperon
	2: a fields_Feature
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsInOperon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	rank has a value which is an int
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Operon
	1: a fields_IsInOperon
	2: a fields_Feature
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsInOperon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	rank has a value which is an int
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_OperonContains
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_OperonContains:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_OperonContains');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_OperonContains

    $return = $self->_get_relationship($ctx, 'OperonContains', 'IsInOperon', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_OperonContains
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_OperonContains:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_OperonContains');
    }
    return($return);
}




=head2 get_relationship_IsInPair

  $return = $obj->get_relationship_IsInPair($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsInPair
	2: a fields_Pairing
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsInPair is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Pairing is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsInPair
	2: a fields_Pairing
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsInPair is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Pairing is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

A pairing contains exactly two protein sequences. A protein
sequence can belong to multiple pairings. When going from a protein
sequence to its pairings, they are presented in alphabetical order
by sequence key.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsInPair
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsInPair:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInPair');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsInPair

    $return = $self->_get_relationship($ctx, 'IsInPair', 'IsInPair', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsInPair
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsInPair:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInPair');
    }
    return($return);
}




=head2 get_relationship_IsPairOf

  $return = $obj->get_relationship_IsPairOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Pairing
	1: a fields_IsInPair
	2: a fields_Feature
fields_Pairing is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsInPair is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Pairing
	1: a fields_IsInPair
	2: a fields_Feature
fields_Pairing is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsInPair is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsPairOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsPairOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsPairOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsPairOf

    $return = $self->_get_relationship($ctx, 'IsPairOf', 'IsInPair', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsPairOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsPairOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsPairOf');
    }
    return($return);
}




=head2 get_relationship_IsInstantiatedBy

  $return = $obj->get_relationship_IsInstantiatedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Location
	1: a fields_IsInstantiatedBy
	2: a fields_LocationInstance
fields_Location is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is an int
fields_IsInstantiatedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Location
	1: a fields_IsInstantiatedBy
	2: a fields_LocationInstance
fields_Location is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is an int
fields_IsInstantiatedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float


=end text



=item Description

This relationship connects a subcellular location to the instances
of that location that occur in models.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsInstantiatedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsInstantiatedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInstantiatedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsInstantiatedBy

    $return = $self->_get_relationship($ctx, 'IsInstantiatedBy', 'IsInstantiatedBy', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsInstantiatedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsInstantiatedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInstantiatedBy');
    }
    return($return);
}




=head2 get_relationship_IsInstanceOf

  $return = $obj->get_relationship_IsInstanceOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_LocationInstance
	1: a fields_IsInstantiatedBy
	2: a fields_Location
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float
fields_IsInstantiatedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Location is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_LocationInstance
	1: a fields_IsInstantiatedBy
	2: a fields_Location
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float
fields_IsInstantiatedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Location is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_IsInstanceOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsInstanceOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInstanceOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsInstanceOf

    $return = $self->_get_relationship($ctx, 'IsInstanceOf', 'IsInstantiatedBy', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsInstanceOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsInstanceOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInstanceOf');
    }
    return($return);
}




=head2 get_relationship_IsLocatedIn

  $return = $obj->get_relationship_IsLocatedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsLocatedIn
	2: a fields_Contig
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsLocatedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	ordinal has a value which is an int
	begin has a value which is an int
	len has a value which is an int
	dir has a value which is a string
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsLocatedIn
	2: a fields_Contig
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsLocatedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	ordinal has a value which is an int
	begin has a value which is an int
	len has a value which is an int
	dir has a value which is a string
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description

A feature is a set of DNA sequence fragments, the location of
which are specified by the fields of this relationship. Most features
are a single contiguous fragment, so they are located in only one
DNA sequence; however, for search optimization reasons, fragments
have a maximum length, so even a single contiguous feature may
participate in this relationship multiple times. Thus, it is better
to use the CDMI API methods to get feature positions and sequences
as those methods rejoin the fragements for contiguous features. A few
features belong to multiple DNA sequences. In that case, however, all
the DNA sequences belong to the same genome. A DNA sequence itself
will frequently have thousands of features connected to it.

It has the following fields:

=over 4

=item ordinal

Sequence number of this segment, starting from 1 and proceeding sequentially forward from there.

=item begin

Index (1-based) of the first residue in the contig that belongs to the segment.

=item len

Length of this segment.

=item dir

Direction (strand) of the segment: "+" if it is forward and "-" if it is backward.


=back

=back

=cut

sub get_relationship_IsLocatedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsLocatedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsLocatedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsLocatedIn

    $return = $self->_get_relationship($ctx, 'IsLocatedIn', 'IsLocatedIn', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsLocatedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsLocatedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsLocatedIn');
    }
    return($return);
}




=head2 get_relationship_IsLocusFor

  $return = $obj->get_relationship_IsLocusFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Contig
	1: a fields_IsLocatedIn
	2: a fields_Feature
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_IsLocatedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	ordinal has a value which is an int
	begin has a value which is an int
	len has a value which is an int
	dir has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Contig
	1: a fields_IsLocatedIn
	2: a fields_Feature
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_IsLocatedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	ordinal has a value which is an int
	begin has a value which is an int
	len has a value which is an int
	dir has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsLocusFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsLocusFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsLocusFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsLocusFor

    $return = $self->_get_relationship($ctx, 'IsLocusFor', 'IsLocatedIn', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsLocusFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsLocusFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsLocusFor');
    }
    return($return);
}




=head2 get_relationship_IsMeasurementMethodOf

  $return = $obj->get_relationship_IsMeasurementMethodOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Protocol
	1: a fields_IsMeasurementMethodOf
	2: a fields_Measurement
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
fields_IsMeasurementMethodOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Protocol
	1: a fields_IsMeasurementMethodOf
	2: a fields_Measurement
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
fields_IsMeasurementMethodOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float


=end text



=item Description

The IsMeasurementMethodOf relationship describes which protocol
was used to take a measurement.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsMeasurementMethodOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsMeasurementMethodOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsMeasurementMethodOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsMeasurementMethodOf

    $return = $self->_get_relationship($ctx, 'IsMeasurementMethodOf', 'IsMeasurementMethodOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsMeasurementMethodOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsMeasurementMethodOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsMeasurementMethodOf');
    }
    return($return);
}




=head2 get_relationship_WasMeasuredBy

  $return = $obj->get_relationship_WasMeasuredBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Measurement
	1: a fields_IsMeasurementMethodOf
	2: a fields_Protocol
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float
fields_IsMeasurementMethodOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Measurement
	1: a fields_IsMeasurementMethodOf
	2: a fields_Protocol
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float
fields_IsMeasurementMethodOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_WasMeasuredBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_WasMeasuredBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_WasMeasuredBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_WasMeasuredBy

    $return = $self->_get_relationship($ctx, 'WasMeasuredBy', 'IsMeasurementMethodOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_WasMeasuredBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_WasMeasuredBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_WasMeasuredBy');
    }
    return($return);
}




=head2 get_relationship_IsModeledBy

  $return = $obj->get_relationship_IsModeledBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsModeledBy
	2: a fields_Model
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsModeledBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsModeledBy
	2: a fields_Model
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsModeledBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int


=end text



=item Description

A genome can be modeled by many different models, but a model belongs
to only one genome.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsModeledBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsModeledBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsModeledBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsModeledBy

    $return = $self->_get_relationship($ctx, 'IsModeledBy', 'IsModeledBy', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsModeledBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsModeledBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsModeledBy');
    }
    return($return);
}




=head2 get_relationship_Models

  $return = $obj->get_relationship_Models($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Model
	1: a fields_IsModeledBy
	2: a fields_Genome
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int
fields_IsModeledBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Model
	1: a fields_IsModeledBy
	2: a fields_Genome
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int
fields_IsModeledBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_Models
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Models:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Models');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Models

    $return = $self->_get_relationship($ctx, 'Models', 'IsModeledBy', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Models
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Models:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Models');
    }
    return($return);
}




=head2 get_relationship_IsModifiedToBuildAlignment

  $return = $obj->get_relationship_IsModifiedToBuildAlignment($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_IsModifiedToBuildAlignment
	2: a fields_Alignment
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_IsModifiedToBuildAlignment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	modification_type has a value which is a string
	modification_value has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_IsModifiedToBuildAlignment
	2: a fields_Alignment
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_IsModifiedToBuildAlignment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	modification_type has a value which is a string
	modification_value has a value which is a string


=end text



=item Description

Relates an alignment to other alignments built from it.

It has the following fields:

=over 4

=item modification_type

description of how the alignment was modified

=item modification_value

description of any parameters used to derive the modification


=back

=back

=cut

sub get_relationship_IsModifiedToBuildAlignment
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsModifiedToBuildAlignment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsModifiedToBuildAlignment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsModifiedToBuildAlignment

    $return = $self->_get_relationship($ctx, 'IsModifiedToBuildAlignment', 'IsModifiedToBuildAlignment', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsModifiedToBuildAlignment
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsModifiedToBuildAlignment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsModifiedToBuildAlignment');
    }
    return($return);
}




=head2 get_relationship_IsModificationOfAlignment

  $return = $obj->get_relationship_IsModificationOfAlignment($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_IsModifiedToBuildAlignment
	2: a fields_Alignment
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_IsModifiedToBuildAlignment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	modification_type has a value which is a string
	modification_value has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_IsModifiedToBuildAlignment
	2: a fields_Alignment
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_IsModifiedToBuildAlignment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	modification_type has a value which is a string
	modification_value has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsModificationOfAlignment
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsModificationOfAlignment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsModificationOfAlignment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsModificationOfAlignment

    $return = $self->_get_relationship($ctx, 'IsModificationOfAlignment', 'IsModifiedToBuildAlignment', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsModificationOfAlignment
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsModificationOfAlignment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsModificationOfAlignment');
    }
    return($return);
}




=head2 get_relationship_IsModifiedToBuildTree

  $return = $obj->get_relationship_IsModifiedToBuildTree($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_IsModifiedToBuildTree
	2: a fields_Tree
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_IsModifiedToBuildTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	modification_type has a value which is a string
	modification_value has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_IsModifiedToBuildTree
	2: a fields_Tree
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_IsModifiedToBuildTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	modification_type has a value which is a string
	modification_value has a value which is a string


=end text



=item Description

Relates a tree to other trees built from it.

It has the following fields:

=over 4

=item modification_type

description of how the tree was modified (rerooted, annotated, etc.)

=item modification_value

description of any parameters used to derive the modification


=back

=back

=cut

sub get_relationship_IsModifiedToBuildTree
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsModifiedToBuildTree:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsModifiedToBuildTree');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsModifiedToBuildTree

    $return = $self->_get_relationship($ctx, 'IsModifiedToBuildTree', 'IsModifiedToBuildTree', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsModifiedToBuildTree
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsModifiedToBuildTree:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsModifiedToBuildTree');
    }
    return($return);
}




=head2 get_relationship_IsModificationOfTree

  $return = $obj->get_relationship_IsModificationOfTree($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_IsModifiedToBuildTree
	2: a fields_Tree
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_IsModifiedToBuildTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	modification_type has a value which is a string
	modification_value has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_IsModifiedToBuildTree
	2: a fields_Tree
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_IsModifiedToBuildTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	modification_type has a value which is a string
	modification_value has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsModificationOfTree
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsModificationOfTree:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsModificationOfTree');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsModificationOfTree

    $return = $self->_get_relationship($ctx, 'IsModificationOfTree', 'IsModifiedToBuildTree', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsModificationOfTree
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsModificationOfTree:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsModificationOfTree');
    }
    return($return);
}




=head2 get_relationship_IsOwnerOf

  $return = $obj->get_relationship_IsOwnerOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsOwnerOf
	2: a fields_Feature
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsOwnerOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsOwnerOf
	2: a fields_Feature
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsOwnerOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description

This relationship connects a genome to the features it
contains. Though technically redundant (the information is
available from the feature's contigs), it simplifies the
extremely common process of finding all features for a
genome.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsOwnerOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsOwnerOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsOwnerOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsOwnerOf

    $return = $self->_get_relationship($ctx, 'IsOwnerOf', 'IsOwnerOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsOwnerOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsOwnerOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsOwnerOf');
    }
    return($return);
}




=head2 get_relationship_IsOwnedBy

  $return = $obj->get_relationship_IsOwnedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsOwnerOf
	2: a fields_Genome
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsOwnerOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsOwnerOf
	2: a fields_Genome
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsOwnerOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsOwnedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsOwnedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsOwnedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsOwnedBy

    $return = $self->_get_relationship($ctx, 'IsOwnedBy', 'IsOwnerOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsOwnedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsOwnedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsOwnedBy');
    }
    return($return);
}




=head2 get_relationship_IsParticipatingAt

  $return = $obj->get_relationship_IsParticipatingAt($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Location
	1: a fields_IsParticipatingAt
	2: a fields_LocalizedCompound
fields_Location is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is an int
fields_IsParticipatingAt is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Location
	1: a fields_IsParticipatingAt
	2: a fields_LocalizedCompound
fields_Location is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is an int
fields_IsParticipatingAt is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

This relationship connects a localized compound to the
location in which it occurs during one or more reactions.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsParticipatingAt
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsParticipatingAt:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsParticipatingAt');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsParticipatingAt

    $return = $self->_get_relationship($ctx, 'IsParticipatingAt', 'IsParticipatingAt', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsParticipatingAt
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsParticipatingAt:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsParticipatingAt');
    }
    return($return);
}




=head2 get_relationship_ParticipatesAt

  $return = $obj->get_relationship_ParticipatesAt($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_LocalizedCompound
	1: a fields_IsParticipatingAt
	2: a fields_Location
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsParticipatingAt is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Location is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_LocalizedCompound
	1: a fields_IsParticipatingAt
	2: a fields_Location
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsParticipatingAt is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Location is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	source_id has a value which is a string
	abbr has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_ParticipatesAt
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ParticipatesAt:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ParticipatesAt');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ParticipatesAt

    $return = $self->_get_relationship($ctx, 'ParticipatesAt', 'IsParticipatingAt', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ParticipatesAt
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ParticipatesAt:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ParticipatesAt');
    }
    return($return);
}




=head2 get_relationship_IsProteinFor

  $return = $obj->get_relationship_IsProteinFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProteinSequence
	1: a fields_IsProteinFor
	2: a fields_Feature
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string
fields_IsProteinFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProteinSequence
	1: a fields_IsProteinFor
	2: a fields_Feature
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string
fields_IsProteinFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description

This relationship connects a peg feature to the protein
sequence it produces (if any). Only peg features participate in this
relationship. A single protein sequence will frequently be produced
by many features.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsProteinFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsProteinFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsProteinFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsProteinFor

    $return = $self->_get_relationship($ctx, 'IsProteinFor', 'IsProteinFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsProteinFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsProteinFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsProteinFor');
    }
    return($return);
}




=head2 get_relationship_Produces

  $return = $obj->get_relationship_Produces($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsProteinFor
	2: a fields_ProteinSequence
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsProteinFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsProteinFor
	2: a fields_ProteinSequence
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsProteinFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ProteinSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	sequence has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_Produces
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Produces:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Produces');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Produces

    $return = $self->_get_relationship($ctx, 'Produces', 'IsProteinFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Produces
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Produces:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Produces');
    }
    return($return);
}




=head2 get_relationship_IsReagentIn

  $return = $obj->get_relationship_IsReagentIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CompoundInstance
	1: a fields_IsReagentIn
	2: a fields_ReactionInstance
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string
fields_IsReagentIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CompoundInstance
	1: a fields_IsReagentIn
	2: a fields_ReactionInstance
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string
fields_IsReagentIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float


=end text



=item Description

This relationship connects a compound instance to the reaction instance
in which it is transformed.

It has the following fields:

=over 4

=item coefficient

Number of molecules of the compound that participate in a single instance of the reaction. For example, if a reaction produces two water molecules, the stoichiometry of water for the reaction would be two. When a reaction is written on paper in chemical notation, the stoichiometry is the number next to the chemical formula of the compound. The value is negative for substrates and positive for products.


=back

=back

=cut

sub get_relationship_IsReagentIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsReagentIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsReagentIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsReagentIn

    $return = $self->_get_relationship($ctx, 'IsReagentIn', 'IsReagentIn', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsReagentIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsReagentIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsReagentIn');
    }
    return($return);
}




=head2 get_relationship_Targets

  $return = $obj->get_relationship_Targets($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ReactionInstance
	1: a fields_IsReagentIn
	2: a fields_CompoundInstance
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float
fields_IsReagentIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ReactionInstance
	1: a fields_IsReagentIn
	2: a fields_CompoundInstance
fields_ReactionInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	direction has a value which is a string
	protons has a value which is a float
fields_IsReagentIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	coefficient has a value which is a float
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_Targets
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Targets:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Targets');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Targets

    $return = $self->_get_relationship($ctx, 'Targets', 'IsReagentIn', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Targets
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Targets:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Targets');
    }
    return($return);
}




=head2 get_relationship_IsRealLocationOf

  $return = $obj->get_relationship_IsRealLocationOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_LocationInstance
	1: a fields_IsRealLocationOf
	2: a fields_CompoundInstance
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float
fields_IsRealLocationOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_LocationInstance
	1: a fields_IsRealLocationOf
	2: a fields_CompoundInstance
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float
fields_IsRealLocationOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string


=end text



=item Description

This relationship connects a specific instance of a compound in a model
to the specific instance of the model subcellular location where the compound exists.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsRealLocationOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsRealLocationOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRealLocationOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsRealLocationOf

    $return = $self->_get_relationship($ctx, 'IsRealLocationOf', 'IsRealLocationOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsRealLocationOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsRealLocationOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRealLocationOf');
    }
    return($return);
}




=head2 get_relationship_HasRealLocationIn

  $return = $obj->get_relationship_HasRealLocationIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CompoundInstance
	1: a fields_IsRealLocationOf
	2: a fields_LocationInstance
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string
fields_IsRealLocationOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CompoundInstance
	1: a fields_IsRealLocationOf
	2: a fields_LocationInstance
fields_CompoundInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	charge has a value which is a float
	formula has a value which is a string
fields_IsRealLocationOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_LocationInstance is a reference to a hash where the following keys are defined:
	id has a value which is a string
	index has a value which is an int
	label has a value which is a reference to a list where each element is a string
	pH has a value which is a float
	potential has a value which is a float


=end text



=item Description



=back

=cut

sub get_relationship_HasRealLocationIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasRealLocationIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasRealLocationIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasRealLocationIn

    $return = $self->_get_relationship($ctx, 'HasRealLocationIn', 'IsRealLocationOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasRealLocationIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasRealLocationIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasRealLocationIn');
    }
    return($return);
}




=head2 get_relationship_IsReferencedBy

  $return = $obj->get_relationship_IsReferencedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsReferencedBy
	2: a fields_ObservationalUnit
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsReferencedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsReferencedBy
	2: a fields_ObservationalUnit
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsReferencedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string


=end text



=item Description

This relationship associates each observational unit with the reference
genome that it will be compared to.  All variations will be differences
between the observational unit and the reference.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsReferencedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsReferencedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsReferencedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsReferencedBy

    $return = $self->_get_relationship($ctx, 'IsReferencedBy', 'IsReferencedBy', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsReferencedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsReferencedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsReferencedBy');
    }
    return($return);
}




=head2 get_relationship_UsesReference

  $return = $obj->get_relationship_UsesReference($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ObservationalUnit
	1: a fields_IsReferencedBy
	2: a fields_Genome
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string
fields_IsReferencedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ObservationalUnit
	1: a fields_IsReferencedBy
	2: a fields_Genome
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string
fields_IsReferencedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_UsesReference
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_UsesReference:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_UsesReference');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_UsesReference

    $return = $self->_get_relationship($ctx, 'UsesReference', 'IsReferencedBy', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_UsesReference
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_UsesReference:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_UsesReference');
    }
    return($return);
}




=head2 get_relationship_IsRegulatedIn

  $return = $obj->get_relationship_IsRegulatedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsRegulatedIn
	2: a fields_CoregulatedSet
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsRegulatedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsRegulatedIn
	2: a fields_CoregulatedSet
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsRegulatedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int


=end text



=item Description

This relationship connects a feature to the set of coregulated features.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsRegulatedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsRegulatedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRegulatedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsRegulatedIn

    $return = $self->_get_relationship($ctx, 'IsRegulatedIn', 'IsRegulatedIn', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsRegulatedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsRegulatedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRegulatedIn');
    }
    return($return);
}




=head2 get_relationship_IsRegulatedSetOf

  $return = $obj->get_relationship_IsRegulatedSetOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CoregulatedSet
	1: a fields_IsRegulatedIn
	2: a fields_Feature
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int
fields_IsRegulatedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CoregulatedSet
	1: a fields_IsRegulatedIn
	2: a fields_Feature
fields_CoregulatedSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	binding_location has a value which is a reference to a list where each element is an int
fields_IsRegulatedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsRegulatedSetOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsRegulatedSetOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRegulatedSetOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsRegulatedSetOf

    $return = $self->_get_relationship($ctx, 'IsRegulatedSetOf', 'IsRegulatedIn', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsRegulatedSetOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsRegulatedSetOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRegulatedSetOf');
    }
    return($return);
}




=head2 get_relationship_IsRegulatorFor

  $return = $obj->get_relationship_IsRegulatorFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulator
	1: a fields_IsRegulatorFor
	2: a fields_Regulog
fields_Regulator is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	rfam_id has a value which is a string
	tf_family has a value which is a string
	type has a value which is a string
	taxonomy has a value which is a string
fields_IsRegulatorFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulator
	1: a fields_IsRegulatorFor
	2: a fields_Regulog
fields_Regulator is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	rfam_id has a value which is a string
	tf_family has a value which is a string
	type has a value which is a string
	taxonomy has a value which is a string
fields_IsRegulatorFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsRegulatorFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsRegulatorFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRegulatorFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsRegulatorFor

    $return = $self->_get_relationship($ctx, 'IsRegulatorFor', 'IsRegulatorFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsRegulatorFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsRegulatorFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRegulatorFor');
    }
    return($return);
}




=head2 get_relationship_HasRegulator

  $return = $obj->get_relationship_HasRegulator($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulog
	1: a fields_IsRegulatorFor
	2: a fields_Regulator
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_IsRegulatorFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulator is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	rfam_id has a value which is a string
	tf_family has a value which is a string
	type has a value which is a string
	taxonomy has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulog
	1: a fields_IsRegulatorFor
	2: a fields_Regulator
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_IsRegulatorFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulator is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	rfam_id has a value which is a string
	tf_family has a value which is a string
	type has a value which is a string
	taxonomy has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasRegulator
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasRegulator:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasRegulator');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasRegulator

    $return = $self->_get_relationship($ctx, 'HasRegulator', 'IsRegulatorFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasRegulator
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasRegulator:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasRegulator');
    }
    return($return);
}




=head2 get_relationship_IsRegulatorForRegulon

  $return = $obj->get_relationship_IsRegulatorForRegulon($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulator
	1: a fields_IsRegulatorForRegulon
	2: a fields_Regulon
fields_Regulator is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	rfam_id has a value which is a string
	tf_family has a value which is a string
	type has a value which is a string
	taxonomy has a value which is a string
fields_IsRegulatorForRegulon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulator
	1: a fields_IsRegulatorForRegulon
	2: a fields_Regulon
fields_Regulator is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	rfam_id has a value which is a string
	tf_family has a value which is a string
	type has a value which is a string
	taxonomy has a value which is a string
fields_IsRegulatorForRegulon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsRegulatorForRegulon
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsRegulatorForRegulon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRegulatorForRegulon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsRegulatorForRegulon

    $return = $self->_get_relationship($ctx, 'IsRegulatorForRegulon', 'IsRegulatorForRegulon', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsRegulatorForRegulon
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsRegulatorForRegulon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRegulatorForRegulon');
    }
    return($return);
}




=head2 get_relationship_ReglonHasRegulator

  $return = $obj->get_relationship_ReglonHasRegulator($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulon
	1: a fields_IsRegulatorForRegulon
	2: a fields_Regulator
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_IsRegulatorForRegulon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulator is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	rfam_id has a value which is a string
	tf_family has a value which is a string
	type has a value which is a string
	taxonomy has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulon
	1: a fields_IsRegulatorForRegulon
	2: a fields_Regulator
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_IsRegulatorForRegulon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulator is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	rfam_id has a value which is a string
	tf_family has a value which is a string
	type has a value which is a string
	taxonomy has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_ReglonHasRegulator
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ReglonHasRegulator:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ReglonHasRegulator');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ReglonHasRegulator

    $return = $self->_get_relationship($ctx, 'ReglonHasRegulator', 'IsRegulatorForRegulon', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ReglonHasRegulator
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ReglonHasRegulator:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ReglonHasRegulator');
    }
    return($return);
}




=head2 get_relationship_IsRegulatorySiteFor

  $return = $obj->get_relationship_IsRegulatorySiteFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsRegulatorySiteFor
	2: a fields_Operon
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsRegulatorySiteFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Feature
	1: a fields_IsRegulatorySiteFor
	2: a fields_Operon
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsRegulatorySiteFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsRegulatorySiteFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsRegulatorySiteFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRegulatorySiteFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsRegulatorySiteFor

    $return = $self->_get_relationship($ctx, 'IsRegulatorySiteFor', 'IsRegulatorySiteFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsRegulatorySiteFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsRegulatorySiteFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRegulatorySiteFor');
    }
    return($return);
}




=head2 get_relationship_HasRegulatorySite

  $return = $obj->get_relationship_HasRegulatorySite($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Operon
	1: a fields_IsRegulatorySiteFor
	2: a fields_Feature
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsRegulatorySiteFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Operon
	1: a fields_IsRegulatorySiteFor
	2: a fields_Feature
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsRegulatorySiteFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Feature is a reference to a hash where the following keys are defined:
	id has a value which is a string
	feature_type has a value which is a string
	source_id has a value which is a string
	sequence_length has a value which is an int
	function has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasRegulatorySite
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasRegulatorySite:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasRegulatorySite');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasRegulatorySite

    $return = $self->_get_relationship($ctx, 'HasRegulatorySite', 'IsRegulatorySiteFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasRegulatorySite
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasRegulatorySite:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasRegulatorySite');
    }
    return($return);
}




=head2 get_relationship_IsRelevantFor

  $return = $obj->get_relationship_IsRelevantFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Diagram
	1: a fields_IsRelevantFor
	2: a fields_Subsystem
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string
fields_IsRelevantFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Diagram
	1: a fields_IsRelevantFor
	2: a fields_Subsystem
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string
fields_IsRelevantFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int


=end text



=item Description

This relationship connects a diagram to the subsystems that are depicted on
it. Only diagrams which are useful in curating or annotation the subsystem are
specified in this relationship.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsRelevantFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsRelevantFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRelevantFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsRelevantFor

    $return = $self->_get_relationship($ctx, 'IsRelevantFor', 'IsRelevantFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsRelevantFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsRelevantFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRelevantFor');
    }
    return($return);
}




=head2 get_relationship_IsRelevantTo

  $return = $obj->get_relationship_IsRelevantTo($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Subsystem
	1: a fields_IsRelevantFor
	2: a fields_Diagram
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int
fields_IsRelevantFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Subsystem
	1: a fields_IsRelevantFor
	2: a fields_Diagram
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int
fields_IsRelevantFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsRelevantTo
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsRelevantTo:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRelevantTo');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsRelevantTo

    $return = $self->_get_relationship($ctx, 'IsRelevantTo', 'IsRelevantFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsRelevantTo
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsRelevantTo:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRelevantTo');
    }
    return($return);
}




=head2 get_relationship_IsRepresentedBy

  $return = $obj->get_relationship_IsRepresentedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_TaxonomicGrouping
	1: a fields_IsRepresentedBy
	2: a fields_ObservationalUnit
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsRepresentedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_TaxonomicGrouping
	1: a fields_IsRepresentedBy
	2: a fields_ObservationalUnit
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsRepresentedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string


=end text



=item Description

This relationship associates observational units with a genus,
species, strain, and/or variety that was the source material.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsRepresentedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsRepresentedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRepresentedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsRepresentedBy

    $return = $self->_get_relationship($ctx, 'IsRepresentedBy', 'IsRepresentedBy', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsRepresentedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsRepresentedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRepresentedBy');
    }
    return($return);
}




=head2 get_relationship_DefinedBy

  $return = $obj->get_relationship_DefinedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ObservationalUnit
	1: a fields_IsRepresentedBy
	2: a fields_TaxonomicGrouping
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string
fields_IsRepresentedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ObservationalUnit
	1: a fields_IsRepresentedBy
	2: a fields_TaxonomicGrouping
fields_ObservationalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_name has a value which is a string
	source_name2 has a value which is a reference to a list where each element is a string
	plant_id has a value which is a string
fields_IsRepresentedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_DefinedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_DefinedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DefinedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_DefinedBy

    $return = $self->_get_relationship($ctx, 'DefinedBy', 'IsRepresentedBy', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_DefinedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_DefinedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DefinedBy');
    }
    return($return);
}




=head2 get_relationship_IsRoleOf

  $return = $obj->get_relationship_IsRoleOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Role
	1: a fields_IsRoleOf
	2: a fields_SSCell
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int
fields_IsRoleOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Role
	1: a fields_IsRoleOf
	2: a fields_SSCell
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int
fields_IsRoleOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

This relationship connects a role to the machine roles that
represent its appearance in a molecular machine. A machine role has
exactly one associated role, but a role may be represented by many
machine roles.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsRoleOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsRoleOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRoleOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsRoleOf

    $return = $self->_get_relationship($ctx, 'IsRoleOf', 'IsRoleOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsRoleOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsRoleOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRoleOf');
    }
    return($return);
}




=head2 get_relationship_HasRole

  $return = $obj->get_relationship_HasRole($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SSCell
	1: a fields_IsRoleOf
	2: a fields_Role
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsRoleOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SSCell
	1: a fields_IsRoleOf
	2: a fields_Role
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsRoleOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_HasRole
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasRole:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasRole');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasRole

    $return = $self->_get_relationship($ctx, 'HasRole', 'IsRoleOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasRole
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasRole:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasRole');
    }
    return($return);
}




=head2 get_relationship_IsRowOf

  $return = $obj->get_relationship_IsRowOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SSRow
	1: a fields_IsRowOf
	2: a fields_SSCell
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string
fields_IsRowOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SSRow
	1: a fields_IsRowOf
	2: a fields_SSCell
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string
fields_IsRowOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

This relationship connects a subsystem spreadsheet row to its
constituent spreadsheet cells.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsRowOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsRowOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRowOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsRowOf

    $return = $self->_get_relationship($ctx, 'IsRowOf', 'IsRowOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsRowOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsRowOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRowOf');
    }
    return($return);
}




=head2 get_relationship_IsRoleFor

  $return = $obj->get_relationship_IsRoleFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SSCell
	1: a fields_IsRowOf
	2: a fields_SSRow
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsRowOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SSCell
	1: a fields_IsRowOf
	2: a fields_SSRow
fields_SSCell is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsRowOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsRoleFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsRoleFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRoleFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsRoleFor

    $return = $self->_get_relationship($ctx, 'IsRoleFor', 'IsRowOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsRoleFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsRoleFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsRoleFor');
    }
    return($return);
}




=head2 get_relationship_IsSequenceOf

  $return = $obj->get_relationship_IsSequenceOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ContigSequence
	1: a fields_IsSequenceOf
	2: a fields_Contig
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int
fields_IsSequenceOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ContigSequence
	1: a fields_IsSequenceOf
	2: a fields_Contig
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int
fields_IsSequenceOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description

This relationship connects a Contig as it occurs in a
genome to the Contig Sequence that represents the physical
DNA base pairs. A contig sequence may represent many contigs,
but each contig has only one sequence.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsSequenceOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsSequenceOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSequenceOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsSequenceOf

    $return = $self->_get_relationship($ctx, 'IsSequenceOf', 'IsSequenceOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsSequenceOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsSequenceOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSequenceOf');
    }
    return($return);
}




=head2 get_relationship_HasAsSequence

  $return = $obj->get_relationship_HasAsSequence($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Contig
	1: a fields_IsSequenceOf
	2: a fields_ContigSequence
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_IsSequenceOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Contig
	1: a fields_IsSequenceOf
	2: a fields_ContigSequence
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_IsSequenceOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ContigSequence is a reference to a hash where the following keys are defined:
	id has a value which is a string
	length has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_HasAsSequence
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasAsSequence:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasAsSequence');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasAsSequence

    $return = $self->_get_relationship($ctx, 'HasAsSequence', 'IsSequenceOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasAsSequence
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasAsSequence:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasAsSequence');
    }
    return($return);
}




=head2 get_relationship_IsSourceForAssociationDataset

  $return = $obj->get_relationship_IsSourceForAssociationDataset($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_IsSourceForAssociationDataset
	2: a fields_AssociationDataset
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_IsSourceForAssociationDataset is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_IsSourceForAssociationDataset
	2: a fields_AssociationDataset
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_IsSourceForAssociationDataset is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string


=end text



=item Description

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsSourceForAssociationDataset
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsSourceForAssociationDataset:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSourceForAssociationDataset');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsSourceForAssociationDataset

    $return = $self->_get_relationship($ctx, 'IsSourceForAssociationDataset', 'IsSourceForAssociationDataset', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsSourceForAssociationDataset
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsSourceForAssociationDataset:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSourceForAssociationDataset');
    }
    return($return);
}




=head2 get_relationship_AssociationDatasetSourcedBy

  $return = $obj->get_relationship_AssociationDatasetSourcedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AssociationDataset
	1: a fields_IsSourceForAssociationDataset
	2: a fields_Source
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string
fields_IsSourceForAssociationDataset is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AssociationDataset
	1: a fields_IsSourceForAssociationDataset
	2: a fields_Source
fields_AssociationDataset is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	data_source has a value which is a string
	url has a value which is a string
	association_type has a value which is a string
fields_IsSourceForAssociationDataset is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_AssociationDatasetSourcedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_AssociationDatasetSourcedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AssociationDatasetSourcedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_AssociationDatasetSourcedBy

    $return = $self->_get_relationship($ctx, 'AssociationDatasetSourcedBy', 'IsSourceForAssociationDataset', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_AssociationDatasetSourcedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_AssociationDatasetSourcedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AssociationDatasetSourcedBy');
    }
    return($return);
}




=head2 get_relationship_IsSubInstanceOf

  $return = $obj->get_relationship_IsSubInstanceOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Subsystem
	1: a fields_IsSubInstanceOf
	2: a fields_Scenario
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int
fields_IsSubInstanceOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is an int
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Subsystem
	1: a fields_IsSubInstanceOf
	2: a fields_Scenario
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int
fields_IsSubInstanceOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is an int
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string


=end text



=item Description

This relationship connects a scenario to its subsystem it
validates. A scenario belongs to exactly one subsystem, but a
subsystem may have multiple scenarios.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsSubInstanceOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsSubInstanceOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSubInstanceOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsSubInstanceOf

    $return = $self->_get_relationship($ctx, 'IsSubInstanceOf', 'IsSubInstanceOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsSubInstanceOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsSubInstanceOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSubInstanceOf');
    }
    return($return);
}




=head2 get_relationship_Validates

  $return = $obj->get_relationship_Validates($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Scenario
	1: a fields_IsSubInstanceOf
	2: a fields_Subsystem
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string
fields_IsSubInstanceOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is an int
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Scenario
	1: a fields_IsSubInstanceOf
	2: a fields_Subsystem
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string
fields_IsSubInstanceOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is an int
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_Validates
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Validates:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Validates');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Validates

    $return = $self->_get_relationship($ctx, 'Validates', 'IsSubInstanceOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Validates
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Validates:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Validates');
    }
    return($return);
}




=head2 get_relationship_IsSummarizedBy

  $return = $obj->get_relationship_IsSummarizedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Contig
	1: a fields_IsSummarizedBy
	2: a fields_AlleleFrequency
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_IsSummarizedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	position has a value which is an int
fields_AlleleFrequency is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	position has a value which is an int
	minor_AF has a value which is a float
	minor_allele has a value which is a string
	major_AF has a value which is a float
	major_allele has a value which is a string
	obs_unit_count has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Contig
	1: a fields_IsSummarizedBy
	2: a fields_AlleleFrequency
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_IsSummarizedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	position has a value which is an int
fields_AlleleFrequency is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	position has a value which is an int
	minor_AF has a value which is a float
	minor_allele has a value which is a string
	major_AF has a value which is a float
	major_allele has a value which is a string
	obs_unit_count has a value which is an int


=end text



=item Description

This relationship describes the statistical frequencies of the
most common alleles in various positions on the reference contig.

It has the following fields:

=over 4

=item position

Position in the reference contig where the trait has an impact.


=back

=back

=cut

sub get_relationship_IsSummarizedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsSummarizedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSummarizedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsSummarizedBy

    $return = $self->_get_relationship($ctx, 'IsSummarizedBy', 'IsSummarizedBy', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsSummarizedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsSummarizedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSummarizedBy');
    }
    return($return);
}




=head2 get_relationship_Summarizes

  $return = $obj->get_relationship_Summarizes($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AlleleFrequency
	1: a fields_IsSummarizedBy
	2: a fields_Contig
fields_AlleleFrequency is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	position has a value which is an int
	minor_AF has a value which is a float
	minor_allele has a value which is a string
	major_AF has a value which is a float
	major_allele has a value which is a string
	obs_unit_count has a value which is an int
fields_IsSummarizedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	position has a value which is an int
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_AlleleFrequency
	1: a fields_IsSummarizedBy
	2: a fields_Contig
fields_AlleleFrequency is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	position has a value which is an int
	minor_AF has a value which is a float
	minor_allele has a value which is a string
	major_AF has a value which is a float
	major_allele has a value which is a string
	obs_unit_count has a value which is an int
fields_IsSummarizedBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	position has a value which is an int
fields_Contig is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_Summarizes
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Summarizes:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Summarizes');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Summarizes

    $return = $self->_get_relationship($ctx, 'Summarizes', 'IsSummarizedBy', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Summarizes
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Summarizes:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Summarizes');
    }
    return($return);
}




=head2 get_relationship_IsSuperclassOf

  $return = $obj->get_relationship_IsSuperclassOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SubsystemClass
	1: a fields_IsSuperclassOf
	2: a fields_SubsystemClass
fields_SubsystemClass is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsSuperclassOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SubsystemClass
	1: a fields_IsSuperclassOf
	2: a fields_SubsystemClass
fields_SubsystemClass is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsSuperclassOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string


=end text



=item Description

This is a recursive relationship that imposes a hierarchy on
the subsystem classes.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsSuperclassOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsSuperclassOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSuperclassOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsSuperclassOf

    $return = $self->_get_relationship($ctx, 'IsSuperclassOf', 'IsSuperclassOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsSuperclassOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsSuperclassOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSuperclassOf');
    }
    return($return);
}




=head2 get_relationship_IsSubclassOf

  $return = $obj->get_relationship_IsSubclassOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SubsystemClass
	1: a fields_IsSuperclassOf
	2: a fields_SubsystemClass
fields_SubsystemClass is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsSuperclassOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SubsystemClass
	1: a fields_IsSuperclassOf
	2: a fields_SubsystemClass
fields_SubsystemClass is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_IsSuperclassOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsSubclassOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsSubclassOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSubclassOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsSubclassOf

    $return = $self->_get_relationship($ctx, 'IsSubclassOf', 'IsSuperclassOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsSubclassOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsSubclassOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSubclassOf');
    }
    return($return);
}




=head2 get_relationship_IsTaxonomyOf

  $return = $obj->get_relationship_IsTaxonomyOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_TaxonomicGrouping
	1: a fields_IsTaxonomyOf
	2: a fields_Genome
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsTaxonomyOf is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_TaxonomicGrouping
	1: a fields_IsTaxonomyOf
	2: a fields_Genome
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string
fields_IsTaxonomyOf is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description

A genome is assigned to a particular point in the taxonomy tree, but not
necessarily to a leaf node. In some cases, the exact species and strain is
not available when inserting the genome, so it is placed at the lowest node
that probably contains the actual genome.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsTaxonomyOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsTaxonomyOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsTaxonomyOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsTaxonomyOf

    $return = $self->_get_relationship($ctx, 'IsTaxonomyOf', 'IsTaxonomyOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsTaxonomyOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsTaxonomyOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsTaxonomyOf');
    }
    return($return);
}




=head2 get_relationship_IsInTaxa

  $return = $obj->get_relationship_IsInTaxa($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsTaxonomyOf
	2: a fields_TaxonomicGrouping
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsTaxonomyOf is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_IsTaxonomyOf
	2: a fields_TaxonomicGrouping
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_IsTaxonomyOf is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
fields_TaxonomicGrouping is a reference to a hash where the following keys are defined:
	id has a value which is a string
	domain has a value which is an int
	hidden has a value which is an int
	scientific_name has a value which is a string
	alias has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsInTaxa
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsInTaxa:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInTaxa');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsInTaxa

    $return = $self->_get_relationship($ctx, 'IsInTaxa', 'IsTaxonomyOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsInTaxa
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsInTaxa:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsInTaxa');
    }
    return($return);
}




=head2 get_relationship_IsTerminusFor

  $return = $obj->get_relationship_IsTerminusFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_IsTerminusFor
	2: a fields_Scenario
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_IsTerminusFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is an int
	group_number has a value which is an int
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_IsTerminusFor
	2: a fields_Scenario
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_IsTerminusFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is an int
	group_number has a value which is an int
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string


=end text



=item Description

A terminus for a scenario is a compound that acts as its
input or output. A compound can be the terminus for many scenarios,
and a scenario will have many termini. The relationship attributes
indicate whether the compound is an input to the scenario or an
output. In some cases, there may be multiple alternative output
groups. This is also indicated by the attributes.

It has the following fields:

=over 4

=item group_number

If zero, then the compound is an input. If one, the compound is an output. If two, the compound is an auxiliary output.


=back

=back

=cut

sub get_relationship_IsTerminusFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsTerminusFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsTerminusFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsTerminusFor

    $return = $self->_get_relationship($ctx, 'IsTerminusFor', 'IsTerminusFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsTerminusFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsTerminusFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsTerminusFor');
    }
    return($return);
}




=head2 get_relationship_HasAsTerminus

  $return = $obj->get_relationship_HasAsTerminus($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Scenario
	1: a fields_IsTerminusFor
	2: a fields_Compound
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string
fields_IsTerminusFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is an int
	group_number has a value which is an int
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Scenario
	1: a fields_IsTerminusFor
	2: a fields_Compound
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string
fields_IsTerminusFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is an int
	group_number has a value which is an int
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float


=end text



=item Description



=back

=cut

sub get_relationship_HasAsTerminus
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasAsTerminus:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasAsTerminus');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasAsTerminus

    $return = $self->_get_relationship($ctx, 'HasAsTerminus', 'IsTerminusFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasAsTerminus
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasAsTerminus:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasAsTerminus');
    }
    return($return);
}




=head2 get_relationship_IsTriggeredBy

  $return = $obj->get_relationship_IsTriggeredBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Complex
	1: a fields_IsTriggeredBy
	2: a fields_Role
fields_Complex is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a reference to a list where each element is a string
	source_id has a value which is a string
	mod_date has a value which is a string
fields_IsTriggeredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	optional has a value which is an int
	type has a value which is a string
	triggering has a value which is an int
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Complex
	1: a fields_IsTriggeredBy
	2: a fields_Role
fields_Complex is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a reference to a list where each element is a string
	source_id has a value which is a string
	mod_date has a value which is a string
fields_IsTriggeredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	optional has a value which is an int
	type has a value which is a string
	triggering has a value which is an int
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int


=end text



=item Description

This connects a complex to the roles that work together to form the complex.

It has the following fields:

=over 4

=item optional

TRUE if the role is not necessarily required to trigger the complex, else FALSE

=item type

a string code that is used to determine whether a complex should be added to a model

=item triggering

TRUE if the presence of the role requires including the complex in the model, else FALSE


=back

=back

=cut

sub get_relationship_IsTriggeredBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsTriggeredBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsTriggeredBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsTriggeredBy

    $return = $self->_get_relationship($ctx, 'IsTriggeredBy', 'IsTriggeredBy', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsTriggeredBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsTriggeredBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsTriggeredBy');
    }
    return($return);
}




=head2 get_relationship_Triggers

  $return = $obj->get_relationship_Triggers($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Role
	1: a fields_IsTriggeredBy
	2: a fields_Complex
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int
fields_IsTriggeredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	optional has a value which is an int
	type has a value which is a string
	triggering has a value which is an int
fields_Complex is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a reference to a list where each element is a string
	source_id has a value which is a string
	mod_date has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Role
	1: a fields_IsTriggeredBy
	2: a fields_Complex
fields_Role is a reference to a hash where the following keys are defined:
	id has a value which is a string
	hypothetical has a value which is an int
fields_IsTriggeredBy is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	optional has a value which is an int
	type has a value which is a string
	triggering has a value which is an int
fields_Complex is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a reference to a list where each element is a string
	source_id has a value which is a string
	mod_date has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_Triggers
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Triggers:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Triggers');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Triggers

    $return = $self->_get_relationship($ctx, 'Triggers', 'IsTriggeredBy', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Triggers
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Triggers:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Triggers');
    }
    return($return);
}




=head2 get_relationship_IsUsedToBuildTree

  $return = $obj->get_relationship_IsUsedToBuildTree($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_IsUsedToBuildTree
	2: a fields_Tree
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_IsUsedToBuildTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_IsUsedToBuildTree
	2: a fields_Tree
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_IsUsedToBuildTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string


=end text



=item Description

This relationship connects each tree to the alignment from
which it is built. There is at most one.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_IsUsedToBuildTree
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsUsedToBuildTree:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsUsedToBuildTree');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsUsedToBuildTree

    $return = $self->_get_relationship($ctx, 'IsUsedToBuildTree', 'IsUsedToBuildTree', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsUsedToBuildTree
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsUsedToBuildTree:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsUsedToBuildTree');
    }
    return($return);
}




=head2 get_relationship_IsBuiltFromAlignment

  $return = $obj->get_relationship_IsBuiltFromAlignment($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_IsUsedToBuildTree
	2: a fields_Alignment
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_IsUsedToBuildTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_IsUsedToBuildTree
	2: a fields_Alignment
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_IsUsedToBuildTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsBuiltFromAlignment
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsBuiltFromAlignment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsBuiltFromAlignment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsBuiltFromAlignment

    $return = $self->_get_relationship($ctx, 'IsBuiltFromAlignment', 'IsUsedToBuildTree', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsBuiltFromAlignment
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsBuiltFromAlignment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsBuiltFromAlignment');
    }
    return($return);
}




=head2 get_relationship_Manages

  $return = $obj->get_relationship_Manages($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Model
	1: a fields_Manages
	2: a fields_Biomass
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int
fields_Manages is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Biomass is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a reference to a list where each element is a string
	dna has a value which is a float
	protein has a value which is a float
	cell_wall has a value which is a float
	lipid has a value which is a float
	cofactor has a value which is a float
	energy has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Model
	1: a fields_Manages
	2: a fields_Biomass
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int
fields_Manages is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Biomass is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a reference to a list where each element is a string
	dna has a value which is a float
	protein has a value which is a float
	cell_wall has a value which is a float
	lipid has a value which is a float
	cofactor has a value which is a float
	energy has a value which is a float


=end text



=item Description

This relationship connects a model to its associated biomass
composition reactions.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_Manages
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Manages:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Manages');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Manages

    $return = $self->_get_relationship($ctx, 'Manages', 'Manages', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Manages
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Manages:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Manages');
    }
    return($return);
}




=head2 get_relationship_IsManagedBy

  $return = $obj->get_relationship_IsManagedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Biomass
	1: a fields_Manages
	2: a fields_Model
fields_Biomass is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a reference to a list where each element is a string
	dna has a value which is a float
	protein has a value which is a float
	cell_wall has a value which is a float
	lipid has a value which is a float
	cofactor has a value which is a float
	energy has a value which is a float
fields_Manages is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Biomass
	1: a fields_Manages
	2: a fields_Model
fields_Biomass is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a reference to a list where each element is a string
	dna has a value which is a float
	protein has a value which is a float
	cell_wall has a value which is a float
	lipid has a value which is a float
	cofactor has a value which is a float
	energy has a value which is a float
fields_Manages is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Model is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	version has a value which is an int
	type has a value which is a string
	status has a value which is a string
	reaction_count has a value which is an int
	compound_count has a value which is an int
	annotation_count has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_IsManagedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsManagedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsManagedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsManagedBy

    $return = $self->_get_relationship($ctx, 'IsManagedBy', 'Manages', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsManagedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsManagedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsManagedBy');
    }
    return($return);
}




=head2 get_relationship_OntologyForSample

  $return = $obj->get_relationship_OntologyForSample($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Ontology
	1: a fields_OntologyForSample
	2: a fields_SampleAnnotation
fields_Ontology is a reference to a hash where the following keys are defined:
	id has a value which is a string
	id has a value which is a string
	name has a value which is a string
	definition has a value which is a string
	ontologySource has a value which is a string
fields_OntologyForSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Ontology
	1: a fields_OntologyForSample
	2: a fields_SampleAnnotation
fields_Ontology is a reference to a hash where the following keys are defined:
	id has a value which is a string
	id has a value which is a string
	name has a value which is a string
	definition has a value which is a string
	ontologySource has a value which is a string
fields_OntologyForSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string


=end text



=item Description

This relationship the ontology PO#, EO# or ENVO# associatioed with the sample.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_OntologyForSample
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_OntologyForSample:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_OntologyForSample');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_OntologyForSample

    $return = $self->_get_relationship($ctx, 'OntologyForSample', 'OntologyForSample', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_OntologyForSample
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_OntologyForSample:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_OntologyForSample');
    }
    return($return);
}




=head2 get_relationship_SampleHasOntology

  $return = $obj->get_relationship_SampleHasOntology($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SampleAnnotation
	1: a fields_OntologyForSample
	2: a fields_Ontology
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string
fields_OntologyForSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Ontology is a reference to a hash where the following keys are defined:
	id has a value which is a string
	id has a value which is a string
	name has a value which is a string
	definition has a value which is a string
	ontologySource has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SampleAnnotation
	1: a fields_OntologyForSample
	2: a fields_Ontology
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string
fields_OntologyForSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Ontology is a reference to a hash where the following keys are defined:
	id has a value which is a string
	id has a value which is a string
	name has a value which is a string
	definition has a value which is a string
	ontologySource has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_SampleHasOntology
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SampleHasOntology:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleHasOntology');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SampleHasOntology

    $return = $self->_get_relationship($ctx, 'SampleHasOntology', 'OntologyForSample', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SampleHasOntology
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SampleHasOntology:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleHasOntology');
    }
    return($return);
}




=head2 get_relationship_OperatesIn

  $return = $obj->get_relationship_OperatesIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Experiment
	1: a fields_OperatesIn
	2: a fields_Media
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string
fields_OperatesIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Experiment
	1: a fields_OperatesIn
	2: a fields_Media
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string
fields_OperatesIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string


=end text



=item Description

This relationship connects an experiment to the media in which the
experiment took place.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_OperatesIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_OperatesIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_OperatesIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_OperatesIn

    $return = $self->_get_relationship($ctx, 'OperatesIn', 'OperatesIn', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_OperatesIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_OperatesIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_OperatesIn');
    }
    return($return);
}




=head2 get_relationship_IsUtilizedIn

  $return = $obj->get_relationship_IsUtilizedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Media
	1: a fields_OperatesIn
	2: a fields_Experiment
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string
fields_OperatesIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Media
	1: a fields_OperatesIn
	2: a fields_Experiment
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string
fields_OperatesIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Experiment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsUtilizedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsUtilizedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsUtilizedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsUtilizedIn

    $return = $self->_get_relationship($ctx, 'IsUtilizedIn', 'OperatesIn', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsUtilizedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsUtilizedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsUtilizedIn');
    }
    return($return);
}




=head2 get_relationship_OrdersExperimentalUnit

  $return = $obj->get_relationship_OrdersExperimentalUnit($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_TimeSeries
	1: a fields_OrdersExperimentalUnit
	2: a fields_ExperimentalUnit
fields_TimeSeries is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	timeUnits has a value which is a string
fields_OrdersExperimentalUnit is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	time has a value which is a float
	timeMeta has a value which is a string
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_TimeSeries
	1: a fields_OrdersExperimentalUnit
	2: a fields_ExperimentalUnit
fields_TimeSeries is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	timeUnits has a value which is a string
fields_OrdersExperimentalUnit is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	time has a value which is a float
	timeMeta has a value which is a string
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string


=end text



=item Description

Experimental units may be ordered into time series. This
relationship describes which experimenal units belong to
which time series.

It has the following fields:

=over 4

=item time

The time at which the associated ExperimentUnit's data was taken.

=item timeMeta

Denotes that the associated ExperimentalUnit's data measures the time series as a whole - for example, lag and doubling times for bacterial growth curves.


=back

=back

=cut

sub get_relationship_OrdersExperimentalUnit
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_OrdersExperimentalUnit:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_OrdersExperimentalUnit');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_OrdersExperimentalUnit

    $return = $self->_get_relationship($ctx, 'OrdersExperimentalUnit', 'OrdersExperimentalUnit', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_OrdersExperimentalUnit
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_OrdersExperimentalUnit:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_OrdersExperimentalUnit');
    }
    return($return);
}




=head2 get_relationship_IsTimepointOf

  $return = $obj->get_relationship_IsTimepointOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnit
	1: a fields_OrdersExperimentalUnit
	2: a fields_TimeSeries
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_OrdersExperimentalUnit is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	time has a value which is a float
	timeMeta has a value which is a string
fields_TimeSeries is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	timeUnits has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentalUnit
	1: a fields_OrdersExperimentalUnit
	2: a fields_TimeSeries
fields_ExperimentalUnit is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
fields_OrdersExperimentalUnit is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	time has a value which is a float
	timeMeta has a value which is a string
fields_TimeSeries is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	name has a value which is a string
	comments has a value which is a string
	timeUnits has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsTimepointOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsTimepointOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsTimepointOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsTimepointOf

    $return = $self->_get_relationship($ctx, 'IsTimepointOf', 'OrdersExperimentalUnit', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsTimepointOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsTimepointOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsTimepointOf');
    }
    return($return);
}




=head2 get_relationship_Overlaps

  $return = $obj->get_relationship_Overlaps($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Scenario
	1: a fields_Overlaps
	2: a fields_Diagram
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string
fields_Overlaps is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Scenario
	1: a fields_Overlaps
	2: a fields_Diagram
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string
fields_Overlaps is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string


=end text



=item Description

A Scenario overlaps a diagram when the diagram displays a
portion of the reactions that make up the scenario. A scenario may
overlap many diagrams, and a diagram may be include portions of many
scenarios.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_Overlaps
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Overlaps:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Overlaps');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Overlaps

    $return = $self->_get_relationship($ctx, 'Overlaps', 'Overlaps', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Overlaps
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Overlaps:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Overlaps');
    }
    return($return);
}




=head2 get_relationship_IncludesPartOf

  $return = $obj->get_relationship_IncludesPartOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Diagram
	1: a fields_Overlaps
	2: a fields_Scenario
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string
fields_Overlaps is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Diagram
	1: a fields_Overlaps
	2: a fields_Scenario
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string
fields_Overlaps is a reference to a hash where the following keys are defined:
	from_link has a value which is an int
	to_link has a value which is a string
fields_Scenario is a reference to a hash where the following keys are defined:
	id has a value which is a string
	common_name has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IncludesPartOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IncludesPartOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IncludesPartOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IncludesPartOf

    $return = $self->_get_relationship($ctx, 'IncludesPartOf', 'Overlaps', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IncludesPartOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IncludesPartOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IncludesPartOf');
    }
    return($return);
}




=head2 get_relationship_ParticipatesAs

  $return = $obj->get_relationship_ParticipatesAs($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_ParticipatesAs
	2: a fields_LocalizedCompound
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_ParticipatesAs is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_ParticipatesAs
	2: a fields_LocalizedCompound
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_ParticipatesAs is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

This relationship connects a generic compound to a specific compound
where subceullar location has been specified.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_ParticipatesAs
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ParticipatesAs:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ParticipatesAs');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ParticipatesAs

    $return = $self->_get_relationship($ctx, 'ParticipatesAs', 'ParticipatesAs', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ParticipatesAs
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ParticipatesAs:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ParticipatesAs');
    }
    return($return);
}




=head2 get_relationship_IsParticipationOf

  $return = $obj->get_relationship_IsParticipationOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_LocalizedCompound
	1: a fields_ParticipatesAs
	2: a fields_Compound
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_ParticipatesAs is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_LocalizedCompound
	1: a fields_ParticipatesAs
	2: a fields_Compound
fields_LocalizedCompound is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_ParticipatesAs is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float


=end text



=item Description



=back

=cut

sub get_relationship_IsParticipationOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsParticipationOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsParticipationOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsParticipationOf

    $return = $self->_get_relationship($ctx, 'IsParticipationOf', 'ParticipatesAs', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsParticipationOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsParticipationOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsParticipationOf');
    }
    return($return);
}




=head2 get_relationship_PerformedExperiment

  $return = $obj->get_relationship_PerformedExperiment($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Person
	1: a fields_PerformedExperiment
	2: a fields_ExperimentMeta
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string
fields_PerformedExperiment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	role has a value which is a string
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Person
	1: a fields_PerformedExperiment
	2: a fields_ExperimentMeta
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string
fields_PerformedExperiment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	role has a value which is a string
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string


=end text



=item Description

Denotes that a Person was associated with a
Experiment in some role.

It has the following fields:

=over 4

=item role

Describes the role the person played in the experiment. Examples are Primary Investigator, Designer, Experimentalist, etc.


=back

=back

=cut

sub get_relationship_PerformedExperiment
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_PerformedExperiment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PerformedExperiment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_PerformedExperiment

    $return = $self->_get_relationship($ctx, 'PerformedExperiment', 'PerformedExperiment', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_PerformedExperiment
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_PerformedExperiment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PerformedExperiment');
    }
    return($return);
}




=head2 get_relationship_PerformedBy

  $return = $obj->get_relationship_PerformedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentMeta
	1: a fields_PerformedExperiment
	2: a fields_Person
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string
fields_PerformedExperiment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	role has a value which is a string
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentMeta
	1: a fields_PerformedExperiment
	2: a fields_Person
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string
fields_PerformedExperiment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	role has a value which is a string
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_PerformedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_PerformedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PerformedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_PerformedBy

    $return = $self->_get_relationship($ctx, 'PerformedBy', 'PerformedExperiment', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_PerformedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_PerformedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PerformedBy');
    }
    return($return);
}




=head2 get_relationship_PersonAnnotatedSample

  $return = $obj->get_relationship_PersonAnnotatedSample($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Person
	1: a fields_PersonAnnotatedSample
	2: a fields_SampleAnnotation
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string
fields_PersonAnnotatedSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Person
	1: a fields_PersonAnnotatedSample
	2: a fields_SampleAnnotation
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string
fields_PersonAnnotatedSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string


=end text



=item Description

Only stores a person if a person annotates the data by hand.  
Automated Sample Annotations will not be annotated by a person.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_PersonAnnotatedSample
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_PersonAnnotatedSample:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PersonAnnotatedSample');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_PersonAnnotatedSample

    $return = $self->_get_relationship($ctx, 'PersonAnnotatedSample', 'PersonAnnotatedSample', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_PersonAnnotatedSample
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_PersonAnnotatedSample:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PersonAnnotatedSample');
    }
    return($return);
}




=head2 get_relationship_SampleAnnotatedBy

  $return = $obj->get_relationship_SampleAnnotatedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SampleAnnotation
	1: a fields_PersonAnnotatedSample
	2: a fields_Person
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string
fields_PersonAnnotatedSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SampleAnnotation
	1: a fields_PersonAnnotatedSample
	2: a fields_Person
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string
fields_PersonAnnotatedSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_SampleAnnotatedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SampleAnnotatedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleAnnotatedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SampleAnnotatedBy

    $return = $self->_get_relationship($ctx, 'SampleAnnotatedBy', 'PersonAnnotatedSample', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SampleAnnotatedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SampleAnnotatedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleAnnotatedBy');
    }
    return($return);
}




=head2 get_relationship_PlatformWithSamples

  $return = $obj->get_relationship_PlatformWithSamples($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Platform
	1: a fields_PlatformWithSamples
	2: a fields_Sample
fields_Platform is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	externalSourceId has a value which is a string
	technology has a value which is a string
	type has a value which is a string
	source_id has a value which is a string
fields_PlatformWithSamples is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Platform
	1: a fields_PlatformWithSamples
	2: a fields_Sample
fields_Platform is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	externalSourceId has a value which is a string
	technology has a value which is a string
	type has a value which is a string
	source_id has a value which is a string
fields_PlatformWithSamples is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int


=end text



=item Description

This relationship indicates the expression samples that were run on a particular platform.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_PlatformWithSamples
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_PlatformWithSamples:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PlatformWithSamples');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_PlatformWithSamples

    $return = $self->_get_relationship($ctx, 'PlatformWithSamples', 'PlatformWithSamples', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_PlatformWithSamples
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_PlatformWithSamples:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PlatformWithSamples');
    }
    return($return);
}




=head2 get_relationship_SampleRunOnPlatform

  $return = $obj->get_relationship_SampleRunOnPlatform($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_PlatformWithSamples
	2: a fields_Platform
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_PlatformWithSamples is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Platform is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	externalSourceId has a value which is a string
	technology has a value which is a string
	type has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_PlatformWithSamples
	2: a fields_Platform
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_PlatformWithSamples is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Platform is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	externalSourceId has a value which is a string
	technology has a value which is a string
	type has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_SampleRunOnPlatform
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SampleRunOnPlatform:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleRunOnPlatform');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SampleRunOnPlatform

    $return = $self->_get_relationship($ctx, 'SampleRunOnPlatform', 'PlatformWithSamples', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SampleRunOnPlatform
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SampleRunOnPlatform:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleRunOnPlatform');
    }
    return($return);
}




=head2 get_relationship_ProducedResultsFor

  $return = $obj->get_relationship_ProducedResultsFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProbeSet
	1: a fields_ProducedResultsFor
	2: a fields_Genome
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_ProducedResultsFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ProbeSet
	1: a fields_ProducedResultsFor
	2: a fields_Genome
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_ProducedResultsFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description

This relationship connects a probe set to a genome for which it was
used to produce experimental results. In general, a probe set is used for
only one genome and vice versa, but this is not a requirement.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_ProducedResultsFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ProducedResultsFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ProducedResultsFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ProducedResultsFor

    $return = $self->_get_relationship($ctx, 'ProducedResultsFor', 'ProducedResultsFor', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ProducedResultsFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ProducedResultsFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ProducedResultsFor');
    }
    return($return);
}




=head2 get_relationship_HadResultsProducedBy

  $return = $obj->get_relationship_HadResultsProducedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_ProducedResultsFor
	2: a fields_ProbeSet
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_ProducedResultsFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_ProducedResultsFor
	2: a fields_ProbeSet
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_ProducedResultsFor is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ProbeSet is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_HadResultsProducedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HadResultsProducedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HadResultsProducedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HadResultsProducedBy

    $return = $self->_get_relationship($ctx, 'HadResultsProducedBy', 'ProducedResultsFor', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HadResultsProducedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HadResultsProducedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HadResultsProducedBy');
    }
    return($return);
}




=head2 get_relationship_ProtocolForSample

  $return = $obj->get_relationship_ProtocolForSample($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Protocol
	1: a fields_ProtocolForSample
	2: a fields_Sample
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
fields_ProtocolForSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Protocol
	1: a fields_ProtocolForSample
	2: a fields_Sample
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
fields_ProtocolForSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int


=end text



=item Description

This relationship indicates the protocol used in the expression sample.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_ProtocolForSample
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ProtocolForSample:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ProtocolForSample');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ProtocolForSample

    $return = $self->_get_relationship($ctx, 'ProtocolForSample', 'ProtocolForSample', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ProtocolForSample
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ProtocolForSample:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ProtocolForSample');
    }
    return($return);
}




=head2 get_relationship_SampleUsesProtocol

  $return = $obj->get_relationship_SampleUsesProtocol($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_ProtocolForSample
	2: a fields_Protocol
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_ProtocolForSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_ProtocolForSample
	2: a fields_Protocol
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_ProtocolForSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_SampleUsesProtocol
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SampleUsesProtocol:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleUsesProtocol');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SampleUsesProtocol

    $return = $self->_get_relationship($ctx, 'SampleUsesProtocol', 'ProtocolForSample', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SampleUsesProtocol
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SampleUsesProtocol:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleUsesProtocol');
    }
    return($return);
}




=head2 get_relationship_Provided

  $return = $obj->get_relationship_Provided($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_Provided
	2: a fields_Subsystem
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_Provided is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_Provided
	2: a fields_Subsystem
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_Provided is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int


=end text



=item Description

This relationship connects a source (core) database
to the subsystems it submitted to the knowledge base.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_Provided
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Provided:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Provided');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Provided

    $return = $self->_get_relationship($ctx, 'Provided', 'Provided', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Provided
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Provided:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Provided');
    }
    return($return);
}




=head2 get_relationship_WasProvidedBy

  $return = $obj->get_relationship_WasProvidedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Subsystem
	1: a fields_Provided
	2: a fields_Source
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int
fields_Provided is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Subsystem
	1: a fields_Provided
	2: a fields_Source
fields_Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a string
	version has a value which is an int
	curator has a value which is a string
	notes has a value which is a string
	description has a value which is a string
	usable has a value which is an int
	private has a value which is an int
	cluster_based has a value which is an int
	experimental has a value which is an int
fields_Provided is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_WasProvidedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_WasProvidedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_WasProvidedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_WasProvidedBy

    $return = $self->_get_relationship($ctx, 'WasProvidedBy', 'Provided', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_WasProvidedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_WasProvidedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_WasProvidedBy');
    }
    return($return);
}




=head2 get_relationship_PublishedAssociation

  $return = $obj->get_relationship_PublishedAssociation($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Publication
	1: a fields_PublishedAssociation
	2: a fields_Association
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string
fields_PublishedAssociation is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Publication
	1: a fields_PublishedAssociation
	2: a fields_Association
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string
fields_PublishedAssociation is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string


=end text



=item Description

The PublishedAssociation relationship links associations
to the manuscript they are published in.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_PublishedAssociation
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_PublishedAssociation:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PublishedAssociation');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_PublishedAssociation

    $return = $self->_get_relationship($ctx, 'PublishedAssociation', 'PublishedAssociation', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_PublishedAssociation
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_PublishedAssociation:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PublishedAssociation');
    }
    return($return);
}




=head2 get_relationship_AssociationPublishedIn

  $return = $obj->get_relationship_AssociationPublishedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Association
	1: a fields_PublishedAssociation
	2: a fields_Publication
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string
fields_PublishedAssociation is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Association
	1: a fields_PublishedAssociation
	2: a fields_Publication
fields_Association is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	directional has a value which is an int
	confidence has a value which is a float
	url has a value which is a string
fields_PublishedAssociation is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_AssociationPublishedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_AssociationPublishedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AssociationPublishedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_AssociationPublishedIn

    $return = $self->_get_relationship($ctx, 'AssociationPublishedIn', 'PublishedAssociation', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_AssociationPublishedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_AssociationPublishedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AssociationPublishedIn');
    }
    return($return);
}




=head2 get_relationship_PublishedExperiment

  $return = $obj->get_relationship_PublishedExperiment($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Publication
	1: a fields_PublishedExperiment
	2: a fields_ExperimentMeta
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string
fields_PublishedExperiment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Publication
	1: a fields_PublishedExperiment
	2: a fields_ExperimentMeta
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string
fields_PublishedExperiment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string


=end text



=item Description

The PublishedExperiment relationship describes where a
particular experiment was published.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_PublishedExperiment
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_PublishedExperiment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PublishedExperiment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_PublishedExperiment

    $return = $self->_get_relationship($ctx, 'PublishedExperiment', 'PublishedExperiment', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_PublishedExperiment
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_PublishedExperiment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PublishedExperiment');
    }
    return($return);
}




=head2 get_relationship_ExperimentPublishedIn

  $return = $obj->get_relationship_ExperimentPublishedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentMeta
	1: a fields_PublishedExperiment
	2: a fields_Publication
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string
fields_PublishedExperiment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ExperimentMeta
	1: a fields_PublishedExperiment
	2: a fields_Publication
fields_ExperimentMeta is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	startDate has a value which is a string
	comments has a value which is a string
fields_PublishedExperiment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_ExperimentPublishedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ExperimentPublishedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ExperimentPublishedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ExperimentPublishedIn

    $return = $self->_get_relationship($ctx, 'ExperimentPublishedIn', 'PublishedExperiment', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ExperimentPublishedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ExperimentPublishedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ExperimentPublishedIn');
    }
    return($return);
}




=head2 get_relationship_PublishedProtocol

  $return = $obj->get_relationship_PublishedProtocol($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Publication
	1: a fields_PublishedProtocol
	2: a fields_Protocol
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string
fields_PublishedProtocol is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Publication
	1: a fields_PublishedProtocol
	2: a fields_Protocol
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string
fields_PublishedProtocol is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string


=end text



=item Description

The ProtocolPublishedIn relationship describes where a
particular protocol was published.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_PublishedProtocol
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_PublishedProtocol:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PublishedProtocol');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_PublishedProtocol

    $return = $self->_get_relationship($ctx, 'PublishedProtocol', 'PublishedProtocol', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_PublishedProtocol
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_PublishedProtocol:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PublishedProtocol');
    }
    return($return);
}




=head2 get_relationship_ProtocolPublishedIn

  $return = $obj->get_relationship_ProtocolPublishedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Protocol
	1: a fields_PublishedProtocol
	2: a fields_Publication
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
fields_PublishedProtocol is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Protocol
	1: a fields_PublishedProtocol
	2: a fields_Publication
fields_Protocol is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
fields_PublishedProtocol is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_ProtocolPublishedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ProtocolPublishedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ProtocolPublishedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ProtocolPublishedIn

    $return = $self->_get_relationship($ctx, 'ProtocolPublishedIn', 'PublishedProtocol', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ProtocolPublishedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ProtocolPublishedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ProtocolPublishedIn');
    }
    return($return);
}




=head2 get_relationship_RegulogHasRegulon

  $return = $obj->get_relationship_RegulogHasRegulon($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulog
	1: a fields_RegulogHasRegulon
	2: a fields_Regulon
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_RegulogHasRegulon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulog
	1: a fields_RegulogHasRegulon
	2: a fields_Regulon
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_RegulogHasRegulon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_RegulogHasRegulon
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_RegulogHasRegulon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_RegulogHasRegulon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_RegulogHasRegulon

    $return = $self->_get_relationship($ctx, 'RegulogHasRegulon', 'RegulogHasRegulon', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_RegulogHasRegulon
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_RegulogHasRegulon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_RegulogHasRegulon');
    }
    return($return);
}




=head2 get_relationship_RegulonIsInRegolog

  $return = $obj->get_relationship_RegulonIsInRegolog($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulon
	1: a fields_RegulogHasRegulon
	2: a fields_Regulog
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_RegulogHasRegulon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulon
	1: a fields_RegulogHasRegulon
	2: a fields_Regulog
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_RegulogHasRegulon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulog is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_RegulonIsInRegolog
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_RegulonIsInRegolog:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_RegulonIsInRegolog');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_RegulonIsInRegolog

    $return = $self->_get_relationship($ctx, 'RegulonIsInRegolog', 'RegulogHasRegulon', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_RegulonIsInRegolog
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_RegulonIsInRegolog:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_RegulonIsInRegolog');
    }
    return($return);
}




=head2 get_relationship_RegulomeHasGenome

  $return = $obj->get_relationship_RegulomeHasGenome($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulome
	1: a fields_RegulomeHasGenome
	2: a fields_Genome
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string
fields_RegulomeHasGenome is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulome
	1: a fields_RegulomeHasGenome
	2: a fields_Genome
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string
fields_RegulomeHasGenome is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_RegulomeHasGenome
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_RegulomeHasGenome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_RegulomeHasGenome');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_RegulomeHasGenome

    $return = $self->_get_relationship($ctx, 'RegulomeHasGenome', 'RegulomeHasGenome', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_RegulomeHasGenome
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_RegulomeHasGenome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_RegulomeHasGenome');
    }
    return($return);
}




=head2 get_relationship_GenomeIsInRegulome

  $return = $obj->get_relationship_GenomeIsInRegulome($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_RegulomeHasGenome
	2: a fields_Regulome
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_RegulomeHasGenome is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_RegulomeHasGenome
	2: a fields_Regulome
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_RegulomeHasGenome is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_GenomeIsInRegulome
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_GenomeIsInRegulome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_GenomeIsInRegulome');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_GenomeIsInRegulome

    $return = $self->_get_relationship($ctx, 'GenomeIsInRegulome', 'RegulomeHasGenome', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_GenomeIsInRegulome
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_GenomeIsInRegulome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_GenomeIsInRegulome');
    }
    return($return);
}




=head2 get_relationship_RegulomeHasRegulon

  $return = $obj->get_relationship_RegulomeHasRegulon($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulome
	1: a fields_RegulomeHasRegulon
	2: a fields_Regulon
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string
fields_RegulomeHasRegulon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulome
	1: a fields_RegulomeHasRegulon
	2: a fields_Regulon
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string
fields_RegulomeHasRegulon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_RegulomeHasRegulon
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_RegulomeHasRegulon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_RegulomeHasRegulon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_RegulomeHasRegulon

    $return = $self->_get_relationship($ctx, 'RegulomeHasRegulon', 'RegulomeHasRegulon', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_RegulomeHasRegulon
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_RegulomeHasRegulon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_RegulomeHasRegulon');
    }
    return($return);
}




=head2 get_relationship_RegulonIsInRegolome

  $return = $obj->get_relationship_RegulonIsInRegolome($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulon
	1: a fields_RegulomeHasRegulon
	2: a fields_Regulome
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_RegulomeHasRegulon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulon
	1: a fields_RegulomeHasRegulon
	2: a fields_Regulome
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_RegulomeHasRegulon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_RegulonIsInRegolome
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_RegulonIsInRegolome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_RegulonIsInRegolome');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_RegulonIsInRegolome

    $return = $self->_get_relationship($ctx, 'RegulonIsInRegolome', 'RegulomeHasRegulon', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_RegulonIsInRegolome
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_RegulonIsInRegolome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_RegulonIsInRegolome');
    }
    return($return);
}




=head2 get_relationship_RegulomeSource

  $return = $obj->get_relationship_RegulomeSource($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulome
	1: a fields_RegulomeSource
	2: a fields_Source
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string
fields_RegulomeSource is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulome
	1: a fields_RegulomeSource
	2: a fields_Source
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string
fields_RegulomeSource is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string


=end text



=item Description

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_RegulomeSource
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_RegulomeSource:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_RegulomeSource');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_RegulomeSource

    $return = $self->_get_relationship($ctx, 'RegulomeSource', 'RegulomeSource', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_RegulomeSource
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_RegulomeSource:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_RegulomeSource');
    }
    return($return);
}




=head2 get_relationship_CreatedRegulome

  $return = $obj->get_relationship_CreatedRegulome($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_RegulomeSource
	2: a fields_Regulome
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_RegulomeSource is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_RegulomeSource
	2: a fields_Regulome
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_RegulomeSource is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
	creation_date has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_CreatedRegulome
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_CreatedRegulome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_CreatedRegulome');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_CreatedRegulome

    $return = $self->_get_relationship($ctx, 'CreatedRegulome', 'RegulomeSource', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_CreatedRegulome
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_CreatedRegulome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_CreatedRegulome');
    }
    return($return);
}




=head2 get_relationship_RegulonHasOperon

  $return = $obj->get_relationship_RegulonHasOperon($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulon
	1: a fields_RegulonHasOperon
	2: a fields_Operon
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_RegulonHasOperon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Regulon
	1: a fields_RegulonHasOperon
	2: a fields_Operon
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string
fields_RegulonHasOperon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_RegulonHasOperon
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_RegulonHasOperon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_RegulonHasOperon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_RegulonHasOperon

    $return = $self->_get_relationship($ctx, 'RegulonHasOperon', 'RegulonHasOperon', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_RegulonHasOperon
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_RegulonHasOperon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_RegulonHasOperon');
    }
    return($return);
}




=head2 get_relationship_OperonIsInRegulon

  $return = $obj->get_relationship_OperonIsInRegulon($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Operon
	1: a fields_RegulonHasOperon
	2: a fields_Regulon
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_RegulonHasOperon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Operon
	1: a fields_RegulonHasOperon
	2: a fields_Regulon
fields_Operon is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_RegulonHasOperon is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Regulon is a reference to a hash where the following keys are defined:
	id has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_OperonIsInRegulon
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_OperonIsInRegulon:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_OperonIsInRegulon');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_OperonIsInRegulon

    $return = $self->_get_relationship($ctx, 'OperonIsInRegulon', 'RegulonHasOperon', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_OperonIsInRegulon
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_OperonIsInRegulon:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_OperonIsInRegulon');
    }
    return($return);
}




=head2 get_relationship_SampleAveragedFrom

  $return = $obj->get_relationship_SampleAveragedFrom($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_SampleAveragedFrom
	2: a fields_Sample
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_SampleAveragedFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_SampleAveragedFrom
	2: a fields_Sample
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_SampleAveragedFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string


=end text



=item Description

Custom averaging of samples (typically replicates).

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_SampleAveragedFrom
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SampleAveragedFrom:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleAveragedFrom');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SampleAveragedFrom

    $return = $self->_get_relationship($ctx, 'SampleAveragedFrom', 'SampleAveragedFrom', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SampleAveragedFrom
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SampleAveragedFrom:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleAveragedFrom');
    }
    return($return);
}




=head2 get_relationship_SampleComponentOf

  $return = $obj->get_relationship_SampleComponentOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_SampleAveragedFrom
	2: a fields_Sample
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_SampleAveragedFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_SampleAveragedFrom
	2: a fields_Sample
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_SampleAveragedFrom is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_SampleComponentOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SampleComponentOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleComponentOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SampleComponentOf

    $return = $self->_get_relationship($ctx, 'SampleComponentOf', 'SampleAveragedFrom', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SampleComponentOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SampleComponentOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleComponentOf');
    }
    return($return);
}




=head2 get_relationship_SampleContactPerson

  $return = $obj->get_relationship_SampleContactPerson($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_SampleContactPerson
	2: a fields_Person
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_SampleContactPerson is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_SampleContactPerson
	2: a fields_Person
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_SampleContactPerson is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string


=end text



=item Description

The people that performed the expression experiment(sample).

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_SampleContactPerson
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SampleContactPerson:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleContactPerson');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SampleContactPerson

    $return = $self->_get_relationship($ctx, 'SampleContactPerson', 'SampleContactPerson', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SampleContactPerson
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SampleContactPerson:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleContactPerson');
    }
    return($return);
}




=head2 get_relationship_PersonPerformedSample

  $return = $obj->get_relationship_PersonPerformedSample($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Person
	1: a fields_SampleContactPerson
	2: a fields_Sample
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string
fields_SampleContactPerson is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Person
	1: a fields_SampleContactPerson
	2: a fields_Sample
fields_Person is a reference to a hash where the following keys are defined:
	id has a value which is a string
	firstName has a value which is a string
	lastName has a value which is a string
	contactEmail has a value which is a string
	institution has a value which is a string
	source_id has a value which is a string
fields_SampleContactPerson is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_PersonPerformedSample
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_PersonPerformedSample:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PersonPerformedSample');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_PersonPerformedSample

    $return = $self->_get_relationship($ctx, 'PersonPerformedSample', 'SampleContactPerson', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_PersonPerformedSample
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_PersonPerformedSample:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PersonPerformedSample');
    }
    return($return);
}




=head2 get_relationship_SampleHasAnnotations

  $return = $obj->get_relationship_SampleHasAnnotations($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_SampleHasAnnotations
	2: a fields_SampleAnnotation
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_SampleHasAnnotations is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_SampleHasAnnotations
	2: a fields_SampleAnnotation
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_SampleHasAnnotations is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string


=end text



=item Description

This relationship indicates the sample annotations that belong to the sample.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_SampleHasAnnotations
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SampleHasAnnotations:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleHasAnnotations');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SampleHasAnnotations

    $return = $self->_get_relationship($ctx, 'SampleHasAnnotations', 'SampleHasAnnotations', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SampleHasAnnotations
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SampleHasAnnotations:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleHasAnnotations');
    }
    return($return);
}




=head2 get_relationship_AnnotationsForSample

  $return = $obj->get_relationship_AnnotationsForSample($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SampleAnnotation
	1: a fields_SampleHasAnnotations
	2: a fields_Sample
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string
fields_SampleHasAnnotations is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SampleAnnotation
	1: a fields_SampleHasAnnotations
	2: a fields_Sample
fields_SampleAnnotation is a reference to a hash where the following keys are defined:
	id has a value which is a string
	annotationDate has a value which is a string
	source_id has a value which is a string
fields_SampleHasAnnotations is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_AnnotationsForSample
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_AnnotationsForSample:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AnnotationsForSample');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_AnnotationsForSample

    $return = $self->_get_relationship($ctx, 'AnnotationsForSample', 'SampleHasAnnotations', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_AnnotationsForSample
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_AnnotationsForSample:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AnnotationsForSample');
    }
    return($return);
}




=head2 get_relationship_SampleInSeries

  $return = $obj->get_relationship_SampleInSeries($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_SampleInSeries
	2: a fields_Series
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_SampleInSeries is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Series is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	summary has a value which is a string
	design has a value which is a string
	externalSourceId has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_SampleInSeries
	2: a fields_Series
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_SampleInSeries is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Series is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	summary has a value which is a string
	design has a value which is a string
	externalSourceId has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	source_id has a value which is a string


=end text



=item Description

This relationship indicates what samples are in a series.  Note a sample can be in more than one series.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_SampleInSeries
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SampleInSeries:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleInSeries');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SampleInSeries

    $return = $self->_get_relationship($ctx, 'SampleInSeries', 'SampleInSeries', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SampleInSeries
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SampleInSeries:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleInSeries');
    }
    return($return);
}




=head2 get_relationship_SeriesWithSamples

  $return = $obj->get_relationship_SeriesWithSamples($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Series
	1: a fields_SampleInSeries
	2: a fields_Sample
fields_Series is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	summary has a value which is a string
	design has a value which is a string
	externalSourceId has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	source_id has a value which is a string
fields_SampleInSeries is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Series
	1: a fields_SampleInSeries
	2: a fields_Sample
fields_Series is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	summary has a value which is a string
	design has a value which is a string
	externalSourceId has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	source_id has a value which is a string
fields_SampleInSeries is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_SeriesWithSamples
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SeriesWithSamples:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SeriesWithSamples');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SeriesWithSamples

    $return = $self->_get_relationship($ctx, 'SeriesWithSamples', 'SampleInSeries', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SeriesWithSamples
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SeriesWithSamples:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SeriesWithSamples');
    }
    return($return);
}




=head2 get_relationship_SampleMeasurements

  $return = $obj->get_relationship_SampleMeasurements($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_SampleMeasurements
	2: a fields_Measurement
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_SampleMeasurements is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_SampleMeasurements
	2: a fields_Measurement
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_SampleMeasurements is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float


=end text



=item Description

The Measurements for expression microarray data should be in Log2 space and 
the measurements for a given sample should have the median set to zero.  RNA-Seq data will likely be in FPKM.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_SampleMeasurements
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SampleMeasurements:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleMeasurements');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SampleMeasurements

    $return = $self->_get_relationship($ctx, 'SampleMeasurements', 'SampleMeasurements', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SampleMeasurements
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SampleMeasurements:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleMeasurements');
    }
    return($return);
}




=head2 get_relationship_MeasurementInSample

  $return = $obj->get_relationship_MeasurementInSample($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Measurement
	1: a fields_SampleMeasurements
	2: a fields_Sample
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float
fields_SampleMeasurements is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Measurement
	1: a fields_SampleMeasurements
	2: a fields_Sample
fields_Measurement is a reference to a hash where the following keys are defined:
	id has a value which is a string
	source_id has a value which is a string
	value has a value which is a float
	mean has a value which is a float
	median has a value which is a float
	stddev has a value which is a float
	N has a value which is an int
	p_value has a value which is a float
	Z_score has a value which is a float
fields_SampleMeasurements is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_MeasurementInSample
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_MeasurementInSample:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_MeasurementInSample');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_MeasurementInSample

    $return = $self->_get_relationship($ctx, 'MeasurementInSample', 'SampleMeasurements', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_MeasurementInSample
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_MeasurementInSample:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_MeasurementInSample');
    }
    return($return);
}




=head2 get_relationship_SamplesInReplicateGroup

  $return = $obj->get_relationship_SamplesInReplicateGroup($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_SamplesInReplicateGroup
	2: a fields_ReplicateGroup
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_SamplesInReplicateGroup is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ReplicateGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_SamplesInReplicateGroup
	2: a fields_ReplicateGroup
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_SamplesInReplicateGroup is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_ReplicateGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string


=end text



=item Description

The samples that are identified as being part of one replicate group.  All samples in replicate group are replicates of one another.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_SamplesInReplicateGroup
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SamplesInReplicateGroup:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SamplesInReplicateGroup');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SamplesInReplicateGroup

    $return = $self->_get_relationship($ctx, 'SamplesInReplicateGroup', 'SamplesInReplicateGroup', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SamplesInReplicateGroup
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SamplesInReplicateGroup:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SamplesInReplicateGroup');
    }
    return($return);
}




=head2 get_relationship_ReplicateGroupsForSample

  $return = $obj->get_relationship_ReplicateGroupsForSample($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ReplicateGroup
	1: a fields_SamplesInReplicateGroup
	2: a fields_Sample
fields_ReplicateGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_SamplesInReplicateGroup is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_ReplicateGroup
	1: a fields_SamplesInReplicateGroup
	2: a fields_Sample
fields_ReplicateGroup is a reference to a hash where the following keys are defined:
	id has a value which is a string
fields_SamplesInReplicateGroup is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int


=end text



=item Description



=back

=cut

sub get_relationship_ReplicateGroupsForSample
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_ReplicateGroupsForSample:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ReplicateGroupsForSample');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_ReplicateGroupsForSample

    $return = $self->_get_relationship($ctx, 'ReplicateGroupsForSample', 'SamplesInReplicateGroup', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_ReplicateGroupsForSample
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_ReplicateGroupsForSample:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_ReplicateGroupsForSample');
    }
    return($return);
}




=head2 get_relationship_SeriesPublishedIn

  $return = $obj->get_relationship_SeriesPublishedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Series
	1: a fields_SeriesPublishedIn
	2: a fields_Publication
fields_Series is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	summary has a value which is a string
	design has a value which is a string
	externalSourceId has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	source_id has a value which is a string
fields_SeriesPublishedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Series
	1: a fields_SeriesPublishedIn
	2: a fields_Publication
fields_Series is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	summary has a value which is a string
	design has a value which is a string
	externalSourceId has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	source_id has a value which is a string
fields_SeriesPublishedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string


=end text



=item Description

This relationship indicates where the series was published.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_SeriesPublishedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SeriesPublishedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SeriesPublishedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SeriesPublishedIn

    $return = $self->_get_relationship($ctx, 'SeriesPublishedIn', 'SeriesPublishedIn', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SeriesPublishedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SeriesPublishedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SeriesPublishedIn');
    }
    return($return);
}




=head2 get_relationship_PublicationsForSeries

  $return = $obj->get_relationship_PublicationsForSeries($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Publication
	1: a fields_SeriesPublishedIn
	2: a fields_Series
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string
fields_SeriesPublishedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Series is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	summary has a value which is a string
	design has a value which is a string
	externalSourceId has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Publication
	1: a fields_SeriesPublishedIn
	2: a fields_Series
fields_Publication is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	link has a value which is a string
	pubdate has a value which is a string
fields_SeriesPublishedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Series is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	summary has a value which is a string
	design has a value which is a string
	externalSourceId has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_PublicationsForSeries
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_PublicationsForSeries:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PublicationsForSeries');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_PublicationsForSeries

    $return = $self->_get_relationship($ctx, 'PublicationsForSeries', 'SeriesPublishedIn', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_PublicationsForSeries
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_PublicationsForSeries:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PublicationsForSeries');
    }
    return($return);
}




=head2 get_relationship_Shows

  $return = $obj->get_relationship_Shows($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Diagram
	1: a fields_Shows
	2: a fields_Compound
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string
fields_Shows is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	location has a value which is a rectangle
rectangle is a string
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Diagram
	1: a fields_Shows
	2: a fields_Compound
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string
fields_Shows is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	location has a value which is a rectangle
rectangle is a string
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float


=end text



=item Description

This relationship indicates that a compound appears on a
particular diagram. The same compound can appear on many diagrams,
and a diagram always contains many compounds.

It has the following fields:

=over 4

=item location

Location of the compound's node on the diagram.


=back

=back

=cut

sub get_relationship_Shows
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Shows:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Shows');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Shows

    $return = $self->_get_relationship($ctx, 'Shows', 'Shows', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Shows
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Shows:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Shows');
    }
    return($return);
}




=head2 get_relationship_IsShownOn

  $return = $obj->get_relationship_IsShownOn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_Shows
	2: a fields_Diagram
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_Shows is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	location has a value which is a rectangle
rectangle is a string
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Compound
	1: a fields_Shows
	2: a fields_Diagram
fields_Compound is a reference to a hash where the following keys are defined:
	id has a value which is a string
	label has a value which is a string
	abbr has a value which is a string
	source_id has a value which is a string
	ubiquitous has a value which is an int
	mod_date has a value which is a string
	mass has a value which is a float
	formula has a value which is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaG_error has a value which is a float
fields_Shows is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	location has a value which is a rectangle
rectangle is a string
fields_Diagram is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	content has a value which is a reference to a list where each element is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsShownOn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsShownOn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsShownOn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsShownOn

    $return = $self->_get_relationship($ctx, 'IsShownOn', 'Shows', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsShownOn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsShownOn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsShownOn');
    }
    return($return);
}




=head2 get_relationship_StrainParentOf

  $return = $obj->get_relationship_StrainParentOf($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Strain
	1: a fields_StrainParentOf
	2: a fields_Strain
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string
fields_StrainParentOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Strain
	1: a fields_StrainParentOf
	2: a fields_Strain
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string
fields_StrainParentOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string


=end text



=item Description

The recursive StrainParentOf relationship organizes derived
organisms into a tree based on parent/child relationships.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_StrainParentOf
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_StrainParentOf:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_StrainParentOf');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_StrainParentOf

    $return = $self->_get_relationship($ctx, 'StrainParentOf', 'StrainParentOf', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_StrainParentOf
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_StrainParentOf:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_StrainParentOf');
    }
    return($return);
}




=head2 get_relationship_DerivedFromStrain

  $return = $obj->get_relationship_DerivedFromStrain($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Strain
	1: a fields_StrainParentOf
	2: a fields_Strain
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string
fields_StrainParentOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Strain
	1: a fields_StrainParentOf
	2: a fields_Strain
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string
fields_StrainParentOf is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_DerivedFromStrain
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_DerivedFromStrain:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DerivedFromStrain');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_DerivedFromStrain

    $return = $self->_get_relationship($ctx, 'DerivedFromStrain', 'StrainParentOf', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_DerivedFromStrain
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_DerivedFromStrain:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_DerivedFromStrain');
    }
    return($return);
}




=head2 get_relationship_StrainWithPlatforms

  $return = $obj->get_relationship_StrainWithPlatforms($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Strain
	1: a fields_StrainWithPlatforms
	2: a fields_Platform
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string
fields_StrainWithPlatforms is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Platform is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	externalSourceId has a value which is a string
	technology has a value which is a string
	type has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Strain
	1: a fields_StrainWithPlatforms
	2: a fields_Platform
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string
fields_StrainWithPlatforms is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Platform is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	externalSourceId has a value which is a string
	technology has a value which is a string
	type has a value which is a string
	source_id has a value which is a string


=end text



=item Description

This relationship indicates the platforms for a strain.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_StrainWithPlatforms
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_StrainWithPlatforms:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_StrainWithPlatforms');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_StrainWithPlatforms

    $return = $self->_get_relationship($ctx, 'StrainWithPlatforms', 'StrainWithPlatforms', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_StrainWithPlatforms
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_StrainWithPlatforms:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_StrainWithPlatforms');
    }
    return($return);
}




=head2 get_relationship_PlatformForStrain

  $return = $obj->get_relationship_PlatformForStrain($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Platform
	1: a fields_StrainWithPlatforms
	2: a fields_Strain
fields_Platform is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	externalSourceId has a value which is a string
	technology has a value which is a string
	type has a value which is a string
	source_id has a value which is a string
fields_StrainWithPlatforms is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Platform
	1: a fields_StrainWithPlatforms
	2: a fields_Strain
fields_Platform is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	externalSourceId has a value which is a string
	technology has a value which is a string
	type has a value which is a string
	source_id has a value which is a string
fields_StrainWithPlatforms is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_PlatformForStrain
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_PlatformForStrain:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PlatformForStrain');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_PlatformForStrain

    $return = $self->_get_relationship($ctx, 'PlatformForStrain', 'StrainWithPlatforms', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_PlatformForStrain
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_PlatformForStrain:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_PlatformForStrain');
    }
    return($return);
}




=head2 get_relationship_StrainWithSample

  $return = $obj->get_relationship_StrainWithSample($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Strain
	1: a fields_StrainWithSample
	2: a fields_Sample
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string
fields_StrainWithSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Strain
	1: a fields_StrainWithSample
	2: a fields_Sample
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string
fields_StrainWithSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int


=end text



=item Description

This indicates which expression samples a strain has.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_StrainWithSample
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_StrainWithSample:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_StrainWithSample');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_StrainWithSample

    $return = $self->_get_relationship($ctx, 'StrainWithSample', 'StrainWithSample', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_StrainWithSample
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_StrainWithSample:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_StrainWithSample');
    }
    return($return);
}




=head2 get_relationship_SampleForStrain

  $return = $obj->get_relationship_SampleForStrain($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_StrainWithSample
	2: a fields_Strain
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_StrainWithSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Sample
	1: a fields_StrainWithSample
	2: a fields_Strain
fields_Sample is a reference to a hash where the following keys are defined:
	id has a value which is a string
	title has a value which is a string
	dataSource has a value which is a string
	externalSourceId has a value which is a string
	description has a value which is a string
	molecule has a value which is a string
	type has a value which is a string
	kbaseSubmissionDate has a value which is a string
	externalSourceDate has a value which is a string
	custom has a value which is a string
	originalLog2Median has a value which is a float
	source_id has a value which is a string
	dataQualityLevel has a value which is an int
fields_StrainWithSample is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Strain is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	description has a value which is a string
	source_id has a value which is a string
	aggregateData has a value which is a string
	wildtype has a value which is a string
	referenceStrain has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_SampleForStrain
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SampleForStrain:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleForStrain');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SampleForStrain

    $return = $self->_get_relationship($ctx, 'SampleForStrain', 'StrainWithSample', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SampleForStrain
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SampleForStrain:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SampleForStrain');
    }
    return($return);
}




=head2 get_relationship_Submitted

  $return = $obj->get_relationship_Submitted($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_Submitted
	2: a fields_Genome
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_Submitted is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_Submitted
	2: a fields_Genome
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_Submitted is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description

This relationship connects a genome to the
core database from which it was loaded.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_Submitted
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Submitted:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Submitted');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Submitted

    $return = $self->_get_relationship($ctx, 'Submitted', 'Submitted', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Submitted
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Submitted:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Submitted');
    }
    return($return);
}




=head2 get_relationship_WasSubmittedBy

  $return = $obj->get_relationship_WasSubmittedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_Submitted
	2: a fields_Source
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_Submitted is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_Submitted
	2: a fields_Source
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_Submitted is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_WasSubmittedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_WasSubmittedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_WasSubmittedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_WasSubmittedBy

    $return = $self->_get_relationship($ctx, 'WasSubmittedBy', 'Submitted', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_WasSubmittedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_WasSubmittedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_WasSubmittedBy');
    }
    return($return);
}




=head2 get_relationship_SupersedesAlignment

  $return = $obj->get_relationship_SupersedesAlignment($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_SupersedesAlignment
	2: a fields_Alignment
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_SupersedesAlignment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	successor_type has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_SupersedesAlignment
	2: a fields_Alignment
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_SupersedesAlignment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	successor_type has a value which is a string


=end text



=item Description

This relationship connects an alignment to the alignments
it replaces.

It has the following fields:

=over 4

=item successor_type

Indicates whether sequences were removed or added to create the new alignment.


=back

=back

=cut

sub get_relationship_SupersedesAlignment
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SupersedesAlignment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SupersedesAlignment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SupersedesAlignment

    $return = $self->_get_relationship($ctx, 'SupersedesAlignment', 'SupersedesAlignment', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SupersedesAlignment
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SupersedesAlignment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SupersedesAlignment');
    }
    return($return);
}




=head2 get_relationship_IsSupersededByAlignment

  $return = $obj->get_relationship_IsSupersededByAlignment($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_SupersedesAlignment
	2: a fields_Alignment
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_SupersedesAlignment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	successor_type has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Alignment
	1: a fields_SupersedesAlignment
	2: a fields_Alignment
fields_Alignment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	n_rows has a value which is an int
	n_cols has a value which is an int
	status has a value which is a string
	is_concatenation has a value which is an int
	sequence_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
fields_SupersedesAlignment is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	successor_type has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsSupersededByAlignment
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsSupersededByAlignment:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSupersededByAlignment');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsSupersededByAlignment

    $return = $self->_get_relationship($ctx, 'IsSupersededByAlignment', 'SupersedesAlignment', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsSupersededByAlignment
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsSupersededByAlignment:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSupersededByAlignment');
    }
    return($return);
}




=head2 get_relationship_SupersedesTree

  $return = $obj->get_relationship_SupersedesTree($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_SupersedesTree
	2: a fields_Tree
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_SupersedesTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	successor_type has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_SupersedesTree
	2: a fields_Tree
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_SupersedesTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	successor_type has a value which is a string


=end text



=item Description

This relationship connects a tree to the trees
it replaces.

It has the following fields:

=over 4

=item successor_type

Indicates whether sequences were removed or added to create the new tree.


=back

=back

=cut

sub get_relationship_SupersedesTree
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_SupersedesTree:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SupersedesTree');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_SupersedesTree

    $return = $self->_get_relationship($ctx, 'SupersedesTree', 'SupersedesTree', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_SupersedesTree
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_SupersedesTree:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_SupersedesTree');
    }
    return($return);
}




=head2 get_relationship_IsSupersededByTree

  $return = $obj->get_relationship_IsSupersededByTree($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_SupersedesTree
	2: a fields_Tree
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_SupersedesTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	successor_type has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_SupersedesTree
	2: a fields_Tree
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_SupersedesTree is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
	successor_type has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsSupersededByTree
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsSupersededByTree:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSupersededByTree');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsSupersededByTree

    $return = $self->_get_relationship($ctx, 'IsSupersededByTree', 'SupersedesTree', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsSupersededByTree
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsSupersededByTree:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsSupersededByTree');
    }
    return($return);
}




=head2 get_relationship_Treed

  $return = $obj->get_relationship_Treed($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_Treed
	2: a fields_Tree
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_Treed is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Source
	1: a fields_Treed
	2: a fields_Tree
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string
fields_Treed is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string


=end text



=item Description

This relationship connects a tree to the source database from
which it was generated.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_Treed
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Treed:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Treed');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Treed

    $return = $self->_get_relationship($ctx, 'Treed', 'Treed', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Treed
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Treed:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Treed');
    }
    return($return);
}




=head2 get_relationship_IsTreeFrom

  $return = $obj->get_relationship_IsTreeFrom($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_Treed
	2: a fields_Source
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_Treed is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Tree
	1: a fields_Treed
	2: a fields_Source
fields_Tree is a reference to a hash where the following keys are defined:
	id has a value which is a string
	status has a value which is a string
	data_type has a value which is a string
	timestamp has a value which is a string
	method has a value which is a string
	parameters has a value which is a string
	protocol has a value which is a string
	source_id has a value which is a string
	newick has a value which is a string
fields_Treed is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Source is a reference to a hash where the following keys are defined:
	id has a value which is a string
	name has a value which is a string
	url has a value which is a string
	description has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsTreeFrom
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsTreeFrom:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsTreeFrom');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsTreeFrom

    $return = $self->_get_relationship($ctx, 'IsTreeFrom', 'Treed', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsTreeFrom
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsTreeFrom:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsTreeFrom');
    }
    return($return);
}




=head2 get_relationship_UsedIn

  $return = $obj->get_relationship_UsedIn($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Media
	1: a fields_UsedIn
	2: a fields_Environment
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string
fields_UsedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Media
	1: a fields_UsedIn
	2: a fields_Environment
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string
fields_UsedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string


=end text



=item Description

The UsedIn relationship defines which media is used by an
Environment.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_UsedIn
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_UsedIn:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_UsedIn');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_UsedIn

    $return = $self->_get_relationship($ctx, 'UsedIn', 'UsedIn', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_UsedIn
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_UsedIn:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_UsedIn');
    }
    return($return);
}




=head2 get_relationship_HasMedia

  $return = $obj->get_relationship_HasMedia($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Environment
	1: a fields_UsedIn
	2: a fields_Media
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string
fields_UsedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Environment
	1: a fields_UsedIn
	2: a fields_Media
fields_Environment is a reference to a hash where the following keys are defined:
	id has a value which is a string
	temperature has a value which is a float
	description has a value which is a string
	oxygenConcentration has a value which is a float
	pH has a value which is a float
	source_id has a value which is a string
fields_UsedIn is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Media is a reference to a hash where the following keys are defined:
	id has a value which is a string
	mod_date has a value which is a string
	name has a value which is a string
	is_minimal has a value which is a string
	source_id has a value which is a string
	type has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_HasMedia
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_HasMedia:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasMedia');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_HasMedia

    $return = $self->_get_relationship($ctx, 'HasMedia', 'UsedIn', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_HasMedia
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_HasMedia:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_HasMedia');
    }
    return($return);
}




=head2 get_relationship_Uses

  $return = $obj->get_relationship_Uses($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_Uses
	2: a fields_SSRow
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_Uses is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_Uses
	2: a fields_SSRow
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_Uses is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string


=end text



=item Description

This relationship connects a genome to the machines that form
its metabolic pathways. A genome can use many machines, but a
machine is used by exactly one genome.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_Uses
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_Uses:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Uses');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_Uses

    $return = $self->_get_relationship($ctx, 'Uses', 'Uses', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_Uses
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_Uses:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_Uses');
    }
    return($return);
}




=head2 get_relationship_IsUsedBy

  $return = $obj->get_relationship_IsUsedBy($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SSRow
	1: a fields_Uses
	2: a fields_Genome
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string
fields_Uses is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_SSRow
	1: a fields_Uses
	2: a fields_Genome
fields_SSRow is a reference to a hash where the following keys are defined:
	id has a value which is a string
	curated has a value which is an int
	region has a value which is a string
fields_Uses is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_IsUsedBy
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_IsUsedBy:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsUsedBy');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_IsUsedBy

    $return = $self->_get_relationship($ctx, 'IsUsedBy', 'Uses', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_IsUsedBy
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_IsUsedBy:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_IsUsedBy');
    }
    return($return);
}




=head2 get_relationship_UsesCodons

  $return = $obj->get_relationship_UsesCodons($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_UsesCodons
	2: a fields_CodonUsage
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_UsesCodons is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_CodonUsage is a reference to a hash where the following keys are defined:
	id has a value which is a string
	frequencies has a value which is a string
	genetic_code has a value which is an int
	type has a value which is a string
	subtype has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_Genome
	1: a fields_UsesCodons
	2: a fields_CodonUsage
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string
fields_UsesCodons is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_CodonUsage is a reference to a hash where the following keys are defined:
	id has a value which is a string
	frequencies has a value which is a string
	genetic_code has a value which is an int
	type has a value which is a string
	subtype has a value which is a string


=end text



=item Description

This relationship connects a genome to the various codon usage
records for it.

It has the following fields:

=over 4


=back

=back

=cut

sub get_relationship_UsesCodons
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_UsesCodons:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_UsesCodons');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_UsesCodons

    $return = $self->_get_relationship($ctx, 'UsesCodons', 'UsesCodons', 0, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_UsesCodons
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_UsesCodons:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_UsesCodons');
    }
    return($return);
}




=head2 get_relationship_AreCodonsFor

  $return = $obj->get_relationship_AreCodonsFor($ids, $from_fields, $rel_fields, $to_fields)

=over 4

=item Parameter and return types

=begin html

<pre>
$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CodonUsage
	1: a fields_UsesCodons
	2: a fields_Genome
fields_CodonUsage is a reference to a hash where the following keys are defined:
	id has a value which is a string
	frequencies has a value which is a string
	genetic_code has a value which is an int
	type has a value which is a string
	subtype has a value which is a string
fields_UsesCodons is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string

</pre>

=end html

=begin text

$ids is a reference to a list where each element is a string
$from_fields is a reference to a list where each element is a string
$rel_fields is a reference to a list where each element is a string
$to_fields is a reference to a list where each element is a string
$return is a reference to a list where each element is a reference to a list containing 3 items:
	0: a fields_CodonUsage
	1: a fields_UsesCodons
	2: a fields_Genome
fields_CodonUsage is a reference to a hash where the following keys are defined:
	id has a value which is a string
	frequencies has a value which is a string
	genetic_code has a value which is an int
	type has a value which is a string
	subtype has a value which is a string
fields_UsesCodons is a reference to a hash where the following keys are defined:
	from_link has a value which is a string
	to_link has a value which is a string
fields_Genome is a reference to a hash where the following keys are defined:
	id has a value which is a string
	pegs has a value which is an int
	rnas has a value which is an int
	scientific_name has a value which is a string
	complete has a value which is an int
	prokaryotic has a value which is an int
	dna_size has a value which is an int
	contigs has a value which is an int
	domain has a value which is a string
	genetic_code has a value which is an int
	gc_content has a value which is a float
	phenotype has a value which is a reference to a list where each element is a string
	md5 has a value which is a string
	source_id has a value which is a string


=end text



=item Description



=back

=cut

sub get_relationship_AreCodonsFor
{
    my $self = shift;
    my($ids, $from_fields, $rel_fields, $to_fields) = @_;

    my @_bad_arguments;
    (ref($ids) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"ids\" (value was \"$ids\")");
    (ref($from_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"from_fields\" (value was \"$from_fields\")");
    (ref($rel_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"rel_fields\" (value was \"$rel_fields\")");
    (ref($to_fields) eq 'ARRAY') or push(@_bad_arguments, "Invalid type for argument \"to_fields\" (value was \"$to_fields\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_relationship_AreCodonsFor:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AreCodonsFor');
    }

    my $ctx = $Bio::KBase::CDMI::Service::CallContext;
    my($return);
    #BEGIN get_relationship_AreCodonsFor

    $return = $self->_get_relationship($ctx, 'AreCodonsFor', 'UsesCodons', 1, $ids, $from_fields, $rel_fields, $to_fields);
	
    #END get_relationship_AreCodonsFor
    my @_bad_returns;
    (ref($return) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"return\" (value was \"$return\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_relationship_AreCodonsFor:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_relationship_AreCodonsFor');
    }
    return($return);
}




=head2 version 

  $return = $obj->version()

=over 4

=item Parameter and return types

=begin html

<pre>
$return is a string
</pre>

=end html

=begin text

$return is a string

=end text

=item Description

Return the module version. This is a Semantic Versioning number.

=back

=cut

sub version {
    return $VERSION;
}

=head1 TYPES



=head2 annotator

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 annotation_time

=over 4



=item Definition

=begin html

<pre>
an int
</pre>

=end html

=begin text

an int

=end text

=back



=head2 comment

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 fid

=over 4



=item Description

A fid is a "feature id".  A feature represents an ordered list of regions from
the contigs of a genome.  Features all have types.  This allows you to speak
of not only protein-encoding genes (PEGs) and RNAs, but also binding sites,
large regions, etc.  The location of a fid is defined as a list of
"location of a contiguous DNA string" pieces (see the description of the
type "location")


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 protein_family

=over 4



=item Description

A protein_family is thought of as a set of isofunctional, homologous protein sequences.
This is not exactly what other groups have meant by "protein families".  There is no
hierarchy of super-family, family, sub-family.  We plan on loading different collections
of protein families, but in many cases there will need to be a transformation into the
concept used by Kbase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 role

=over 4



=item Description

The concept of "role" or "functional role" is basically an atomic functional unit.
The "function of a protein" is made up of one or more roles.  That is, a bifunctional protein
with an assigned function of

   5-Enolpyruvylshikimate-3-phosphate synthase (EC 2.5.1.19) / Cytidylate kinase (EC 2.7.4.14)

would implement two distinct roles (the "function1 / function2" notation is intended to assert
that the initial part of the protein implements function1, and the terminal part of the protein
implements function2).  It is worth noting that a protein often implements multiple roles due
to broad specificity.  In this case, we suggest describing the protein function as

     function1 @ function2

That is the ' / ' separator is used to represent multiple roles implemented by distinct
domains of the protein, while ' @ ' is used to represent multiple roles implemented by
distinct domains.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 subsystem

=over 4



=item Description

A substem is composed of two components: a set of roles that are gathered to be annotated
simultaneously and a spreadsheet depicting the proteins within each genome that implement
the roles.  The set of roles may correspond to a pathway, a complex, an inventory (say, "transporters")
or whatever other principle an annotator used to formulate the subsystem.

The subsystem spreadsheet is a list of "rows", each representing the subsytem in a specific genome.
Each row includes a variant code (indicating what version of the molecular machine exists in the
genome) and cells.  Each cell is a 2-tuple:

     [role,protein-encoding genes that implement the role in the genome]

Annotators construct subsystems, and in the process impose a controlled vocabulary
for roles and functions.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 variant

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 variant_of_subsystem

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: a subsystem
1: a variant

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: a subsystem
1: a variant


=end text

=back



=head2 variant_subsystem_pairs

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a variant_of_subsystem
</pre>

=end html

=begin text

a reference to a list where each element is a variant_of_subsystem

=end text

=back



=head2 type_of_fid

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 types_of_fids

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a type_of_fid
</pre>

=end html

=begin text

a reference to a list where each element is a type_of_fid

=end text

=back



=head2 length

=over 4



=item Definition

=begin html

<pre>
an int
</pre>

=end html

=begin text

an int

=end text

=back



=head2 begin

=over 4



=item Definition

=begin html

<pre>
an int
</pre>

=end html

=begin text

an int

=end text

=back



=head2 strand

=over 4



=item Description

In encodings of locations, we often specify strands.  We specify the strand
as '+' or '-'


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 contig

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 region_of_dna

=over 4



=item Description

A region of DNA is maintained as a tuple of four components:

                the contig
                the beginning position (from 1)
                the strand
                the length

           We often speak of "a region".  By "location", we mean a sequence
           of regions from the same genome (perhaps from distinct contigs).


=item Definition

=begin html

<pre>
a reference to a list containing 4 items:
0: a contig
1: a begin
2: a strand
3: a length

</pre>

=end html

=begin text

a reference to a list containing 4 items:
0: a contig
1: a begin
2: a strand
3: a length


=end text

=back



=head2 location

=over 4



=item Description

a "location" refers to a sequence of regions


=item Definition

=begin html

<pre>
a reference to a list where each element is a region_of_dna
</pre>

=end html

=begin text

a reference to a list where each element is a region_of_dna

=end text

=back



=head2 locations

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a location
</pre>

=end html

=begin text

a reference to a list where each element is a location

=end text

=back



=head2 region_of_dna_string

=over 4



=item Description

we often need to represent regions or locations as
strings.  We would use something like

     contigA_200+100,contigA_402+188

to represent a location composed of two regions


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 region_of_dna_strings

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a region_of_dna_string
</pre>

=end html

=begin text

a reference to a list where each element is a region_of_dna_string

=end text

=back



=head2 location_string

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 dna

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 function

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 protein

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 md5

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 genome

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 taxonomic_group

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 annotation

=over 4



=item Description

The Kbase stores annotations relating to features.  Each annotation
is a 3-tuple:

     the text of the annotation (often a record of assertion of function)

     the annotator attaching the annotation to the feature

     the time (in seconds from the epoch) at which the annotation was attached


=item Definition

=begin html

<pre>
a reference to a list containing 3 items:
0: a comment
1: an annotator
2: an annotation_time

</pre>

=end html

=begin text

a reference to a list containing 3 items:
0: a comment
1: an annotator
2: an annotation_time


=end text

=back



=head2 pubref

=over 4



=item Description

The Kbase will include a growing body of literature supporting protein
functions, asserted phenotypes, etc.  References are encoded as 3-tuples:

     an id (often a PubMed ID)

     a URL to the paper

     a title of the paper

The URL and title are often missing (but, can usually be inferred from the pubmed ID).


=item Definition

=begin html

<pre>
a reference to a list containing 3 items:
0: (id) a string
1: (link) a string
2: (title) a string

</pre>

=end html

=begin text

a reference to a list containing 3 items:
0: (id) a string
1: (link) a string
2: (title) a string


=end text

=back



=head2 scored_fid

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: a fid
1: (score) a float

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: a fid
1: (score) a float


=end text

=back



=head2 annotations

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is an annotation
</pre>

=end html

=begin text

a reference to a list where each element is an annotation

=end text

=back



=head2 pubrefs

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a pubref
</pre>

=end html

=begin text

a reference to a list where each element is a pubref

=end text

=back



=head2 roles

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a role
</pre>

=end html

=begin text

a reference to a list where each element is a role

=end text

=back



=head2 optional

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 role_with_flag

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: a role
1: an optional

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: a role
1: an optional


=end text

=back



=head2 roles_with_flags

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a role_with_flag
</pre>

=end html

=begin text

a reference to a list where each element is a role_with_flag

=end text

=back



=head2 scored_fids

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a scored_fid
</pre>

=end html

=begin text

a reference to a list where each element is a scored_fid

=end text

=back



=head2 proteins

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a protein
</pre>

=end html

=begin text

a reference to a list where each element is a protein

=end text

=back



=head2 functions

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a function
</pre>

=end html

=begin text

a reference to a list where each element is a function

=end text

=back



=head2 taxonomic_groups

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a taxonomic_group
</pre>

=end html

=begin text

a reference to a list where each element is a taxonomic_group

=end text

=back



=head2 subsystems

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a subsystem
</pre>

=end html

=begin text

a reference to a list where each element is a subsystem

=end text

=back



=head2 contigs

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a contig
</pre>

=end html

=begin text

a reference to a list where each element is a contig

=end text

=back



=head2 md5s

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a md5
</pre>

=end html

=begin text

a reference to a list where each element is a md5

=end text

=back



=head2 genomes

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a genome
</pre>

=end html

=begin text

a reference to a list where each element is a genome

=end text

=back



=head2 pair_of_fids

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: a fid
1: a fid

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: a fid
1: a fid


=end text

=back



=head2 pairs_of_fids

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a pair_of_fids
</pre>

=end html

=begin text

a reference to a list where each element is a pair_of_fids

=end text

=back



=head2 protein_families

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a protein_family
</pre>

=end html

=begin text

a reference to a list where each element is a protein_family

=end text

=back



=head2 score

=over 4



=item Definition

=begin html

<pre>
a float
</pre>

=end html

=begin text

a float

=end text

=back



=head2 evidence

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a pair_of_fids
</pre>

=end html

=begin text

a reference to a list where each element is a pair_of_fids

=end text

=back



=head2 fids

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a fid
</pre>

=end html

=begin text

a reference to a list where each element is a fid

=end text

=back



=head2 row

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: a variant
1: a reference to a hash where the key is a role and the value is a fids

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: a variant
1: a reference to a hash where the key is a role and the value is a fids


=end text

=back



=head2 fid_function_pair

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: a fid
1: a function

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: a fid
1: a function


=end text

=back



=head2 fid_function_pairs

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a fid_function_pair
</pre>

=end html

=begin text

a reference to a list where each element is a fid_function_pair

=end text

=back



=head2 fc_protein_family

=over 4



=item Description

A functionally coupled protein family identifies a family, a score, and a function
(of the related family)


=item Definition

=begin html

<pre>
a reference to a list containing 3 items:
0: a protein_family
1: a score
2: a function

</pre>

=end html

=begin text

a reference to a list containing 3 items:
0: a protein_family
1: a score
2: a function


=end text

=back



=head2 fc_protein_families

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a fc_protein_family
</pre>

=end html

=begin text

a reference to a list where each element is a fc_protein_family

=end text

=back



=head2 allele

=over 4



=item Description

We now have a number of types and functions relating to ObservationalUnits (ous),
alleles and traits.  We think of a reference genome and a set of ous that
have measured differences (SNPs) when compared to the reference genome.
Each allele is associated with a position on a contig of the reference genome.
Prior analysis has associated traits with the alleles that impact them.
We are interested in supporting operations that locate genes in the region
of an allele (i.e., genes of the reference genome that are in a region 
containining an allele).  Similarly, we wish to locate the alleles that
impact a trait, map the alleles to regions, loacte the possibly impacted genes,
relate these to subsystems, etc.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 alleles

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is an allele
</pre>

=end html

=begin text

a reference to a list where each element is an allele

=end text

=back



=head2 trait

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 traits

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a trait
</pre>

=end html

=begin text

a reference to a list where each element is a trait

=end text

=back



=head2 ou

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 ous

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is an ou
</pre>

=end html

=begin text

a reference to a list where each element is an ou

=end text

=back



=head2 bp_loc

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: a contig
1: (position) an int

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: a contig
1: (position) an int


=end text

=back



=head2 measurement_type

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 measurement_value

=over 4



=item Definition

=begin html

<pre>
a float
</pre>

=end html

=begin text

a float

=end text

=back



=head2 aux

=over 4



=item Definition

=begin html

<pre>
an int
</pre>

=end html

=begin text

an int

=end text

=back



=head2 fields

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a string
</pre>

=end html

=begin text

a reference to a list where each element is a string

=end text

=back



=head2 complex

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 complex_with_flag

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: a complex
1: an optional

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: a complex
1: an optional


=end text

=back



=head2 complexes_with_flags

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a complex_with_flag
</pre>

=end html

=begin text

a reference to a list where each element is a complex_with_flag

=end text

=back



=head2 complexes

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a complex
</pre>

=end html

=begin text

a reference to a list where each element is a complex

=end text

=back



=head2 name

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 reaction

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 reactions

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a reaction
</pre>

=end html

=begin text

a reference to a list where each element is a reaction

=end text

=back



=head2 complex_data

=over 4



=item Description

Reactions do not connect directly to roles.  Rather, the conceptual model is that one or more roles
together form a complex.  A complex implements one or more reactions.  The actual data relating
to a complex is spread over two entities: Complex and ReactionComplex. It is convenient to be
able to offer access to the complex name, the reactions it implements, and the roles that make it up
in a single invocation.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
complex_name has a value which is a name
complex_roles has a value which is a roles_with_flags
complex_reactions has a value which is a reactions

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
complex_name has a value which is a name
complex_roles has a value which is a roles_with_flags
complex_reactions has a value which is a reactions


=end text

=back



=head2 genome_data

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
complete has a value which is an int
contigs has a value which is an int
dna_size has a value which is an int
gc_content has a value which is a float
genetic_code has a value which is an int
pegs has a value which is an int
rnas has a value which is an int
scientific_name has a value which is a string
taxonomy has a value which is a string
genome_md5 has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
complete has a value which is an int
contigs has a value which is an int
dna_size has a value which is an int
gc_content has a value which is a float
genetic_code has a value which is an int
pegs has a value which is an int
rnas has a value which is an int
scientific_name has a value which is a string
taxonomy has a value which is a string
genome_md5 has a value which is a string


=end text

=back



=head2 regulon

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 regulons

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a regulon
</pre>

=end html

=begin text

a reference to a list where each element is a regulon

=end text

=back



=head2 regulon_data

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
regulon_id has a value which is a regulon
regulon_set has a value which is a fids
tfs has a value which is a fids

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
regulon_id has a value which is a regulon
regulon_set has a value which is a fids
tfs has a value which is a fids


=end text

=back



=head2 regulons_data

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a regulon_data
</pre>

=end html

=begin text

a reference to a list where each element is a regulon_data

=end text

=back



=head2 feature_data

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
feature_id has a value which is a fid
genome_name has a value which is a string
feature_function has a value which is a string
feature_length has a value which is an int
feature_publications has a value which is a pubrefs
feature_location has a value which is a location

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
feature_id has a value which is a fid
genome_name has a value which is a string
feature_function has a value which is a string
feature_length has a value which is an int
feature_publications has a value which is a pubrefs
feature_location has a value which is a location


=end text

=back



=head2 expert

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 source

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 id

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 function_assertion

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 3 items:
0: an id
1: a function
2: a source

</pre>

=end html

=begin text

a reference to a list containing 3 items:
0: an id
1: a function
2: a source


=end text

=back



=head2 function_assertions

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a function_assertion
</pre>

=end html

=begin text

a reference to a list where each element is a function_assertion

=end text

=back



=head2 atomic_regulon

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 atomic_regulon_size

=over 4



=item Definition

=begin html

<pre>
an int
</pre>

=end html

=begin text

an int

=end text

=back



=head2 atomic_regulon_size_pair

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: an atomic_regulon
1: an atomic_regulon_size

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: an atomic_regulon
1: an atomic_regulon_size


=end text

=back



=head2 atomic_regulon_size_pairs

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is an atomic_regulon_size_pair
</pre>

=end html

=begin text

a reference to a list where each element is an atomic_regulon_size_pair

=end text

=back



=head2 atomic_regulons

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is an atomic_regulon
</pre>

=end html

=begin text

a reference to a list where each element is an atomic_regulon

=end text

=back



=head2 protein_sequence

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 dna_sequence

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 alias

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 aliases

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is an alias
</pre>

=end html

=begin text

a reference to a list where each element is an alias

=end text

=back



=head2 external_id

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 external_ids

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is an external_id
</pre>

=end html

=begin text

a reference to a list where each element is an external_id

=end text

=back



=head2 name_parameter

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 ss_var_role_tuple

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 3 items:
0: a subsystem
1: a variant
2: a role

</pre>

=end html

=begin text

a reference to a list containing 3 items:
0: a subsystem
1: a variant
2: a role


=end text

=back



=head2 ss_var_role_tuples

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a ss_var_role_tuple
</pre>

=end html

=begin text

a reference to a list where each element is a ss_var_role_tuple

=end text

=back



=head2 genome_name

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 entity_name

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 weight

=over 4



=item Definition

=begin html

<pre>
an int
</pre>

=end html

=begin text

an int

=end text

=back



=head2 field_name

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 search_hit

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: a weight
1: a reference to a hash where the key is a field_name and the value is a string

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: a weight
1: a reference to a hash where the key is a field_name and the value is a string


=end text

=back



=head2 correspondence

=over 4



=item Description

A correspondence is generated as a mapping of fids to fids.  The mapping
attempts to map a fid to another that performs the same function.  The
correspondence describes the regions that are similar, the strength of
the similarity, the number of genes in the chromosomal context that appear
to "correspond" and a score from 0 to 1 that loosely corresponds to 
confidence in the correspondence.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
to has a value which is a fid
iden has a value which is a float
ncontext has a value which is an int
b1 has a value which is an int
e1 has a value which is an int
ln1 has a value which is an int
b2 has a value which is an int
e2 has a value which is an int
ln2 has a value which is an int
score has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
to has a value which is a fid
iden has a value which is a float
ncontext has a value which is an int
b1 has a value which is an int
e1 has a value which is an int
ln1 has a value which is an int
b2 has a value which is an int
e2 has a value which is an int
ln2 has a value which is an int
score has a value which is an int


=end text

=back



=head2 sequence

=over 4



=item Description

A close_genomes is used to get a set of relatively close genomes (for
each input genome, a set of close genomes is calculated, but the
result should be viewed as quite approximate.  It is quite slow,
using similarities for a universal protein as the basis for the 
assessments.  It produces estimates of degree of similarity for
the universal proteins it samples.

Up to n genomes will be returned for each input genome.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 seq_triple

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 3 items:
0: an id
1: a comment
2: a sequence

</pre>

=end html

=begin text

a reference to a list containing 3 items:
0: an id
1: a comment
2: a sequence


=end text

=back



=head2 seq_set

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a seq_triple
</pre>

=end html

=begin text

a reference to a list where each element is a seq_triple

=end text

=back



=head2 id_set

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is an id
</pre>

=end html

=begin text

a reference to a list where each element is an id

=end text

=back



=head2 alignment

=over 4



=item Definition

=begin html

<pre>
a seq_set
</pre>

=end html

=begin text

a seq_set

=end text

=back



=head2 rep_seq_parms

=over 4



=item Description

fractions or bits


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
existing_reps has a value which is a seq_set
order has a value which is a string
alg has a value which is an int
type_sim has a value which is a string
cutoff has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
existing_reps has a value which is a seq_set
order has a value which is a string
alg has a value which is an int
type_sim has a value which is a string
cutoff has a value which is a float


=end text

=back



=head2 muscle_parms_t

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
anchors has a value which is an int
brenner has a value which is an int
cluster has a value which is an int
dimer has a value which is an int
diags has a value which is an int
diags1 has a value which is an int
diags2 has a value which is an int
le has a value which is an int
noanchors has a value which is an int
sp has a value which is an int
spn has a value which is an int
stable has a value which is an int
sv has a value which is an int
anchorspacing has a value which is a string
center has a value which is a string
cluster1 has a value which is a string
cluster2 has a value which is a string
diagbreak has a value which is a string
diaglength has a value which is a string
diagmargin has a value which is a string
distance1 has a value which is a string
distance2 has a value which is a string
gapopen has a value which is a string
log has a value which is a string
loga has a value which is a string
matrix has a value which is a string
maxhours has a value which is a string
maxiters has a value which is a string
maxmb has a value which is a string
maxtrees has a value which is a string
minbestcolscore has a value which is a string
minsmoothscore has a value which is a string
objscore has a value which is a string
refinewindow has a value which is a string
root1 has a value which is a string
root2 has a value which is a string
scorefile has a value which is a string
seqtype has a value which is a string
smoothscorecell has a value which is a string
smoothwindow has a value which is a string
spscore has a value which is a string
SUEFF has a value which is a string
usetree has a value which is a string
weight1 has a value which is a string
weight2 has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
anchors has a value which is an int
brenner has a value which is an int
cluster has a value which is an int
dimer has a value which is an int
diags has a value which is an int
diags1 has a value which is an int
diags2 has a value which is an int
le has a value which is an int
noanchors has a value which is an int
sp has a value which is an int
spn has a value which is an int
stable has a value which is an int
sv has a value which is an int
anchorspacing has a value which is a string
center has a value which is a string
cluster1 has a value which is a string
cluster2 has a value which is a string
diagbreak has a value which is a string
diaglength has a value which is a string
diagmargin has a value which is a string
distance1 has a value which is a string
distance2 has a value which is a string
gapopen has a value which is a string
log has a value which is a string
loga has a value which is a string
matrix has a value which is a string
maxhours has a value which is a string
maxiters has a value which is a string
maxmb has a value which is a string
maxtrees has a value which is a string
minbestcolscore has a value which is a string
minsmoothscore has a value which is a string
objscore has a value which is a string
refinewindow has a value which is a string
root1 has a value which is a string
root2 has a value which is a string
scorefile has a value which is a string
seqtype has a value which is a string
smoothscorecell has a value which is a string
smoothwindow has a value which is a string
spscore has a value which is a string
SUEFF has a value which is a string
usetree has a value which is a string
weight1 has a value which is a string
weight2 has a value which is a string


=end text

=back



=head2 mafft_parms_t

=over 4



=item Description

linsi | einsi | ginsi | nwnsi | nwns | fftnsi | fftns (D)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
sixmerpair has a value which is an int
amino has a value which is an int
anysymbol has a value which is an int
auto has a value which is an int
clustalout has a value which is an int
dpparttree has a value which is an int
fastapair has a value which is an int
fastaparttree has a value which is an int
fft has a value which is an int
fmodel has a value which is an int
genafpair has a value which is an int
globalpair has a value which is an int
inputorder has a value which is an int
localpair has a value which is an int
memsave has a value which is an int
nofft has a value which is an int
noscore has a value which is an int
parttree has a value which is an int
reorder has a value which is an int
treeout has a value which is an int
alg has a value which is a string
aamatrix has a value which is a string
bl has a value which is a string
ep has a value which is a string
groupsize has a value which is a string
jtt has a value which is a string
lap has a value which is a string
lep has a value which is a string
lepx has a value which is a string
LOP has a value which is a string
LEXP has a value which is a string
maxiterate has a value which is a string
op has a value which is a string
partsize has a value which is a string
retree has a value which is a string
thread has a value which is a string
tm has a value which is a string
weighti has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
sixmerpair has a value which is an int
amino has a value which is an int
anysymbol has a value which is an int
auto has a value which is an int
clustalout has a value which is an int
dpparttree has a value which is an int
fastapair has a value which is an int
fastaparttree has a value which is an int
fft has a value which is an int
fmodel has a value which is an int
genafpair has a value which is an int
globalpair has a value which is an int
inputorder has a value which is an int
localpair has a value which is an int
memsave has a value which is an int
nofft has a value which is an int
noscore has a value which is an int
parttree has a value which is an int
reorder has a value which is an int
treeout has a value which is an int
alg has a value which is a string
aamatrix has a value which is a string
bl has a value which is a string
ep has a value which is a string
groupsize has a value which is a string
jtt has a value which is a string
lap has a value which is a string
lep has a value which is a string
lepx has a value which is a string
LOP has a value which is a string
LEXP has a value which is a string
maxiterate has a value which is a string
op has a value which is a string
partsize has a value which is a string
retree has a value which is a string
thread has a value which is a string
tm has a value which is a string
weighti has a value which is a string


=end text

=back



=head2 align_seq_parms

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
muscle_parms has a value which is a muscle_parms_t
mafft_parms has a value which is a mafft_parms_t
tool has a value which is a string
align_ends_with_clustal has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
muscle_parms has a value which is a muscle_parms_t
mafft_parms has a value which is a mafft_parms_t
tool has a value which is a string
align_ends_with_clustal has a value which is an int


=end text

=back



=head2 newick_tree

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 build_tree_parms

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
bootstrap has a value which is a string
model has a value which is a string
nclasses has a value which is a string
nproc has a value which is a string
rate has a value which is a string
search has a value which is a string
tool has a value which is a string
tool_params has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
bootstrap has a value which is a string
model has a value which is a string
nclasses has a value which is a string
nproc has a value which is a string
rate has a value which is a string
search has a value which is a string
tool has a value which is a string
tool_params has a value which is a string


=end text

=back



=head2 aln_id

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 tree_id

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 entity_name

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 entity_names

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is an entity_name
</pre>

=end html

=begin text

a reference to a list where each element is an entity_name

=end text

=back



=head2 relationship_name

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 relationship_names

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a relationship_name
</pre>

=end html

=begin text

a reference to a list where each element is a relationship_name

=end text

=back



=head2 field_name

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 boolean

=over 4



=item Definition

=begin html

<pre>
an int
</pre>

=end html

=begin text

an int

=end text

=back



=head2 field_info

=over 4



=item Description

Information about a field in the database. Includes the name of the 
field, any associated formatted notes, and the type.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
name has a value which is a string
notes has a value which is a string
type has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
name has a value which is a string
notes has a value which is a string
type has a value which is a string


=end text

=back



=head2 entity_info

=over 4



=item Description

Information about an entity in the database, including the entity name
and its relationships and fields.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
name has a value which is a string
relationships has a value which is a reference to a list where each element is a reference to a list containing 2 items:
0: (rel_name) a string
1: (entity_name) a string

fields has a value which is a reference to a hash where the key is a field_name and the value is a field_info

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
name has a value which is a string
relationships has a value which is a reference to a list where each element is a reference to a list containing 2 items:
0: (rel_name) a string
1: (entity_name) a string

fields has a value which is a reference to a hash where the key is a field_name and the value is a field_info


=end text

=back



=head2 relationship_info

=over 4



=item Description

Information about a relationship in the database, including the 
entities it relates, its name and converse name, and its fields.
The real_table boolean designates that the relationship is a real
table in the database rather than the converse relationship to that
table.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
name has a value which is a string
from_entity has a value which is a string
to_entity has a value which is a string
real_table has a value which is a boolean
converse has a value which is a string
fields has a value which is a reference to a hash where the key is a field_name and the value is a field_info

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
name has a value which is a string
from_entity has a value which is a string
to_entity has a value which is a string
real_table has a value which is a boolean
converse has a value which is a string
fields has a value which is a reference to a hash where the key is a field_name and the value is a field_info


=end text

=back



=head2 diamond

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 countVector

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 rectangle

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 fields_Alignment

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
n_rows has a value which is an int
n_cols has a value which is an int
status has a value which is a string
is_concatenation has a value which is an int
sequence_type has a value which is a string
timestamp has a value which is a string
method has a value which is a string
parameters has a value which is a string
protocol has a value which is a string
source_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
n_rows has a value which is an int
n_cols has a value which is an int
status has a value which is a string
is_concatenation has a value which is an int
sequence_type has a value which is a string
timestamp has a value which is a string
method has a value which is a string
parameters has a value which is a string
protocol has a value which is a string
source_id has a value which is a string


=end text

=back



=head2 fields_AlignmentAttribute

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string


=end text

=back



=head2 fields_AlignmentRow

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
row_number has a value which is an int
row_id has a value which is a string
row_description has a value which is a string
n_components has a value which is an int
beg_pos_aln has a value which is an int
end_pos_aln has a value which is an int
md5_of_ungapped_sequence has a value which is a string
sequence has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
row_number has a value which is an int
row_id has a value which is a string
row_description has a value which is a string
n_components has a value which is an int
beg_pos_aln has a value which is an int
end_pos_aln has a value which is an int
md5_of_ungapped_sequence has a value which is a string
sequence has a value which is a string


=end text

=back



=head2 fields_AlleleFrequency

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string
position has a value which is an int
minor_AF has a value which is a float
minor_allele has a value which is a string
major_AF has a value which is a float
major_allele has a value which is a string
obs_unit_count has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string
position has a value which is an int
minor_AF has a value which is a float
minor_allele has a value which is a string
major_AF has a value which is a float
major_allele has a value which is a string
obs_unit_count has a value which is an int


=end text

=back



=head2 fields_Annotation

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
annotator has a value which is a string
comment has a value which is a string
annotation_time has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
annotator has a value which is a string
comment has a value which is a string
annotation_time has a value which is a string


=end text

=back



=head2 fields_Assay

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string
assay_type has a value which is a string
assay_type_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string
assay_type has a value which is a string
assay_type_id has a value which is a string


=end text

=back



=head2 fields_Association

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
description has a value which is a string
directional has a value which is an int
confidence has a value which is a float
url has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
description has a value which is a string
directional has a value which is an int
confidence has a value which is a float
url has a value which is a string


=end text

=back



=head2 fields_AssociationDataset

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
description has a value which is a string
data_source has a value which is a string
url has a value which is a string
association_type has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
description has a value which is a string
data_source has a value which is a string
url has a value which is a string
association_type has a value which is a string


=end text

=back



=head2 fields_AssociationDetectionType

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
description has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
description has a value which is a string


=end text

=back



=head2 fields_AtomicRegulon

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string


=end text

=back



=head2 fields_Attribute

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
description has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
description has a value which is a string


=end text

=back



=head2 fields_Biomass

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
mod_date has a value which is a string
name has a value which is a reference to a list where each element is a string
dna has a value which is a float
protein has a value which is a float
cell_wall has a value which is a float
lipid has a value which is a float
cofactor has a value which is a float
energy has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
mod_date has a value which is a string
name has a value which is a reference to a list where each element is a string
dna has a value which is a float
protein has a value which is a float
cell_wall has a value which is a float
lipid has a value which is a float
cofactor has a value which is a float
energy has a value which is a float


=end text

=back



=head2 fields_CodonUsage

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
frequencies has a value which is a string
genetic_code has a value which is an int
type has a value which is a string
subtype has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
frequencies has a value which is a string
genetic_code has a value which is an int
type has a value which is a string
subtype has a value which is a string


=end text

=back



=head2 fields_Complex

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a reference to a list where each element is a string
source_id has a value which is a string
mod_date has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a reference to a list where each element is a string
source_id has a value which is a string
mod_date has a value which is a string


=end text

=back



=head2 fields_Compound

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
label has a value which is a string
abbr has a value which is a string
source_id has a value which is a string
ubiquitous has a value which is an int
mod_date has a value which is a string
mass has a value which is a float
formula has a value which is a string
charge has a value which is a float
deltaG has a value which is a float
deltaG_error has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
label has a value which is a string
abbr has a value which is a string
source_id has a value which is a string
ubiquitous has a value which is an int
mod_date has a value which is a string
mass has a value which is a float
formula has a value which is a string
charge has a value which is a float
deltaG has a value which is a float
deltaG_error has a value which is a float


=end text

=back



=head2 fields_CompoundInstance

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
charge has a value which is a float
formula has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
charge has a value which is a float
formula has a value which is a string


=end text

=back



=head2 fields_ConservedDomainModel

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
accession has a value which is a string
short_name has a value which is a string
description has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
accession has a value which is a string
short_name has a value which is a string
description has a value which is a string


=end text

=back



=head2 fields_Contig

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string


=end text

=back



=head2 fields_ContigChunk

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
sequence has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
sequence has a value which is a string


=end text

=back



=head2 fields_ContigSequence

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
length has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
length has a value which is an int


=end text

=back



=head2 fields_CoregulatedSet

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string
binding_location has a value which is a reference to a list where each element is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string
binding_location has a value which is a reference to a list where each element is an int


=end text

=back



=head2 fields_Diagram

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
content has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
content has a value which is a reference to a list where each element is a string


=end text

=back



=head2 fields_EcNumber

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
obsolete has a value which is an int
replacedby has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
obsolete has a value which is an int
replacedby has a value which is a string


=end text

=back



=head2 fields_Effector

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
effector_class has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
effector_class has a value which is a string


=end text

=back



=head2 fields_Environment

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
temperature has a value which is a float
description has a value which is a string
oxygenConcentration has a value which is a float
pH has a value which is a float
source_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
temperature has a value which is a float
description has a value which is a string
oxygenConcentration has a value which is a float
pH has a value which is a float
source_id has a value which is a string


=end text

=back



=head2 fields_Experiment

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
source has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
source has a value which is a string


=end text

=back



=head2 fields_ExperimentMeta

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
title has a value which is a string
description has a value which is a string
source_id has a value which is a string
startDate has a value which is a string
comments has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
title has a value which is a string
description has a value which is a string
source_id has a value which is a string
startDate has a value which is a string
comments has a value which is a string


=end text

=back



=head2 fields_ExperimentalUnit

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string


=end text

=back



=head2 fields_ExperimentalUnitGroup

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string
name has a value which is a string
comments has a value which is a string
groupType has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string
name has a value which is a string
comments has a value which is a string
groupType has a value which is a string


=end text

=back



=head2 fields_Family

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
type has a value which is a string
release has a value which is a string
family_function has a value which is a reference to a list where each element is a string
alignment has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
type has a value which is a string
release has a value which is a string
family_function has a value which is a reference to a list where each element is a string
alignment has a value which is a reference to a list where each element is a string


=end text

=back



=head2 fields_Feature

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
feature_type has a value which is a string
source_id has a value which is a string
sequence_length has a value which is an int
function has a value which is a string
alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
feature_type has a value which is a string
source_id has a value which is a string
sequence_length has a value which is an int
function has a value which is a string
alias has a value which is a reference to a list where each element is a string


=end text

=back



=head2 fields_Genome

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
pegs has a value which is an int
rnas has a value which is an int
scientific_name has a value which is a string
complete has a value which is an int
prokaryotic has a value which is an int
dna_size has a value which is an int
contigs has a value which is an int
domain has a value which is a string
genetic_code has a value which is an int
gc_content has a value which is a float
phenotype has a value which is a reference to a list where each element is a string
md5 has a value which is a string
source_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
pegs has a value which is an int
rnas has a value which is an int
scientific_name has a value which is a string
complete has a value which is an int
prokaryotic has a value which is an int
dna_size has a value which is an int
contigs has a value which is an int
domain has a value which is a string
genetic_code has a value which is an int
gc_content has a value which is a float
phenotype has a value which is a reference to a list where each element is a string
md5 has a value which is a string
source_id has a value which is a string


=end text

=back



=head2 fields_Locality

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
source_name has a value which is a string
city has a value which is a string
state has a value which is a string
country has a value which is a string
origcty has a value which is a string
elevation has a value which is an int
latitude has a value which is an int
longitude has a value which is an int
lo_accession has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
source_name has a value which is a string
city has a value which is a string
state has a value which is a string
country has a value which is a string
origcty has a value which is a string
elevation has a value which is an int
latitude has a value which is an int
longitude has a value which is an int
lo_accession has a value which is a string


=end text

=back



=head2 fields_LocalizedCompound

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string


=end text

=back



=head2 fields_Location

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
mod_date has a value which is a string
name has a value which is a string
source_id has a value which is a string
abbr has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
mod_date has a value which is a string
name has a value which is a string
source_id has a value which is a string
abbr has a value which is an int


=end text

=back



=head2 fields_LocationInstance

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
index has a value which is an int
label has a value which is a reference to a list where each element is a string
pH has a value which is a float
potential has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
index has a value which is an int
label has a value which is a reference to a list where each element is a string
pH has a value which is a float
potential has a value which is a float


=end text

=back



=head2 fields_Measurement

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string
value has a value which is a float
mean has a value which is a float
median has a value which is a float
stddev has a value which is a float
N has a value which is an int
p_value has a value which is a float
Z_score has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string
value has a value which is a float
mean has a value which is a float
median has a value which is a float
stddev has a value which is a float
N has a value which is an int
p_value has a value which is a float
Z_score has a value which is a float


=end text

=back



=head2 fields_MeasurementDescription

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
description has a value which is a string
unitOfMeasure has a value which is a string
category has a value which is a string
source_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
description has a value which is a string
unitOfMeasure has a value which is a string
category has a value which is a string
source_id has a value which is a string


=end text

=back



=head2 fields_Media

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
mod_date has a value which is a string
name has a value which is a string
is_minimal has a value which is a string
source_id has a value which is a string
type has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
mod_date has a value which is a string
name has a value which is a string
is_minimal has a value which is a string
source_id has a value which is a string
type has a value which is a string


=end text

=back



=head2 fields_Model

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
mod_date has a value which is a string
name has a value which is a string
version has a value which is an int
type has a value which is a string
status has a value which is a string
reaction_count has a value which is an int
compound_count has a value which is an int
annotation_count has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
mod_date has a value which is a string
name has a value which is a string
version has a value which is an int
type has a value which is a string
status has a value which is a string
reaction_count has a value which is an int
compound_count has a value which is an int
annotation_count has a value which is an int


=end text

=back



=head2 fields_OTU

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string


=end text

=back



=head2 fields_ObservationalUnit

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
source_name has a value which is a string
source_name2 has a value which is a reference to a list where each element is a string
plant_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
source_name has a value which is a string
source_name2 has a value which is a reference to a list where each element is a string
plant_id has a value which is a string


=end text

=back



=head2 fields_Ontology

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
id has a value which is a string
name has a value which is a string
definition has a value which is a string
ontologySource has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
id has a value which is a string
name has a value which is a string
definition has a value which is a string
ontologySource has a value which is a string


=end text

=back



=head2 fields_Operon

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string


=end text

=back



=head2 fields_PairSet

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
score has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
score has a value which is an int


=end text

=back



=head2 fields_Pairing

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string


=end text

=back



=head2 fields_Parameter

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string


=end text

=back



=head2 fields_Person

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
firstName has a value which is a string
lastName has a value which is a string
contactEmail has a value which is a string
institution has a value which is a string
source_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
firstName has a value which is a string
lastName has a value which is a string
contactEmail has a value which is a string
institution has a value which is a string
source_id has a value which is a string


=end text

=back



=head2 fields_Platform

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
title has a value which is a string
externalSourceId has a value which is a string
technology has a value which is a string
type has a value which is a string
source_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
title has a value which is a string
externalSourceId has a value which is a string
technology has a value which is a string
type has a value which is a string
source_id has a value which is a string


=end text

=back



=head2 fields_ProbeSet

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string


=end text

=back



=head2 fields_ProteinSequence

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
sequence has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
sequence has a value which is a string


=end text

=back



=head2 fields_Protocol

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
description has a value which is a string
source_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
description has a value which is a string
source_id has a value which is a string


=end text

=back



=head2 fields_Publication

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
title has a value which is a string
link has a value which is a string
pubdate has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
title has a value which is a string
link has a value which is a string
pubdate has a value which is a string


=end text

=back



=head2 fields_Reaction

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
mod_date has a value which is a string
name has a value which is a string
source_id has a value which is a string
abbr has a value which is a string
direction has a value which is a string
deltaG has a value which is a float
deltaG_error has a value which is a float
thermodynamic_reversibility has a value which is a string
default_protons has a value which is a float
status has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
mod_date has a value which is a string
name has a value which is a string
source_id has a value which is a string
abbr has a value which is a string
direction has a value which is a string
deltaG has a value which is a float
deltaG_error has a value which is a float
thermodynamic_reversibility has a value which is a string
default_protons has a value which is a float
status has a value which is a string


=end text

=back



=head2 fields_ReactionInstance

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
direction has a value which is a string
protons has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
direction has a value which is a string
protons has a value which is a float


=end text

=back



=head2 fields_Regulator

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
rfam_id has a value which is a string
tf_family has a value which is a string
type has a value which is a string
taxonomy has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
rfam_id has a value which is a string
tf_family has a value which is a string
type has a value which is a string
taxonomy has a value which is a string


=end text

=back



=head2 fields_Regulog

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
description has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
description has a value which is a string


=end text

=back



=head2 fields_RegulogCollection

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
description has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
description has a value which is a string


=end text

=back



=head2 fields_Regulome

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
description has a value which is a string
creation_date has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
description has a value which is a string
creation_date has a value which is a string


=end text

=back



=head2 fields_Regulon

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
description has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
description has a value which is a string


=end text

=back



=head2 fields_ReplicateGroup

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string


=end text

=back



=head2 fields_Role

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
hypothetical has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
hypothetical has a value which is an int


=end text

=back



=head2 fields_SSCell

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string


=end text

=back



=head2 fields_SSRow

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
curated has a value which is an int
region has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
curated has a value which is an int
region has a value which is a string


=end text

=back



=head2 fields_Sample

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
title has a value which is a string
dataSource has a value which is a string
externalSourceId has a value which is a string
description has a value which is a string
molecule has a value which is a string
type has a value which is a string
kbaseSubmissionDate has a value which is a string
externalSourceDate has a value which is a string
custom has a value which is a string
originalLog2Median has a value which is a float
source_id has a value which is a string
dataQualityLevel has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
title has a value which is a string
dataSource has a value which is a string
externalSourceId has a value which is a string
description has a value which is a string
molecule has a value which is a string
type has a value which is a string
kbaseSubmissionDate has a value which is a string
externalSourceDate has a value which is a string
custom has a value which is a string
originalLog2Median has a value which is a float
source_id has a value which is a string
dataQualityLevel has a value which is an int


=end text

=back



=head2 fields_SampleAnnotation

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
annotationDate has a value which is a string
source_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
annotationDate has a value which is a string
source_id has a value which is a string


=end text

=back



=head2 fields_Scenario

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
common_name has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
common_name has a value which is a string


=end text

=back



=head2 fields_Series

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
title has a value which is a string
summary has a value which is a string
design has a value which is a string
externalSourceId has a value which is a string
kbaseSubmissionDate has a value which is a string
externalSourceDate has a value which is a string
source_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
title has a value which is a string
summary has a value which is a string
design has a value which is a string
externalSourceId has a value which is a string
kbaseSubmissionDate has a value which is a string
externalSourceDate has a value which is a string
source_id has a value which is a string


=end text

=back



=head2 fields_Source

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
url has a value which is a string
description has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
url has a value which is a string
description has a value which is a string


=end text

=back



=head2 fields_Strain

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
description has a value which is a string
source_id has a value which is a string
aggregateData has a value which is a string
wildtype has a value which is a string
referenceStrain has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
name has a value which is a string
description has a value which is a string
source_id has a value which is a string
aggregateData has a value which is a string
wildtype has a value which is a string
referenceStrain has a value which is a string


=end text

=back



=head2 fields_StudyExperiment

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
source_name has a value which is a string
design has a value which is a string
originator has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
source_name has a value which is a string
design has a value which is a string
originator has a value which is a string


=end text

=back



=head2 fields_Subsystem

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
version has a value which is an int
curator has a value which is a string
notes has a value which is a string
description has a value which is a string
usable has a value which is an int
private has a value which is an int
cluster_based has a value which is an int
experimental has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
version has a value which is an int
curator has a value which is a string
notes has a value which is a string
description has a value which is a string
usable has a value which is an int
private has a value which is an int
cluster_based has a value which is an int
experimental has a value which is an int


=end text

=back



=head2 fields_SubsystemClass

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string


=end text

=back



=head2 fields_TaxonomicGrouping

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
domain has a value which is an int
hidden has a value which is an int
scientific_name has a value which is a string
alias has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
domain has a value which is an int
hidden has a value which is an int
scientific_name has a value which is a string
alias has a value which is a reference to a list where each element is a string


=end text

=back



=head2 fields_TimeSeries

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string
name has a value which is a string
comments has a value which is a string
timeUnits has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
source_id has a value which is a string
name has a value which is a string
comments has a value which is a string
timeUnits has a value which is a string


=end text

=back



=head2 fields_Trait

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
trait_name has a value which is a string
unit_of_measure has a value which is a string
TO_ID has a value which is a string
protocol has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
trait_name has a value which is a string
unit_of_measure has a value which is a string
TO_ID has a value which is a string
protocol has a value which is a string


=end text

=back



=head2 fields_Tree

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
status has a value which is a string
data_type has a value which is a string
timestamp has a value which is a string
method has a value which is a string
parameters has a value which is a string
protocol has a value which is a string
source_id has a value which is a string
newick has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
status has a value which is a string
data_type has a value which is a string
timestamp has a value which is a string
method has a value which is a string
parameters has a value which is a string
protocol has a value which is a string
source_id has a value which is a string
newick has a value which is a string


=end text

=back



=head2 fields_TreeAttribute

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string


=end text

=back



=head2 fields_TreeNodeAttribute

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string


=end text

=back



=head2 fields_Variant

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a string
role_rule has a value which is a reference to a list where each element is a string
code has a value which is a string
type has a value which is a string
comment has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a string
role_rule has a value which is a reference to a list where each element is a string
code has a value which is a string
type has a value which is a string
comment has a value which is a string


=end text

=back



=head2 fields_AffectsLevelOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
level has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
level has a value which is an int


=end text

=back



=head2 fields_Aligned

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_AssertsFunctionFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
function has a value which is a string
external_id has a value which is a string
organism has a value which is a string
gi_number has a value which is an int
release_date has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
function has a value which is a string
external_id has a value which is a string
organism has a value which is a string
gi_number has a value which is an int
release_date has a value which is a string


=end text

=back



=head2 fields_AssociationFeature

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
stoichiometry has a value which is an int
strength has a value which is a float
rank has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
stoichiometry has a value which is an int
strength has a value which is a float
rank has a value which is an int


=end text

=back



=head2 fields_CompoundMeasuredBy

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_Concerns

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_ConsistsOfCompounds

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
molar_ratio has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
molar_ratio has a value which is a float


=end text

=back



=head2 fields_Contains

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_ContainsAlignedDNA

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
index_in_concatenation has a value which is an int
beg_pos_in_parent has a value which is an int
end_pos_in_parent has a value which is an int
parent_seq_len has a value which is an int
beg_pos_aln has a value which is an int
end_pos_aln has a value which is an int
kb_feature_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
index_in_concatenation has a value which is an int
beg_pos_in_parent has a value which is an int
end_pos_in_parent has a value which is an int
parent_seq_len has a value which is an int
beg_pos_aln has a value which is an int
end_pos_aln has a value which is an int
kb_feature_id has a value which is a string


=end text

=back



=head2 fields_ContainsAlignedProtein

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
index_in_concatenation has a value which is an int
beg_pos_in_parent has a value which is an int
end_pos_in_parent has a value which is an int
parent_seq_len has a value which is an int
beg_pos_aln has a value which is an int
end_pos_aln has a value which is an int
kb_feature_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
index_in_concatenation has a value which is an int
beg_pos_in_parent has a value which is an int
end_pos_in_parent has a value which is an int
parent_seq_len has a value which is an int
beg_pos_aln has a value which is an int
end_pos_aln has a value which is an int
kb_feature_id has a value which is a string


=end text

=back



=head2 fields_ContainsExperimentalUnit

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
location has a value which is a string
groupMeta has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
location has a value which is a string
groupMeta has a value which is a string


=end text

=back



=head2 fields_Controls

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_DefaultControlSample

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_Describes

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_DescribesAlignment

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
value has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
value has a value which is a string


=end text

=back



=head2 fields_DescribesMeasurement

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_DescribesTree

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
value has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
value has a value which is a string


=end text

=back



=head2 fields_DescribesTreeNode

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
value has a value which is a string
node_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
value has a value which is a string
node_id has a value which is a string


=end text

=back



=head2 fields_DetectedWithMethod

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_Displays

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
location has a value which is a rectangle

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
location has a value which is a rectangle


=end text

=back



=head2 fields_Encompasses

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_EvaluatedIn

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_FeatureIsTranscriptionFactorFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_FeatureMeasuredBy

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_Formulated

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_GeneratedLevelsFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
level_vector has a value which is a countVector

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
level_vector has a value which is a countVector


=end text

=back



=head2 fields_GenomeParentOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasAliasAssertedFrom

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
alias has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
alias has a value which is a string


=end text

=back



=head2 fields_HasCompoundAliasFrom

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
alias has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
alias has a value which is a string


=end text

=back



=head2 fields_HasEffector

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasExperimentalUnit

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasExpressionSample

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasGenomes

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasIndicatedSignalFrom

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
rma_value has a value which is a float
level has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
rma_value has a value which is a float
level has a value which is an int


=end text

=back



=head2 fields_HasKnockoutIn

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasMeasurement

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasMember

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasParameter

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
value has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
value has a value which is a string


=end text

=back



=head2 fields_HasParticipant

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is an int
to_link has a value which is a string
type has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is an int
to_link has a value which is a string
type has a value which is an int


=end text

=back



=head2 fields_HasPresenceOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
concentration has a value which is a float
minimum_flux has a value which is a float
maximum_flux has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
concentration has a value which is a float
minimum_flux has a value which is a float
maximum_flux has a value which is a float


=end text

=back



=head2 fields_HasProteinMember

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
source_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
source_id has a value which is a string


=end text

=back



=head2 fields_HasReactionAliasFrom

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
alias has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
alias has a value which is a string


=end text

=back



=head2 fields_HasRegulogs

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasRepresentativeOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasRequirementOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasResultsIn

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
sequence has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
sequence has a value which is an int


=end text

=back



=head2 fields_HasSection

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasStep

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasTrait

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
value has a value which is a float
statistic_type has a value which is a string
measure_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
value has a value which is a float
statistic_type has a value which is a string
measure_id has a value which is a string


=end text

=back



=head2 fields_HasUnits

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasUsage

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_HasValueFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
value has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
value has a value which is a string


=end text

=back



=head2 fields_HasVariationIn

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
position has a value which is an int
len has a value which is an int
data has a value which is a string
data2 has a value which is a string
quality has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
position has a value which is an int
len has a value which is an int
data has a value which is a string
data2 has a value which is a string
quality has a value which is a float


=end text

=back



=head2 fields_Impacts

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
source_name has a value which is a string
rank has a value which is an int
pvalue has a value which is a float
position has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
source_name has a value which is a string
rank has a value which is an int
pvalue has a value which is a float
position has a value which is an int


=end text

=back



=head2 fields_ImplementsReaction

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_Includes

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
sequence has a value which is an int
abbreviation has a value which is a string
auxiliary has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
sequence has a value which is an int
abbreviation has a value which is a string
auxiliary has a value which is an int


=end text

=back



=head2 fields_IncludesAdditionalCompounds

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
concentration has a value which is a float
units has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
concentration has a value which is a float
units has a value which is a string


=end text

=back



=head2 fields_IncludesAlignmentRow

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IncludesPart

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IndicatedLevelsFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
level_vector has a value which is a countVector

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
level_vector has a value which is a countVector


=end text

=back



=head2 fields_Involves

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
coefficient has a value which is a float
cofactor has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
coefficient has a value which is a float
cofactor has a value which is an int


=end text

=back



=head2 fields_IsAnnotatedBy

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsAssayOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsClassFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsCollectionOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
representative has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
representative has a value which is an int


=end text

=back



=head2 fields_IsComposedOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsComprisedOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
coefficient has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
coefficient has a value which is a float


=end text

=back



=head2 fields_IsConfiguredBy

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsConservedDomainModelFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is an int
to_link has a value which is a string
percent_identity has a value which is a float
alignment_length has a value which is an int
mismatches has a value which is an int
gap_openings has a value which is an int
protein_start has a value which is an int
protein_end has a value which is an int
domain_start has a value which is an int
domain_end has a value which is an int
e_value has a value which is a float
bit_score has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is an int
to_link has a value which is a string
percent_identity has a value which is a float
alignment_length has a value which is an int
mismatches has a value which is an int
gap_openings has a value which is an int
protein_start has a value which is an int
protein_end has a value which is an int
domain_start has a value which is an int
domain_end has a value which is an int
e_value has a value which is a float
bit_score has a value which is a float


=end text

=back



=head2 fields_IsConsistentWith

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsContextOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsCoregulatedWith

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
coefficient has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
coefficient has a value which is a float


=end text

=back



=head2 fields_IsCoupledTo

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
co_occurrence_evidence has a value which is an int
co_expression_evidence has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
co_occurrence_evidence has a value which is an int
co_expression_evidence has a value which is an int


=end text

=back



=head2 fields_IsDatasetFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsDeterminedBy

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
inverted has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
inverted has a value which is an int


=end text

=back



=head2 fields_IsDividedInto

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsExecutedAs

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsExemplarOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsFamilyFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsFormedOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsFunctionalIn

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsGroupFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is an int
to_link has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is an int
to_link has a value which is an int


=end text

=back



=head2 fields_IsGroupingOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsImplementedBy

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsInOperon

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
rank has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
rank has a value which is an int


=end text

=back



=head2 fields_IsInPair

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsInstantiatedBy

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsLocatedIn

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
ordinal has a value which is an int
begin has a value which is an int
len has a value which is an int
dir has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
ordinal has a value which is an int
begin has a value which is an int
len has a value which is an int
dir has a value which is a string


=end text

=back



=head2 fields_IsMeasurementMethodOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsModeledBy

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsModifiedToBuildAlignment

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
modification_type has a value which is a string
modification_value has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
modification_type has a value which is a string
modification_value has a value which is a string


=end text

=back



=head2 fields_IsModifiedToBuildTree

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
modification_type has a value which is a string
modification_value has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
modification_type has a value which is a string
modification_value has a value which is a string


=end text

=back



=head2 fields_IsOwnerOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsParticipatingAt

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsProteinFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsReagentIn

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
coefficient has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
coefficient has a value which is a float


=end text

=back



=head2 fields_IsRealLocationOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsReferencedBy

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsRegulatedIn

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsRegulatorFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsRegulatorForRegulon

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsRegulatorySiteFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsRelevantFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsRepresentedBy

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is an int
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is an int
to_link has a value which is a string


=end text

=back



=head2 fields_IsRoleOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsRowOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsSequenceOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsSourceForAssociationDataset

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsSubInstanceOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is an int


=end text

=back



=head2 fields_IsSummarizedBy

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
position has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
position has a value which is an int


=end text

=back



=head2 fields_IsSuperclassOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_IsTaxonomyOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is an int
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is an int
to_link has a value which is a string


=end text

=back



=head2 fields_IsTerminusFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is an int
group_number has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is an int
group_number has a value which is an int


=end text

=back



=head2 fields_IsTriggeredBy

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
optional has a value which is an int
type has a value which is a string
triggering has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
optional has a value which is an int
type has a value which is a string
triggering has a value which is an int


=end text

=back



=head2 fields_IsUsedToBuildTree

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_Manages

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_OntologyForSample

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_OperatesIn

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_OrdersExperimentalUnit

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
time has a value which is a float
timeMeta has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
time has a value which is a float
timeMeta has a value which is a string


=end text

=back



=head2 fields_Overlaps

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is an int
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is an int
to_link has a value which is a string


=end text

=back



=head2 fields_ParticipatesAs

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_PerformedExperiment

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
role has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
role has a value which is a string


=end text

=back



=head2 fields_PersonAnnotatedSample

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_PlatformWithSamples

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_ProducedResultsFor

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_ProtocolForSample

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_Provided

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_PublishedAssociation

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_PublishedExperiment

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_PublishedProtocol

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_RegulogHasRegulon

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_RegulomeHasGenome

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_RegulomeHasRegulon

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_RegulomeSource

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_RegulonHasOperon

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_SampleAveragedFrom

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_SampleContactPerson

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_SampleHasAnnotations

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_SampleInSeries

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_SampleMeasurements

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_SamplesInReplicateGroup

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_SeriesPublishedIn

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_Shows

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
location has a value which is a rectangle

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
location has a value which is a rectangle


=end text

=back



=head2 fields_StrainParentOf

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_StrainWithPlatforms

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_StrainWithSample

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_Submitted

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_SupersedesAlignment

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
successor_type has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
successor_type has a value which is a string


=end text

=back



=head2 fields_SupersedesTree

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
successor_type has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string
successor_type has a value which is a string


=end text

=back



=head2 fields_Treed

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_UsedIn

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_Uses

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=head2 fields_UsesCodons

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
from_link has a value which is a string
to_link has a value which is a string


=end text

=back



=cut

1;
