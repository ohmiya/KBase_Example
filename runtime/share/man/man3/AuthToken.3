.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio-KBase-Auth::lib::Bio::KBase::AuthToken 3"
.TH Bio-KBase-Auth::lib::Bio::KBase::AuthToken 3 "2015-09-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Bio::KBase::AuthToken"
.IX Header "Bio::KBase::AuthToken"
Token object for Globus Online/Globus Nexus tokens. For general information about Globus Nexus service see:
http://globusonline.github.com/nexus\-docs/api.html
.SS "Examples"
.IX Subsection "Examples"
.Vb 2
\&   # Acquiring a new token when you have username/password credentials
\&   my $token = Bio::KBase::AuthToken\->new( \*(Aquser_id\*(Aq => \*(Aqmrbig\*(Aq, \*(Aqpassword\*(Aq => \*(AqbigP@SSword\*(Aq);
\&
\&   # or if you have an SSH private key for RSA authentication
\&   my $token2 = Bio::KBase::AuthToken\->new( \*(Aquser_id\*(Aq => \*(Aqmrbig\*(Aq, \*(Aqclient_secret\*(Aq => $rsakey);
\&
\&   # or if you have an unencrypted token in the file $keyfile, you can use
\&   my $token3 = Bio::KBase::AuthToken\->new( \*(Aquser_id\*(Aq => \*(Aqmrbig\*(Aq, \*(Aqkeyfile\*(Aq => $keyfile);
\&
\&   # or if you have a token in the file $keyfile, protected by passphrase "testing" 
\&   my $token3 = Bio::KBase::AuthToken\->new( \*(Aquser_id\*(Aq => \*(Aqmrbig\*(Aq, \*(Aqkeyfile\*(Aq => $keyfile,
\&                                            \*(Aqkeyfile_passphrase\*(Aq => \*(Aqtesting\*(Aq);
\&
\&   # If you have a token in the shell environment variable $KB_AUTH_TOKEN you can
\&   # just instantiate an object with no parameters and it will use that as if it
\&   # were passed in as a token => %ENV{ KB_AUTH_TOKEN } among the params. This
\&   # will also work if there are no legit combinations of credential information
\&   # passed in
\&   my $tok = Bio::KBase::AuthToken\->new( token => \*(Aqvery long token string\*(Aq);
\&   # is the same as
\&   $ENV{ \*(AqKB_AUTH_TOKEN\*(Aq} = \*(Aqvery long token string\*(Aq;
\&   my $tok = Bio::KBase::AuthToken\->new()
\&   
\&   # any parameters for a credential/login that can be passed in to the new() method can
\&   # be put in the [authentication] section of the INI file specified in
\&   # $Bio::KBase::Auth::ConfPath ( defaults to ~/.kbase_config ) will be used to
\&   # initialize the object unless the ignore_kbase_config is set to a true value in the
\&   # call to new()
\&   # 
\&   # This is triggered by not providing any parameters to the new() method and not
\&   # having a $ENV{ KB_AUTH_TOKEN } defined.
\&   #
\&   # if ~/.kbase_config contains:
\&   # [authentication]
\&   # user_id=figaro
\&   # password=mamamia_mamamia
\&   #
\&   # Then the constructor will try to acquire a token with the user_id and password
\&   # settings provided.
\&   # Currently this library recognizes user_id, token,client_secret,keyfile,
\&   #           keyfile_passphrase,password
\&   #
\&   # To login as jqpublic with an ssh key in ~jqpublic/.ssh/id_kbase that has the passphrase
\&   # "MostlySecret" you can set this in the .kbase_config file:
\&   # [authentication]
\&   # user_id=jqpublic
\&   # keyfile=/Users/jqpublic/.ssh/id_kbase
\&   # keyfile_passphrase=MostlySecret
\&   # 
\&   # and then execute the following
\&   my $token4 = Bio::KBase::AuthToken\->new();
\&
\&   # To disable this and just return an empty token object user
\&   my $token5 = Bio::KBase::AuthToken\->new( ignore_kbase_config => 1 );
\&
\&   # If you have a token in $tok, and wish to check if it is valid
\&   my $token3 = Bio::KBase::AuthToken\->new( \*(Aqtoken\*(Aq => $tok);
\&   if ($token3\->validate()) {
\&       # token is legit
\&       my $user_id = $token3\->user_id();
\&
\&       # acquiring a full user profile once you have a token
\&       my $profile = new Bio::KBase::AuthUser\->new;
\&       $profile\->get( $token3\->token());
\&
\&   } else {
\&       die "Begone, evildoer!\en";
\&   }
.Ve
.SS "Class Variables"
.IX Subsection "Class Variables"
.ie n .IP "\fB\fB%Conf\fB\fR" 4
.el .IP "\fB\f(CB%Conf\fB\fR" 4
.IX Item "%Conf"
This contains the configuration directives from the user's ~/.kbase_config under the section header \*(L"authentication\*(R". All the config settings can be accessed via \f(CW$Bio::KBase::AuthUser::Conf\fR{ 'authentication.NAME'}, where \s-1NAME\s0 is found in the config file under the section heading \*(L"authentication\*(R".
.ie n .IP "\fB\fB@trust_token_signers\fB\fR" 4
.el .IP "\fB\f(CB@trust_token_signers\fB\fR" 4
.IX Item "@trust_token_signers"
An array that contains prefixes for trusted signing URLs in the SigningSubject field of tokens.
.ie n .IP "\fB\fB$token_lifetime\fB\fR" 4
.el .IP "\fB\f(CB$token_lifetime\fB\fR" 4
.IX Item "$token_lifetime"
Additional seconds to add to the expiration time of tokens. Tokens currently issued with a default 24 hour lifetime, but modifying this value will change when the \fIvalidate()\fR function will no longer accept the token. The units are in seconds.
.ie n .IP "\fB\fB@attrs\fB\fR" 4
.el .IP "\fB\f(CB@attrs\fB\fR" 4
.IX Item "@attrs"
List of strings that enumerate the attributes allowed to be read from the \fB.kbase_config\fR file.
.ie n .IP "\fB\fB$VERSION\fB\fR" 4
.el .IP "\fB\f(CB$VERSION\fB\fR" 4
.IX Item "$VERSION"
This is the version string (pulled from the Bio::KBase::Auth module)
.ie n .IP "\fB\fB$TokenCache\fB,$SignerCache\fR" 4
.el .IP "\fB\f(CB$TokenCache\fB,$SignerCache\fR" 4
.IX Item "$TokenCache,$SignerCache"
These are \s-1CSV\s0 formatted strings for the Token and TokenSigner caches that contain 3 fields: last seen time, hash key, value
.Sp
The last seen time is the output from \fItime()\fR when the record was last request or loaded
.Sp
The hash key is a salted \s-1SHA1\s0 hash of the token string (for the TokenCache) or the Signer \s-1URL \s0(for the SignerCache)
.Sp
The value is the username associated with the token (for TokenCache) or the \s-1JSON\s0 document at the Signer \s-1URL \s0(for the SignerCache)
.Sp
Entries are not expired due to any \s-1TTL,\s0 but are pushed out based on their last access time.
.Sp
The cache is searched and timestamps are updated using perl regex functions to achieve good performance. New entries are added and deleted using \fIsplit()\fR, \fIsort()\fR and \fIjoin()\fR for performance as well. When the Shared memory caching option is enabled ( with authentication.shm_cache in the config file), this string is tied into an IPC::Shareable memory region.
.ie n .IP "\fB\fB$TokenCacheSize\fB,$SignerCacheSize\fR integer" 4
.el .IP "\fB\f(CB$TokenCacheSize\fB,$SignerCacheSize\fR integer" 4
.IX Item "$TokenCacheSize,$SignerCacheSize integer"
This is maximum the number of token validations or signer \s-1URL JSON\s0 docs that are kept in the cache. Each time that a new token/signer is added, the entries are sorted in descending time order, and any entries above this number are dropped. This can be configured via the authentication.token_cache_size and authentication.signer_cache_size directive.
.ie n .IP "\fB\fB$CacheKeySalt\fB\fR" 4
.el .IP "\fB\f(CB$CacheKeySalt\fB\fR" 4
.IX Item "$CacheKeySalt"
String used to salt the sha1 hash calculated for cache keys. Set using authentication.cache_salt
.ie n .IP "\fB\fB$TokenVar\fB\fR" 4
.el .IP "\fB\f(CB$TokenVar\fB\fR" 4
.IX Item "$TokenVar"
Shell environment variable that may contain a token to be used as a default token value, defaults to \*(L"\s-1KB_AUTH_TOKEN\*(R".\s0 This environment variable can be overridden by authentication.tokenvar in the .kbase_config file
.ie n .IP "\fB\fB$AuthzDB\fB\fR" 4
.el .IP "\fB\f(CB$AuthzDB\fB\fR" 4
.IX Item "$AuthzDB"
MongoDB::Database reference that is initialized by the authentication.authzdb value from the kbase_config file. The value in the configuration must refer to an existing database in the MongoDB instance referenced by \f(CW$Bio::KBase::Auth::MongoDB\fR. If authentication.authzdb is declared but the authentication.mongodb setting is invalid, or if the database does not exist, then an exception will be thrown at module load time. Do not set this unless you really know what you are doing.
.SS "Instance Variables"
.IX Subsection "Instance Variables"
.IP "\fBuser_id\fR (string)" 4
.IX Item "user_id (string)"
\&\s-1REQUIRED\s0 Userid of the associated with the token
.IP "\fBtoken\fR (string)" 4
.IX Item "token (string)"
A string containing a signed assertion from the Globus Nexus service. Here is an example:
.Sp
un=sychan|clientid=sychan|expiry=1376425658|SigningSubject=https://graph.api.go.sandbox.globuscs.info/goauth/keys/da0a4e96\-e22a\-11e1\-9b09\-1231381bc4c2|sig=88cb32eae2782452817f106a2ce8cf9215f3356ce123d43395a5c99c5ec4184eaf5d70111124a06cf9267e5340f1d06b9258cf2e70e8000000000000000000000000000000583c68755de5453b4b019ebf3d7d4547778ef7d6322f2ba8f42d370bbce4b693ef7a9b3c7be3c6970132e72c654e3274afab9ea39ba9724383f1594
.Sp
It is a series of name value pairs:
.Sp
.Vb 5
\&   un = username
\&   clientid = Globus Nexus client id
\&   expiry = time when the token was issued
\&   SigningSubject = url to the public key used to verify the signature
\&   sig = RSA sha1 signature hash
.Ve
.IP "\fBpassword\fR (string)" 4
.IX Item "password (string)"
The password used to acquire token (if provided). Note that it is not possible to pull down the password from the authentication service.
.IP "\fBclient_secret\fR (string)" 4
.IX Item "client_secret (string)"
An unencrypted openssh formatted \s-1RSA\s0 private key string used for authentication
.IP "\fBkeyfile\fR (string)" 4
.IX Item "keyfile (string)"
File containing a \fBclient_secret\fR (typically something like ~user/.ssh/id_rsa). This must be readable by the effective \s-1UID\s0 of the running process. If the file contains an encrypted passphrase then the \fBkeyfile_passphrase\fR must also be specified. Private keys can be created using the ssh-keygen command (for example \*(L"ssh-keygen \-t rsa \-b 1024 \-f kbase_rsa\*(R")
.IP "\fBkeyfile_passphrase\fR (string)" 4
.IX Item "keyfile_passphrase (string)"
The passphrase used to decrypt the \s-1RSA\s0 private specified in \fBkeyfile\fR. See the ssh-keygen man page for information and setting/clering the passphrase.
.IP "\fBsshagent_keys\fR (hashref keynames => ssh_agent_keys)" 4
.IX Item "sshagent_keys (hashref keynames => ssh_agent_keys)"
Hashref with keyname => rsa_sshkey pairs. The keyname is generated by ssh-agent and is the path to the private. Only \s-1RSA\s0 keys are exposed.
.IP "\fBsshagent_keyname\fR (string)" 4
.IX Item "sshagent_keyname (string)"
String specifying which key in the sshagent to use for authentication. Must match one of the keys in sshagent_keys \- format is typically the path to the private key
.IP "\fBerror_message\fR (string)" 4
.IX Item "error_message (string)"
contains error messages, if any, from most recent method call.
.SS "Methods"
.IX Subsection "Methods"
.IP "\fBnew\fR()" 4
.IX Item "new()"
returns a Bio::KBase::AuthToken reference. Optionally pass in hash params to initialize attributes. If we have enough attributes to perform a login either a token, or (user_id,password) or (user_id,client_secret) then the library will try to acquire a new token from Globus Nexus. If no parameters are given, then the library will look for a readable \s-1INI\s0 file in ~/.kbase_config and extract the attributes that match from \f(CW@Bio::KBase::AuthToken::attrs\fR into the new token an attempt to fetch a token from the Globus Online service. If you wish to short circuit the .kbase_config file, you can pass in a ignore_kbase_config => 1 as a parameter to \fInew()\fR
.Sp
.Vb 1
\&   Examples:
\&
\&   # Acquiring a new token when you have username/password credentials
\&   my $token = Bio::KBase::AuthToken\->new( \*(Aquser_id\*(Aq => \*(Aqmrbig\*(Aq, \*(Aqpassword\*(Aq => \*(AqbigP@SSword\*(Aq);
\&
\&   # or if you have an SSH private key in the string $rsakey
\&
\&   my $token2 = Bio::KBase::AuthToken\->new( \*(Aquser_id\*(Aq => \*(Aqmrbig\*(Aq, \*(Aqclient_secret\*(Aq => $rsakey);
\&
\&   # you have an rsa key in the file /home/mrbig/.ssh/id_rsa and wish to use it for authentication
\&   my $token3 = Bio::KBase::AuthToken\->new( \*(Aquser_id\*(Aq => \*(Aqmrbig\*(Aq, \*(Aqkeyfile\*(Aq => \*(Aq/home/mrbig/.ssh/id_rsa\*(Aq);
\&   
\&   # Whoops, turns out it was encrypted
\&   my $token3 = Bio::KBase::AuthToken\->new( \*(Aquser_id\*(Aq => \*(Aqmrbig\*(Aq, \*(Aqkeyfile\*(Aq => \*(Aq/home/mrbig/.ssh/id_rsa\*(Aq,
\&                                            \*(Aqkeyfile_passphrase\*(Aq => \*(AqL33Tp@55word\*(Aq);
.Ve
.IP "\fBuser_id\fR()" 4
.IX Item "user_id()"
returns the user_id associated with the token, if any. If a single string value is passed in, it will be used to set the value of the user_id
.IP "\fBvalidate\fR()" 4
.IX Item "validate()"
attempts to verify the signature on the token, and returns a boolean value signifying whether the token is legit. If the value in the token attribute is a legitimate kbase session \s-1ID\s0 hash and a session database has been enabled (by the \f(CW$AuthzDB\fR database handle), the session \s-1ID\s0 will be replaced by the associated token, and then validated \- this is only relevant for installations where the session service has been enabled.
